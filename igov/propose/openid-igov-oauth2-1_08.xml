<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN" "http://xml2rfc.tools.ietf.org/authoring/rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='http://xml2rfc.tools.ietf.org/authoring/rfc2629.xslt' ?>
<!-- NOTE: This XML file is input used to produce the authoritative copy
    of an OpenID Foundation specification. The authoritative copy is the HTML
    output. This XML source file is not authoritative. The statement ipr="none"
    is present only to satisfy the document compilation tool and is not indicative
    of the IPR status of this specification. The IPR for this specification is
    described in the "Notices" section. This is a public OpenID Foundation document
    and not a private document, as the private="..." declaration could be taken
    to indicate. -->
<rfc
  category="std"
  
  docName="openid-igov-oauth2-1_08"
  
  ipr="none"
  
  xmlns:xi="http://www.w3.org/2001/XInclude"
  
  submissionType="IETF"
  
  consensus="true" >

  <?rfc tocInclude="yes" ?>

  <?rfc tocdepth="5" ?>

  <?rfc symrefs="yes" ?>

  <?rfc sortrefs="yes" ?>

  <?rfc strict="yes" ?>

  <?rfc iprnotified="no" ?>

  <?rfc private="Draft" ?>
  
    <front>
        <title abbrev="iGov OAuth 2.0">International Government Assurance Profile (iGov)
            for OAuth 2.0 - draft 08</title>

        <author fullname="Kelley Burgin" initials="K." role="editor" surname="Burgin">
            <organization abbrev="MITRE">The MITRE Corporation</organization>
            <address>
                <email>kburgin@mitre.org</email>

            </address>
        </author>
        <author fullname="Tom Clancy" initials="T." role="editor" surname="Clancy">
            <organization abbrev="MITRE">The MITRE Corporation</organization>
            <address>
                <email>tclancy@mitre.org</email>

            </address>
        </author>

        <date day="15" month="September" year="2025"/>

        <workgroup>OpenID iGov Working Group</workgroup>

        <abstract>
            <t>The OAuth 2.0 protocol framework defines a mechanism to allow a
                resource owner to delegate access to a protected resource for a
                client
                application.
            </t>

            <t>This specification profiles the OAuth 2.0 protocol framework to
                increase baseline security, provide greater interoperability, and
                structure deployments in a manner specifically applicable, but not limited to
                consumer-to-government deployments.
            </t>
        </abstract>
    </front>

    <middle>
        <section anchor="Introduction" title="Introduction">
            <t>This document profiles the OAuth 2.0 web authorization framework
                for
                use in the context of securing web-facing application programming
                interfaces (APIs), particularly Representational State Transfer
                (RESTful) APIs. The OAuth 2.0 specifications accommodate a wide
                range of
                implementations with varying security and usability
                considerations,
                across different types of software clients. The OAuth
                2.0 client,
                protected resource, and
                authorization server profiles
                defined in this document serve two
                purposes:
            </t>

            <t>
                <list style="numbers">
                    <t>Define a mandatory baseline set of security controls suitable
                        for
                        a wide range of government use cases, while maintaining
                        reasonable
                        ease of
                        implementation and functionality
                    </t>

                    <t>Identify optional, advanced security controls for sensitive use
                        cases where increased risk justifies more stringent controls.
                    </t>
                </list>
            </t>


            <section anchor="rnc" title="Requirements Notation and Conventions">
                <t>
                    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
                    "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",
                    and
                    "OPTIONAL" in this document are to be interpreted as described
                    in
                    <xref target="RFC2119">RFC 2119</xref>
                    .
                </t>

                <t>
                    All uses of
                    <xref target="RFC7515">JSON Web Signature (JWS)</xref>
                    and
                    <xref target="RFC7516">JSON Web Encryption (JWE)</xref>
                    data
                    structures in this specification utilize the JWS Compact
                    Serialization
                    or the JWE Compact Serialization; the JWS JSON
                    Serialization and the
                    JWE JSON Serialization are not used.
                </t>
            </section>

            <section anchor="Terminology" title="Terminology">
                <t>
                    This specification uses the terms "Access Token", "Authorization
                    Code", "Authorization Endpoint", "Authorization Grant",
                    "Authorization
                    Server", "Client", "Client Authentication", "Client
                    Identifier",
                    "Client Secret", "Grant Type", "Protected Resource",
                    "Redirection
                    URI", "Refresh Token", "Resource Owner", "Resource
                    Server", "Response
                    Type", and "Token Endpoint" defined by
                    <xref target="RFC6749">OAuth
                        2.0</xref>
                    , the terms "Claim Name", "Claim Value", and "JSON Web Token
                    (JWT)"
                    defined by
                    <xref target="RFC7519">JSON Web Token (JWT)</xref>
                    ,
                    and the terms defined by
                    <xref target="OpenID.Core">OpenID Connect
                        Core 1.0</xref>
                    .
                </t>
            </section>

            <section title="Conformance">
                <t>This specification defines requirements for the following
                    components:
                </t>

                <t>
                    <list style="symbols">
                        <t>OAuth 2.0 clients.</t>

                        <t>OAuth 2.0 authorization servers.</t>

                        <t>OAuth 2.0 protected resources.</t>
                    </list>
                </t>

                <t>The specification also defines features for interaction between
                    these components:
                </t>

                <t>
                    <list style="symbols">
                        <t>Client to authorization server.</t>

                        <t>Protected resource to authorization server.</t>
                    </list>
                </t>

                <t>When an iGov-compliant component is interacting with other
                    iGov-compliant components, in any valid combination, all components
                    MUST fully conform to the features and requirements of this
                    specification. All interaction with non-iGov components is outside
                    the scope of this specification.
                </t>

                <t>An iGov-compliant OAuth 2.0 authorization server MUST support all
                    features as described in this specification. A general-purpose
                    authorization server MAY support additional features for use with
                    non-iGov clients and protected resources.
                </t>

                <t>An iGov-compliant OAuth 2.0 client MUST use all functions as
                    described in this specification. A general-purpose client library
                    MAY
                    support additional features for use with non-iGov authorization
                    servers and protected resources.
                </t>

                <t>An iGov-compliant OAuth 2.0 protected resource MUST use all
                    functions as described in this specification. A general-purpose
                    protected resource library MAY support additional features for use
                    with non-iGov authorization servers and clients.
                </t>
            </section>


            <section title="Global Requirements">
             
                 <t>All network connections MUST be made using TLS 1.3 or above.
                 Each originator of a TLS connection MUST verify the destination's certificate.
                 Additionally, the following four TLS 1.2 cipher suites MAY be used:
                      <list>
                      <t>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</t>
                    <t>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</t>
                    <t>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</t>
                    <t>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</t>
                    </list>
                  </t>
                  <t>Implementers of this profile SHOULD monitor the progress of specifications of post-quantum
                 cryptography for TLS implementations.
                 Implementers MAY adopt a cipher suite not included in <xref target="BCP195">BCP195</xref> when post quantum safety
                 is required if the cipher suite is supported in the implementation environment.
                 </t>
                 <t>An example of an emerging PQ cipher suite that is broadly supported at the time of writing is X25519MLKEM768, specified by
                 <xref target="mlkem.ikev2">Post-quantum Hybrid Key Exchange with ML-KEM in the Internet Key Exchange Protocol Version 2 (IKEv2)</xref>.
                 </t>
                 <t>
                 For the authorization_endpoint, the authorization server MAY allow
                 additional cipher suites that are permitted by the latest version of <xref target="BCP195">BCP195</xref>,
                 if necessary to allow sufficient interoperability with users' web browsers or as required by local regulations.
                  </t>
                  <t>
                 NOTE: Permitted cipher suites are those listed in <xref target="BCP195">BCP195</xref> that do not explicitly say MUST NOT use.
                   </t>
         
                  <t>Endpoints for use by web browsers MUST use mechanisms to ensure that connections cannot be downgraded
                 using TLS Stripping attacks. Protected resources MAY implement an HTTP Strict Transport Security policy as defined in
                 <xref target="RFC6797">HTTP Strict Transport Security (HSTS)</xref> to mitigate these attacks. Protected resources SHOULD
                 consider registering web domain names with browsers that offer browser-side ("preload") HSTS policy enforcement to further mitigate
                 TLS downgrade attacks.
                 </t>

            </section>

        </section>

        <section anchor="ClientProfiles" title="Client Profiles">
            <t/>
<section anchor="ClientTypes" title="Client Types">
                <t>
                    OAuth defines two client types, based on their ability to
                       authenticate securely with the authorization server
                </t>
                <t>
                    <list style="hanging">
                        <t hangText="confidential clients:">Clients that have credentials with the authorization server.</t>
                        <t hangText="public clients:">Clients without credentials. Public client use cases are out of scope for this profile.
                            </t>
                        </list>
                    </t>

            </section> <!-- End of ClientTypes section -->

            <section anchor="UseCases" title="Client Type Use Cases">
                <t>This specification has been designed around the following client use cases:</t>
                
                <t>
                    <list style="hanging">
                        <t hangText="web application:">A web application is a client running on a web
                               server.  Resource owners access the client via an HTML user
                               interface rendered in a user agent on the device used by the
                               resource owner.  The client credentials as well as any access
                               tokens issued to the client are stored on the web server and are
                               not exposed to or accessible by the resource owner. 
                               In this use case, web applications are confidential clients and in-scope for this profile.
                        </t>

                        <t hangText="native application:">A native application is a client installed and
                            executed on the device used by the resource owner.  Protocol data
                            and credentials are accessible to the resource owner.  It is
                            assumed that any client authentication credentials included in the
                            application can be extracted.  Dynamically issued access tokens
                            and refresh tokens can receive an acceptable level of protection.
                            On some platforms, these credentials are protected from other
                            applications residing on the same device. 
                            In this use case, native applications are public clients and out of scope for this profile.
                            However, best current practices for native applications are detailed in
                            <xref target="RFC8252">OAuth 2.0 for Native Apps</xref>. In this use case, native applications are public clients.
                        </t>
                        
                        <t hangText="browser-based application:">A browser-based application is a client
                          in which the client code is downloaded from a web server and
                          executes within a user agent (e.g., web browser) on the device
                          used by the resource owner.  Protocol data and credentials are
                          easily accessible (and often visible) to the resource owner.  If
                          such applications wish to use client credentials, it is
                          recommended to utilize the backend for frontend pattern.  Since
                          such applications reside within the user agent, they can make
                          seamless use of the user agent capabilities when requesting
                          authorization. 
                          In this use case, browser-based applications are public clients and out of scope for this profile.
                          However, best current practices are detailed in <xref target="browser-based-apps">OAuth 2.0 for Browser-Based Applications</xref>.</t>
                        </list>
                    </t>
                    	<t>This profile establishes requirements that can only be met by confidential clients. 
						Government implementers with public client use cases are encouraged to consult the best practices
						identified above for those use cases.
						</t>
                </section>
                
                <section anchor="ClientRegistration" title="Client Registration">
                <t>All clients MUST register with the authorization server. For
                    client software that may be installed on multiple client
                    instances,
                    each client instance MAY receive a unique client identifier from
                    the authorization server.
                </t>
                
                <t>Client registration MAY be completed by either out-of-band configuration or using the <xref target="RFC7591">Dynamic Client Registration Protocol</xref>.</t>

                <t> If a client uses <xref target="RFC8705">mTLS</xref> for client authentication or to sender-constrain tokens, the client MUST include the 
                tls_client_certificate_bound_access_tokens parameter in its registration metadata.
                    </t>
                
                <t> If a client uses <xref target="RFC9449">DPoP</xref> to sender constrain tokens, the client MUST include the dpop_bound_access_tokens parameter 
                in its registration metadata.
                    </t>
                  
                <t>Clients using mTLS for client authentication or to sender-constrain tokens MUST register their TLS certificate's subject DN with the 
                authorization server.
                Clients using self-signed certificate option are not guaranteed uniqueness of their certificate fingerprint.</t>
                
                <section anchor="RedirectURI" title="Redirect URI">
                    <t>Clients using the authorization code grant type
                        MUST register
                        their full redirect URIs.
                    </t>

                    <t>Clients MUST protect the values passed back to its redirect
                        URI by ensuring that the redirect URI is one of the following:
                    </t>

                    <t>
                        <list style="symbols">
                            <t>Hosted on a website with Transport Layer Security (TLS)
                                protection (a Hypertext Transfer Protocol - Secure
                                (HTTPS) URI)
                            </t>

                            <t>Hosted on a client-specific non-remote-protocol URI scheme
                                (e.g., myapp://)
                            </t>

                        </list>
                    </t>

                    <t>Clients MUST use a unique redirect URI for each logical authorization server.
                    </t>

                    <t>Clients MUST NOT forward values passed back to their redirect
                        URIs to other arbitrary or user-provided URIs (a practice known as an "open redirector").</t>
                    <t>Refer to <xref target="BCP240">Best Current Practice for OAuth 2.0 Security</xref> Section 2.4.1
                    for additional guidance on implementation of edge cases.
                    </t>
                </section>
            </section>

            <section anchor="PoPTokens" title="Sender-constrained Tokens">
                <t> While a bearer token can be used by anyone in possession of the token, a sender-constrained token is
                bound to a particular symmetric or asymmetric key issued to, or already possessed by, the client.
                The association of the key to the token is also communicated to the protected resource. When the client
                presents the token to the protected resource, it is also required to demonstrate possession of the corresponding key.
                    </t>

                 <t>As described in <xref target="BCP240">Best Current Practice for OAuth 2.0 Security</xref>, sender-constrained tokens could
                prevent a number of attacks on OAuth that entail the misuse of stolen and leaked access tokens by unauthorized parties.
                The attacker would need to obtain the legitimate client's cryptographic key along with the access
                token to gain access to protected resources.
                    </t>
            
            <t> All clients MUST use proof of possession to sender-constrain access tokens using either <xref target="RFC8705">OAuth 2.0 Mutual-TLS 
            Client Authentication and Certificate-Bound Access Tokens</xref> or
            <xref target="RFC9449">OAuth 2.0 Demonstrating Proof of Possession (DPoP)</xref>.
                </t>
                
            </section>

            <section anchor="AuthNContext" title="Authentication Context and Step-Up Authentication Challenge Protocol Support">
                <t>Clients SHOULD support the mechanism specified in <xref target="RFC9470">OAuth 2.0 Step Up Authentication Challenge
                Protocol"</xref> to communicate authentication context and implement interoperable step up authentication.</t>
                
                <t>This profile acknowledges government use cases will likely operate within an ecosystem of authentication methods of highly variable security
                value for the foreseeable future by imposing requirements to enable protected resources with basic capabilities to communicate
                requirements for authentication strength and recency to supporting authorization clients and servers, as well as the capability to enforce access
                policies using access tokens augmented with the strength and recency of the authentication event that led to the issuance of each specific access token.</t>
                
                <t>This profile leverages the supporting server metadata, request, token claims and values, and error messages from <xref target="RFC9470">OAuth 2.0 
                Step Up Authentication Challenge
                Protocol</xref> and <xref target="OpenID.Core">OpenID Connect Core 1.0</xref>.</t>
                
                <t>Digital identity policies and semantic mappings to string values are necessary for implementation but are out of scope for this profile.</t>
                
                <t>OAuth 2.0 MUST NOT be used as an authentication protocol. Use of the <xref target="OpenID.iGov">International Government Assurance Profile (iGov) 
                for OpenID Connect 1.0</xref> is RECOMMENDED to provide the identity
                authentication layer for iGov OAuth 2.0 delegated access use cases.
                </t>
                
            </section>

            
                  
            <section title="Connection to the Authorization Server">
                <section anchor="RequestsToAuthorizationEndpoint" title="Requests to the Authorization Endpoint">
                    <t>All clients MUST use the PKCE S256 code challenge method as described in
                    <xref target="RFC7636">Proof Key for Code Exchange by OAuth Public Clients</xref> and
                    include the "code_challenge" parameter
                    and "code_challenge_method", set to "S256", in the authorization request.
                    </t>
                    <t>
                        Clients making a request to the
                        authorization endpoint MUST use an unpredictable value for the
                        state
                        parameter with at least 128 bits of entropy. Clients MUST
                        validate
                        the value of the
                        <spanx style="verb">state</spanx>
                        parameter upon
                        return to the redirect URI and MUST ensure that the
                        state value is
                        securely tied to the user's current session
                        (e.g., by
                        relating
                        the state value to a session identifier issued by
                        the client
                        software to the browser).
                    </t>
                    
                    <t>Clients that have multiple client types MUST have a separate client ID for each client type.</t>

                    <t>Clients MUST include their full redirect URI in the
                        authorization request.
                    </t>
                    
                     <t>The client MAY specify a strength of authentication and maximum age to the authorization server that should be met
                        when issuing an access token for the requesting client by including parameters in the authorization request:</t>
                        <list style="hanging">
                            <t hangText="acr_values"> a space-separated string listing the authentication context class reference values in order of preference.
                            The protected resource requires one of these values for the authentication event associated with the access token.  As defined
                            in Section 1.2 of <xref target="OpenID.Core">OpenID Connect Core 1.0 </xref>, the authentication context conveys information about how
                            authentication takes place (e.g., what authentication
                            method(s) or assurance level to meet).  It is out of scope of this document to determine how an organization semantically maps their
                            digital identity practices to acr values that identify levels of assurance.
                            </t>
                            <t hangText="max_age"> a non-negative integer value that indicates the allowable elapsed time in seconds since the last active authentication event
                            associated with the access token.
                            </t>
                            </list>
                            
                        <t>Furthermore, if the authorization request is a follow-up to a prior request that did not meet the resource server's initial or subsequent
                        authentication strength or recency requirements, the client should include the acr_values and/or max_age values sent by the resource server with
                        the insuffient_user_authentication error code that specify expected strength and recency requirements to be provided to the authentication provider,
                        such as the OpenID Provider, in a new authentication request.</t>
                        
                    <t>The following is a sample response from a client to
                        the
                        end user's browser for the purpose of redirecting the end
                        user
                        to the authorization server's authorization endpoint:
                    </t>

                    <figure>
                        <artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

HTTP/1.2 302 Found
Cache-Control: no-cache
Connection: close
Content-Type: text/plain; charset=UTF-8
Date: Wed, 07 Jan 2015 20:24:15 GMT
Location: \
  https://idp-p.example.com/authorize?client_id=55f9f559-2496-49d4-b\
6c3-351a586b7484&response_type=code&scope=openid+email&redirect_uri=\
https%3A%2F%2Fclient.example.org%2Fcb&acr_values=myACR&max_age=1800\
Status: 302 Found
]]></artwork>
                    </figure>

                    <t>This causes the browser to send the following (non-normative) request to the
                        authorization endpoint (inline wraps for display purposes only):
                    </t>

                    <figure>
                        <artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

GET /authorize?
   client_id=55f9f559-2496-49d4-b6c3-351a586b7484
  &nonce=cd567ed4d958042f721a7cdca557c30d
  &response_type=code
  &scope=openid+email
  &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb HTTP/1.1
Host: idp-p.example.com
]]></artwork>
                    </figure>
            </section>

            <section anchor="RequestsToTokenEndpoint" title="Requests to the Token Endpoint">
                    <t>
                        Clients MUST
                        authenticate to the authorization server's token endpoint using either
                        the private_key_jwt method as defined in
                        <xref target="OpenID.Core">OpenID Connect Core</xref>
                        or
                        the mutually-authenticated transport layer security (mTLS) request method
                        defined in
                        <xref target="RFC8705">OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens</xref>.</t>
                        <t>If using the private_key_jwt method, the request MUST be a JWT assertion as defined by the
                        <xref target="RFC7523">JWT Profile for OAuth 2.0 Client Authentication and Authorization Grants</xref>. The JWT assertion MUST be signed 
                        by the client using the client's private key.
                        If using <xref target="RFC8705">mTLS</xref>, the request MUST be made over a mutually authenticated TLS channel.</t>

            </section>


            <section title="Client Keys">
                    <t>
                        Confidential clients MUST have a
                        public/private key pair for use in authentication to the token
                        endpoint. These clients MUST either send the public key
                        directly in the
                        <spanx style="verb">jwks</spanx>
                        field or
                        register a
                        <spanx style="verb">jwks_uri</spanx>
                        that is
                        reachable by the authorization server. It is
                        RECOMMENDED that
                        clients use a
                        <spanx style="verb">jwks_uri</spanx>
                        if possible as
                        this allows for key rotation more easily. This applies to both
                        dynamic and out-of-band client registration.
                    </t>

                    <t>
                        The
                        <spanx style="verb">jwks</spanx>
                        field or the content
                        available from the
                        <spanx style="verb">jwks_uri</spanx>
                        of a client
                        MUST contain a public key in
                        <xref target="RFC7517">JSON Web Key Set
                            (JWK Set)</xref>
                        format. The authorization server MUST validate the
                        content of the
                        client's registered jwks_uri document and verify that
                        it contains a
                        JWK Set. The following example is of a 2048-bit RSA
                        key:
                    </t>

                    <figure>
                        <artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

{
   "keys": [
     {
       "alg": "RS256",
       "e": "AQAB",
      "n": "kAMYD62n_f2rUcR4awJX4uccDt0zcXRssq_mDch5-ifcShx9aTtTVza2\
3PTn3KaKrsBXwWcfioXR6zQn5eYdZQVGNBfOR4rxF5i7t3hfb4WkS50EK1gBYk2lO9NS\
rQ-xG9QsUsAnN6RHksXqsdOqv-nxjLexDfIJlgbcCN9h6TB-C66ZXv7PVhl19gIYVifS\
U7liHkLe0l0fw7jUI6rHLHf4d96_neR1HrNIK_xssr99Xpv1EM_ubxpktX0T925-qej9\
fMEpzzQ5HLmcNt1H2_VQ_Ww1JOLn9vRn-H48FDj7TxlIT74XdTZgTv31w_GRPAOfyxEw\
_ZUmxhz5Z-gTlQ",
       "kty": "RSA",
       "kid": "oauth-client"
     }
   ]
}
]]></artwork>
                    </figure>

                    <t>For reference, the corresponding public/private key pair for
                        this
                        public key is the following (in JWK format):
                    </t>

                    <figure>
                        <artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

{
  "alg": "RS256",
  "d": "PjIX4i2NsBQuOVIw74ZDjqthYsoFvaoah9GP-cPrai5s5VUIlLoadEAdGbBr\
ss_6dR58x_pRlPHWh04vLQsFBuwQNc9SN3O6TAaai9Jg5TlCi6V0d4O6lUoTYpMR0cxF\
IU-xFMwII--_OZRgmAxiYiAXQj7TKMKvgSvVO7-9-YdhMwHoD-UrJkfnZckMKSs0BoAb\
jReTski3IV9f1wVJ53_pmr9NBpiZeHYmmG_1QDSbBuY35Zummut4QShF-fey2gSALdp9\
h9hRk1p1fsTZtH2lwpvmOcjwDkSDv-zO-4Pt8NuOyqNVPFahROBPlsMVxc_zjPck8ltb\
lalBHPo6AQ",
  "e": "AQAB",
  "n": "kAMYD62n_f2rUcR4awJX4uccDt0zcXRssq_mDch5-ifcShx9aTtTVza23PTn\
3KaKrsBXwWcfioXR6zQn5eYdZQVGNBfOR4rxF5i7t3hfb4WkS50EK1gBYk2lO9NSrQ-x\
G9QsUsAnN6RHksXqsdOqv-nxjLexDfIJlgbcCN9h6TB-C66ZXv7PVhl19gIYVifSU7li\
HkLe0l0fw7jUI6rHLHf4d96_neR1HrNIK_xssr99Xpv1EM_ubxpktX0T925-qej9fMEp\
zzQ5HLmcNt1H2_VQ_Ww1JOLn9vRn-H48FDj7TxlIT74XdTZgTv31w_GRPAOfyxEw_ZUm\
xhz5Z-gTlQ",
  "kty": "RSA",
  "kid": "oauth-client"
}
]]></artwork>
                    </figure>

                    <t>Note that the second example contains both the public and
                        private
                        keys, while the first example contains the public key only.
                    </t>

            </section> <!-- End of Client keys -->
                
        </section> <!-- End of Connections to AS section -->

        <section title="Connection to the Protected Resource">
            <section anchor="RequestsToProtectedResource" title="Requests to the Protected Resource">
                    <t>

                        Clients MUST use the authorization request header field mechanism to send bearer tokens as defined by
                        <xref target="RFC6750"/>.
                    </t>


                    <t>An example of an OAuth-protected call to the OpenID Connect
                        UserInfo endpoint, sending the token in the Authorization header,
                        follows:
                    </t>

                    <figure>
                        <artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

GET /userinfo HTTP/1.1
Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJleHAiOjE0MTg3MDI0MTIsI\
\mF1ZCI6WyJjMWJjODRlNC00N2VlLTRiNjQtYmI1Mi01Y2RhNmM4MWY3ODgiXSwiaXNz\
IjoiaHR0cHM6XC9cL2lkcC1wLmV4YW1wbGUuY29tXC8iLCJqdGkiOiJkM2Y3YjQ4Zi1i\
YzgxLTQwZWMtYTE0MC05NzRhZjc0YzRkZTMiLCJpYXQiOjE0MTg2OTg4MTJ9.iHMz_tz\
Z90_b0QZS-AXtQtvclZ7M4uDAs1WxCFxpgBfBanolW37X8h1ECrUJexbXMD6rrj_uuWE\
qPD738oWRo0rOnoKJAgbF1GhXPAYnN5pZRygWSD1a6RcmN85SxUig0H0e7drmdmRkPQg\
bl2wMhu-6h2Oqize4dKmykN9UX_2drXrooSxpRZqFVYX8PkCvCCBuFy2O-HPRov_SwtJ\
Mk5qjUWMyn2I4Nu2s-R20aCA-7T5dunr0iWCkLQnVnaXMfA22RlRiU87nl21zappYb1_\
EHF9ePyq3Q353cDUY7vje8m2kKXYTgc_bUAYuW-W3SMSw5UlKa
]]></artwork>
                    </figure>


        </section> <!-- End of Connections to Protected Resource section -->
            </section>


    </section> <!-- End of Client profile section -->

    <section anchor="ServerProfile" title="Authorization Server Profile">
            <t>
                All servers MUST conform to applicable recommendations found in the
                Security Considerations sections of
                <xref target="RFC6749"/>
                and those
                found in the
                <xref target="RFC6819">OAuth Threat Model
                    Document</xref>.
            </t>

            <t>The authorization server MUST protect all communications to and
                from
                its OAuth endpoints using TLS as described in Section 1.4.
            </t>


            <section title="Connections with clients">
                <t/>

                <section title="Grant types">
                    <t>
                        Authorization servers MUST support the
                        <spanx style="verb">authorization_code</spanx> grant type and MAY support the
                        <spanx style="verb">client_credentials</spanx>
                        grant type. The implicit grant type MUST NOT be used.</t>
                    <t>Authorization servers MUST limit each registered client (identified by a client ID) 
                    to a single client type only, since a single piece of software will be functioning at runtime as only one client type.
                    </t>
                </section>

                <section title="Client authentication">
                    <t>Authorization servers MUST enforce client authentication for confidential clients. Public clients cannot authenticate 
                    to the authorization server. Authorization servers MUST support the RS256 signature method (the Rivest, Shamir, and Adleman 
                    (RSA) signature algorithm with a 256-bit hash) and MAY use other asymmetric signature methods listed in
                    <xref target="RFC7518">JSON Web Algorithms (JWA) [RFC7518]</xref>.
                    </t>
                    
                    
                    <t> The authorization server MUST validate all redirect
                        URIs for authorization code grant types.
                    </t>
                    <t> The authorization server MUST confirm thumbprints of client keys.
                    </t>
                    
                    <t> Authorization servers MUST only grant access to higher level scope resources to
                        clients that have permission to request these scope levels. Authorization servers MUST reject client authorization requests 
                        containing scopes that are outside their permission.
                    </t>
            
                    <t>Authorization servers MAY set the expiry time (<spanx style="verb">exp</spanx>)
                       of access_tokens associated with higher level resources to be shorter than
                       access_tokens for less sensitive resources.
                    </t>
                    
                    <t>Authorization servers MAY allow a <spanx style="verb">refresh_token</spanx>
                     issued at a higher level to be
                        used to obtain an access_token for a lower level resource scope with an
                        extended expiry time. The client MUST request both the higher level scope and
                        lower level scope in the original authorization request. This allows clients to
                        continue accessing lower level resources after the higher level resource access
                        has expired -- without requiring an additional user authentication/authorization.
                    </t>
                    <t>When a client requests both a higher level scope and a lower level scope in the original authorization request, Authorization 
                    servers MAY allow refresh tokens issued at the higher level to be used to obtain an access_token for a lower level resource scope 
                    with an extended expiry time. This allows clients to continue accessing lower level resources after the higher level resource 
                    access has expired without requiring an additional user authentication/authorization. </t>
                </section>

                <section anchor="DynamicRegistration" title="Dynamic Registration">
                    <t>
                        Dynamic Registration allows for authorized Clients to on-board programmatically without administrative intervention. 
                        This is particularly important in ecosystems with many potential Clients, including Mobile Apps acting as independent Clients. 
                        Authorization servers MUST support dynamic client registration,
                        and clients MAY register using the
                        <xref target="RFC7591">Dynamic
                            Client Registration Protocol</xref>
                        for authorization code grant types. Clients MUST NOT
                        dynamically
                        register for the
                        client credentials grant type.
                        Authorization
                        servers MAY limit the
                        scopes available to dynamically
                        registered
                        clients.
                    </t>

                    <t>    Authorization
                        <!-- Should we make this a MUST? -->
                        servers MAY protect their Dynamic Registration endpoints by requiring clients to present credentials that the authorization 
                        server would recognize as authorized participants. Authorization servers MAY accept signed software statements as described 
                        in <xref target="RFC7591"/>
                        issued to client software developers from a
                        trusted registration
                        entity. The software statement can be used to
                        tie together many
                        instances of the same client software that will be
                        run, dynamically
                        registered, and authorized separately at runtime.
                        The software
                        statement MUST include the following client metadata
                        parameters:
                    </t>

                    <t>
                        <list style="hanging">
                            <t hangText="redirect_uris">
                                array of redirect URIs used by the
                                client; subject to the
                                requirements listed in
                                <xref target="RedirectURI"/>
                            </t>

                            <t hangText="grant_types">grant type used by the client; must be
                                "authorization_code" or "client_credentials"</t>

                            <t hangText="client_name">human-readable name of the client</t>

    
                            <t hangText="client_uri">URL of a web page containing further
                                information
                                about the client
                            </t>
                            <t hangText="tls_client_certificate_bound_access_tokens">
                                REQUIRED. Boolean value indicating server support for mutual-TLS client certificate-bound access tokens.
                                                        </t>
                                                        
                            <t hangText="acr_values_supported">OPTIONAL. Indicates the client will include the acr_values and max_age
                                   parameters in authorization requests, and send insufficient_user_authentication error messages in conformance
                                with <xref target="RFC9470">OAuth 2.0 Step Up Authentication Challenge Protocol</xref>.</t>
                                                        
                            <t hangText="dpop_signing_alg_values_supported">
                                REQUIRED. A JSON array containing a list of the JWS alg values supported by the client for DPoP proof JWTs.
                                                        </t>

                            <t hangText="jwks_uri or jwks">client's public key in a JWK Set [RFC7517], or
                                if jwks_uri is used it MUST be reachable by the Authorization Server and
                                point to the client's public key set. If the PKI/tls_client_auth method is used, the public key must be issued
                                by a trusted Certificate Authority.
                                If either the self-signed mTLS method or private_key_jwt method for client authentication is used, the jwks MUST include a certificate.
                            </t>

                        </list>
                        A client using the tls_client_auth authentication method MUST use exactly one of the below metadata parameters to indicate the certificate
                        subject value that the authorization server is to expect when authenticating the respective client:
                        <list style="hanging">
                            <t hangText="tls_client_auth_subject_dn">String value specifying the expected subject DN of the client certificate.</t>
                            <t hangText="tls_client_auth_san_dns">String value specifying the expected dNSName SAN entry in the client certificate.</t>
                            <t hangText="tls_client_auth_san_uri">String value specifying the expected uniformResourceIdentifier SAN entry in the client certificate.</t>
                        </list>
                        It is NOT RECOMMENDED that authorization servers use IP address or email address to identify 
                        authenticating clients. It is also NOT RECOMMENDED that authorization servers use tls_client_auth_san_ip or tls_client_auth_san_email metadata values
                    </t>
                </section>

                <section anchor="ClientApproval" title="Client Approval">
                    <t>When prompting the end user with an interactive approval page,
                        the authorization server MUST indicate to the user:
                    </t>

                    <t>
                        <list style="symbols">
                            <t>Whether the client was dynamically registered, or else
                                statically registered by a trusted administrator.
                            </t>

                            <t>Whether the client is associated with a software statement,
                                and in which case provide information about the trusted issuer
                                of the software statement.
                            </t>

                            <t>What kind of access the client is requesting, including
                                scope, protected resources (if applicable beyond scopes),
                                and access duration.
                            </t>
                        </list>
                    </t>
                    
                    <t>For example, if the user believes they are authorizing a very limited type of access,
                     providing the access level at the consent screen may help the user make informed decisions about
                     sharing sensitive information.
                    </t>
                </section>

                 <section title="Sender-constrained Tokens">
                    <t> The authorization server MUST support and verify sender-constrained tokens.
                        </t>
                    
                    <t>The Authorization Server MUST NOT issue the client an access token if the client included the
                    <spanx style="verb">tls_client_certificate_bound_access_tokens</spanx>
                    parameter in its registration metadata and makes a request to the token endpoint over connection not secured by TLS.
                        </t>
                    </section>

                <section anchor="Discovery" title="Discovery">
                    <t>
                        The authorization server MUST provide an
                        <xref target="OpenID.Discovery">OpenID Connect service discovery</xref>
                        endpoint listing the components relevant to the OAuth 2.0 protocol:
                        <list style="hanging">
                            <t hangText="issuer"> REQUIRED. The fully qualified issuer URL of the
                                server
                            </t>

                            <t hangText="authorization_endpoint">
                                REQUIRED. The fully qualified URL of
                                the server's authorization endpoint
                                defined by
                                <xref target="RFC6749">OAuth 2.0</xref>
                            </t>

                            <t hangText="token_endpoint">
                                REQUIRED. The fully qualified URL of the
                                server's token endpoint defined by
                                <xref target="RFC6749">OAuth
                                    2.0</xref>
                            </t>

                            <t hangText="token_endpoint_auth_method">
                                REQUIRED. String of values corresponding to permitted methods for client authentication to the authorization server
                                as defined in <xref target="RFC7591">OAuth 2.0 Dynamic Client Registration Protocol</xref>.
                                Within this profile, the server MUST provide one or more of the following values: "private_key_jwt", "tls_client_auth", 
                                and "self_signed_tls_auth".
                            </t>
                            
                            <t hangText="introspection_endpoint">
                                OPTIONAL. The fully qualified URL of
                                the server's introspection endpoint
                                defined by
                                <xref target="RFC7662">OAuth Token Introspection</xref>
                            </t>

                            <t hangText="revocation_endpoint">
                                OPTIONAL. The fully qualified URL of the
                                server's revocation endpoint
                                defined by
                                <xref target="RFC7009">OAuth 2.0 Token Revocation</xref>
                            </t>
                            <t hangText="mtls_endpoint_aliases">
                                OPTIONAL. A JSON object containing alternative
                                authorization server endpoints that, when present, an OAuth client intending to perform
                                mutual TLS uses in preference to the conventional endpoints. Use of this parameter enables isolation
                                of mTLS behavior to only clients intending to use mTLS for authentication or sender-constraining tokens.
                                Usage of the parameter is specified in
                                <xref target="RFC8705">OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens</xref>
                            </t>
                            <t hangText="jwks_uri">
                                REQUIRED. The fully qualified URI of the server's
                                JWK as defined in
                                <xref target="RFC8414">OAuth 2.0 Authorization Server Metadata</xref>.
                                If the self_signed_tls_auth method is used, a jwks_uri MUST be registered and MUST include a certificate.
                            </t>
                        </list>
                    </t>
                        
                    <t>If a client uses <xref target="RFC8705">OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens</xref>S for 
                    client authentication, exactly one authentication method metadata value MUST be included.
                        <list style="hanging">
                            <t hangText="tls_client_auth">Indicates that client authentication to the authorization server will occur with mutual TLS
                                utilizing the PKI method of associating a certificate to a client.</t>
                            <t hangText="self_signed_tls_client_auth">Indicates that client authentication to the authorization server will occur using mutual TLS
                                with the client utilizing a self-signed certificate.</t>
                        </list>
                    </t>
                    
                    <t>If the authorization server is also an OpenID Connect Provider,
                        it MUST provide a discovery endpoint meeting the requirements
                        listed
                        in Section 3.6 of <xref target="OpenID.Core">OpenID Connect Core 1.0</xref>.
                    </t>

                    <t>The following example shows a JSON document found at the
                        discovery endpoint for an authorization server:
                    </t>

                    <figure>
                        <artwork><![CDATA[{
  "request_parameter_supported": true,
  "registration_endpoint": "https://idp-p.example.com/register",
  "userinfo_signing_alg_values_supported": [
    "HS256", "HS384", "HS512", "RS256", "RS384", "RS512"
  ],
  "token_endpoint": "https://idp-p.example.com/token",
  "request_uri_parameter_supported": false,
  "request_object_encryption_enc_values_supported": [
    "A192CBC-HS384", "A192GCM", "A256CBC+HS512",
    "A128CBC+HS256", "A256CBC-HS512",
    "A128CBC-HS256", "A128GCM", "A256GCM"
  ],
  "token_endpoint_auth_methods_supported": [
    "private_key_jwt",
  ],
  "jwks_uri": "https://idp-p.example.com/jwk",
  "authorization_endpoint": "https://idp-p.example.com/authorize",
  "require_request_uri_registration": false,
  "introspection_endpoint": "https://idp-p.example.com/introspect",
  "request_object_encryption_alg_values_supported": [
    "RSA-OAEP", ?RSA1_5", "RSA-OAEP-256"
  ],
  "service_documentation": "https://idp-p.example.com/about",
  "response_types_supported": [
    "code", "token"
  ],
  "token_endpoint_auth_signing_alg_values_supported": [
    "HS256", "HS384", "HS512", "RS256", "RS384", "RS512"
  ],
  "revocation_endpoint": "https://idp-p.example.com/revoke",
  "request_object_signing_alg_values_supported": [
    "HS256", "HS384", "HS512", "RS256", "RS384", "RS512"
  ],
  "grant_types_supported": [
    "authorization_code",
    "client_credentials"
  ],
  "scopes_supported": [
    "profile", "openid", "email", "address", "phone", "offline_access"
  ],
  "op_tos_uri": "https://idp-p.example.com/about",
  "issuer": "https://idp-p.example.com/",
  "op_policy_uri": "https://idp-p.example.com/about"
  "tls_client_certificate_bound_access_tokens": "true"
  "dpop_signing_alg_values_supported": ["PS256", "ES256"]
}
]]></artwork>
                    </figure>
                    
                    <t>It is RECOMMENDED that authorization servers provide cache information through HTTP headers and make the cache valid for at 
                    least one week. This allows clients and protected resources to cache the discovery information.</t>
                    
                    <t> Authorization servers MUST support the RS256 signature method (the Rivest, Shamir, and Adleman (RSA) signature algorithm 
                    with a 256-bit hash) and MAY use other asymmetric signature methods listed in the JSON Web Algorithms (JWA [RFC7518]) ) specification.</t>

                    <t>The authorization server MUST provide its public key in JWK Set format. The
                        key
                        MUST contain the following fields:
                    </t>

                    <t>
                        <list style="hanging">
                            <t hangText="kid">The key ID of the key pair used to sign this
                                token
                            </t>

                            <t hangText="kty">The key type</t>

                            <t hangText="alg">The default algorithm used for this key</t>
                        </list>
                    </t>

                    <t>The following is an example of a 2048-bit RSA public key:</t>

                    <figure>
                        <artwork><![CDATA[{
NOTE: '\' line wrapping per RFC 8792

"keys": [
   {
     "alg": "RS256",
     "e": "AQAB",
     "n": "o80vbR0ZfMhjZWfqwPUGNkcIeUcweFyzB2S2T-hje83IOVct8gVg9FxvHP\
K1ReEW3-p7-A8GNcLAuFP_8jPhiL6LyJC3F10aV9KPQFF-w6Eq6VtpEgYSfzvFegNiPt\
pMWd7C43EDwjQ-GrXMVCLrBYxZC-P1ShyxVBOzeR_5MTC0JGiDTecr_2YT6o_3aE2SIJ\
u4iNPgGh9MnyxdBo0Uf0TmrqEIabquXA1-V8iUihwfI8qjf3EujkYi7gXXelIo4_gipQ\
YNjr4DBNlE0__RI0kDU-27mb6esswnP2WgHZQPsk779fTcNDBIcYgyLujlcUATEqfCaP\
DNp00J6AbY6w",
     "kty": "RSA",
     "kid": "rsa1"
    }
  ]
}
]]></artwork>
                    </figure>

                </section>

                <section title="Revocation">
 
                    <t>Token revocation allows a client to signal to an authorization
                        server that a given token will no longer be used.
                    </t>

                    <t>Authorization servers MUST provide a revocation endpoint URL as
                    specified in <xref target="RFC7009">OAuth 2.0 Token Revocation</xref>
                    for end users to view a list of clients that have been granted access to resources on the
                    user's behalf and for end users to revoke this access.</t>
                    
                    <t>Authorization servers MUST revoke a token if the client
                        requesting the revocation is the client to which the token was
                        issued, the client has permission to revoke tokens, and the token
                        is able to be revoked.
                    </t>

                    <t>Authorizatin servers MUST NOT allow a client to use a token
                        after it is revoked.
                    </t>
                </section>

                <section title="PKCE">
                    <t>Authorization servers MUST require use of PKCE
                        (<xref target="RFC7636">Proof Key for Code Exchange by OAuth Public Clients</xref>) by all clients
                        and reject requests to the authorization endpoint from clients that do not contain a code challenge.</t>
                        <t>Authorization servers MUST support the S256 code challenge method. Authorization servers MUST NOT allow a 
                        client to use the plain code challenge method.</t>
                        <t>The PKCE code_verifier value MUST contain at least 128 bits of entropy.</t>
                        
                        <t>Authorization servers MUST confirm thumbprints of client keys.</t>
                        
                        


                </section>

                <section title="Redirect URIs">
                    <t>The authorization server MUST validate all redirect URIs for authorization code grant types.</t>
                    <t> To prevent open redirection and other injection attacks, the authorization server MUST match the entire redirect 
                    URI using an exact string match against registered values and MUST reject requests with an invalid or missing redirect URI.</t>
                </section>
                <section title="Refresh Tokens">
                    <t>Authorization servers MAY issue refresh tokens to clients.
                    </t>
                </section>
            </section>

            <section title="Response to Authorization Requests">
                <t> Authorization servers respond to an Authorization Request from a client with an Authorization Response. 
                The following fields MUST be included in the response:
                    <list style="hanging">

                        <t hangText="state"> REQUIRED. The value of the state parameter passed in in the
                            authentication request. This value MUST match exactly.</t>

                        <t hangText="code"> REQUIRED. The authorization code, a random string issued by
                            the IdP to be used in the request to the token endpoint.</t>

                    </list>
                </t>
                <t>
                    PKCE parameters MUST be associated with the authorization code as per Section 4.4 of
                    <xref target="RFC7636">Proof Key for Code Exchange by OAuth Public Clients (PKCE)</xref>.
                </t>
                <t> The following is an example response:</t>
                <figure>
                    <artwork><![CDATA[
https://https://client.example.org/cb?
    state=2ca3359dfbfd0
   &code=gOIFJ1hV6Rb1sxUdFhZGACWwR1sMhYbJJcQbVJN0wHA
]]></artwork>
                </figure>
        </section>
            
            <section anchor="JWTokens" title="JSON Web Tokens (JWT)">
                <t>Authorization servers MUST issue
                    cryptographically signed sender-constrained tokens in the JSON Web Token (JWT)
                    format as defined in <xref target="RFC9068">JSON Web Token (JWT) Profile for OAuth
                    2.0 Access Tokens</xref>.
                    The information carried in the JWT is intended to allow a
                    protected
                    resource to quickly test the integrity of the token
                    without
                    additional network calls, and to allow the protected
                    resource to
                    determine which authorization server issued the token.
                    The protected resource MAY use the authorization server token introspection service
                    to retrieve additional security information about the token.
                </t>

                <t>The server MUST issue tokens as JWTs with, at minimum, the
                    following claims:
                </t>

                <t>
                    <list style="hanging">
                        <t hangText="iss">The issuer URL of the server that issued the
                            token
                        </t>

                        <t hangText="client_id">The client id of the client to whom this token
                            was
                            issued
                        </t>

                        <t hangText="exp">The expiration time (integer number of seconds
                            since from 1970-01-01T00:00:00Z UTC), after which the token MUST
                            be considered invalid
                        </t>

                        <t hangText="jti">A unique JWT Token ID value with at least 128
                            bits
                            of entropy. This value MUST NOT be re-used in another
                            token.
                            Clients MUST check for reuse of jti values and reject all
                            tokens
                            issued with duplicate jti values.
                        </t>

                        <t hangText="sub">The identifier of the end-user that authorized
                            this
                            client, or the client id of a client acting on its own
                            behalf
                            (such as a bulk transfer). Since this information could
                            potentially leak private user information, it should be used
                            only when needed. End-user identifiers SHOULD be pairwise
                            anonymous identifiers unless the audience requires otherwise.
                        </t>

                        <t hangText="aud">The audience of the token, an array containing
                            the
                            identifier(s) of protected resource(s) for which the token
                            is
                            valid, if this information is known. The aud claim may
                            contain
                            multiple values if the token is valid for multiple
                            protected
                            resources. Note that at runtime, the authorization
                            server may not
                            know the identifiers of all possible protected
                            resources at which
                            a token may be used.
                        </t>
                        
                        <t hangText="scope">The value of the scope claim is a JSON string containing a
                            space-separated list of scopes associated with the token, in the format
                            described in Section 3.3 of <xref target="RFC6749">The OAuth 2.0 Authorization
                            Framework</xref>.</t>
                            
                        <t hangText="iat">The "iat" (issued at) claim identifies the time at which the JWT
                            was issued.  This claim can be used to determine the age of the JWT.  Its value MUST
                            be a number containing a NumericDate value.
                        </t>
                        <t hangText="cnf">The confirmation claim, as defined in <xref target="RFC7800">Proof-of-Possession Key Semantics
                                            for JSON Web Tokens (JWTs)</xref> and <xref target="RFC8705">OAuth 2.0 Mutual-TLS
                                            Client Authentication and Certificate-Bound Access Tokens</xref> is used in a JWT to contain 
                                            members used to identify the proof-of-possession key.</t>
                                            <t>When <xref target="RFC8705">OAuth 2.0 Mutual-TLS
                                            Client Authentication and Certificate-Bound Access Tokens</xref>is used, the confirmation 
                                            claim value MUST be computed using the
                                            X.509 Certificate SHA-256 Thumbprint and include confirmation
                                            method value "x5t#256".</t>
                                            <t>When <xref target="RFC9449">OAuth 2.0 Demonstrating Proof of Possession (DPoP)</xref> 
                                            is used, the confirmation claim value MUST be computed using the <xref target="RFC7638">JWK SHA-256 
                                            Thumbprint</xref> of the DPoP public key and include conformation method value jkt.
                                        </t>
                        
                    </list>
                </t>
                        <t>In order to support backwards compatibility, AS MAY include the azp claim while resource servers
                        modernize.</t>
                        

                <t>The following sample claim set illustrates the use of the
                    required claims for an access token as defined in this profile;
                    additional claims MAY be included in the claim set:
                </t>

                <figure>
                    <artwork><![CDATA[{
"exp": 1418702388,
"client_id": "55f9f559-2496-49d4-b6c3-351a586b7484",
"azp": "55f9f559-2496-49d4-b6c3-351a586b7484",
"iss": "https://idp-p.example.com/",
"sub" : "93ff28e3-3982-c34b-f2a4-98bb3d42b277",
"jti": "2402f87c-b6ce-45c4-95b0-7a3f2904997f",
"iat": 1418698788,
"scope" : "MyResource1 MyResource2",
"acr": "myACR",
"auth_time": 16463400198,
"cnf": {
   "x5t#S256":"A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0"
   }
}
]]></artwork>
                </figure>

                <t>
                    The access tokens MUST be signed with
                    <xref target="RFC7515">JWS</xref>
                    . If private_key_jwt is used, the authorization server MUST support
                    the RS256 signature method
                    for tokens and MAY use other asymmetric
                    signing methods as defined
                    in the
                    <xref target="JWS.JWE.Algs">IANA
                        JSON Web Signatures and Encryption
                        Algorithms registry</xref>
                    . The
                    JWS header MUST contain the following fields:
                </t>

                <t>
                    <list style="hanging">
                        <t hangText="kid">The key ID of the key pair used to sign this
                            token
                        </t>
                    </list>
                </t>

                <t>This example access token has been signed with the server's
                    private key using RS256:
                </t>

                <figure>
                    <artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

eyJhbGciOiJSUzI1NiJ9.ew0KICAgImV4cCI6IDE0MTg3MDIzODgsDQogICAiYXpwIjo\
gIjU1ZjlmNTU5LTI0OTYtNDlkNC1iNmMzLTM1MWE1ODZiNzQ4NCIsDQogICAiaXNzIjo\
gImh0dHBzOi8vaWRwLXAuZXhhbXBsZS5jb20vIiwNCiAgICJqdGkiOiAiMjQwMmY4N2M\
tYjZjZS00NWM0LTk1YjAtN2EzZjI5MDQ5OTdmIiwNCiAgICJpYXQiOiAxNDE4Njk4Nzg\
4LA0KICAgImtpZCI6ICJyc2ExIg0KfQ.iB6Ix8Xeg-L-nMStgE1X75w7zgXabzw7znWU\
ECOsXpHfnYYqb-CET9Ah5IQyXIDZ20qEyN98UydgsTpiO1YJDDcZV4f4DgY0ZdG3yBW3\
XqwUQwbgF7Gwza9Z4AdhjHjzQx-lChXAyfL1xz0SBDkVbJdDjtXbvaSIyfF7ueWF3M1C\
M70-GXuRY4iucKbuytz9e7eW4Egkk4Aagl3iTk9-l5V-tvL6dYu8IlR93GKsaKE8bng0\
EZ04xcnq8s4V5Yykuc_NARBJENiKTJM8w3wh7xWP2gvMp39Y0XnuCOLyIx-J1ttX83xm\
pXDaLyyY-4HT9XHT9V73fKF8rLWJu9grrA
]]></artwork>
                </figure>

                <t>
                    Refresh tokens SHOULD be signed with
                    <xref target="RFC7515">JWS</xref>
                    using the same private key and contain
                    the same set of claims as
                    the
                    access tokens.
                </t>

                <t>
                    The authorization server MAY encrypt access tokens and refresh
                    tokens using
                    <xref target="RFC7516">JWE</xref>
                    . Encrypted access
                    tokens MUST be encrypted using the public key of
                    the protected
                    resource. Encrypted refresh tokens MUST be encrypted
                    using the
                    authorization server's public key.
                </t>
                <t>The client SHOULD use a certificate to sender-constrain tokens that is distinct from the certificate used to connect
                to the protected resource.</t>
            </section>
           
           <section anchor="TokenLifetimes" title="Token Lifetimes">

               <t>Access tokens SHOULD have a valid lifetime no greater than one hour, and
                   refresh tokens (if issued) SHOULD have a valid lifetime no greater
                   than twenty-four hours. Specific applications MAY issue tokens with different lifetimes.
                   Any active token MAY be revoked at any time.
               </t>

           </section>

           <section anchor="Scopes" title="Scopes">
               <t>Scopes define individual pieces of authority that can be
                   requested
                   by clients, granted by resource owners, and enforced by
                   protected
                   resources. Specific scope values will be highly dependent
                   on the
                   specific types of resources being protected in a given
                   interface.
                   OpenID Connect, for example, defines scope values to
                   enable access
                   to
                   different attributes of user profiles.
               </t>

               <t>Authorization servers SHOULD define and document default scope
                   values that will be used if an authorization request does not
                   specify
                   a requested set of scopes.
               </t>

               <t>To facilitate general use across a wide variety of protected
                   resources, authorization servers SHOULD allow for the use of
                   arbitrary
                   scope values at runtime, such as allowing clients or
                   protected
                   resources to use arbitrary scope strings upon
                   registration.
                   Authorization servers MAY restrict certain scopes from
                   use by
                   dynamically registered systems or public clients.
               </t>
               
               <t>Refer to <xref target="ClientApproval"/> for further information about
               displaying scopes to end users.
               </t>
           </section>
           
           <section title="Connections Between Authorization Servers and Protected Resources">
               
                <section title="Introspection">
                    <t>Token introspection allows a protected resource to query the
                        authorization server for metadata about a token. Authorization servers MUST NOT allow clients to use token introspection endpoints.</t>
                        <t>The protected
                        resource makes a request over a mutually authenticated TLS connection like the following to the token
                        introspection endpoint:
                    </t>

                    <figure>
                        <artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

POST /introspect HTTP/1.1
User-Agent: Faraday v0.9.0
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip;q=1.0,deflate;q=0.6,identity;q=0.3
Accept: */*
Connection: close
Host: as-va.example.com
Content-Length: 1412

client_assertion=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJhMm\
MzNjkxOS0wMWZmLTQ4MTAtYTgyOS00MDBmYWQzNTczNTEiLCJzdWIiOiJhMmMzNjkxOS\
0wMWZmLTQ4MTAtYTgyOS00MDBmYWQzNTczNTEiLCJhdWQiOiJodHRwczovL2FzLXZhLm\
V4YW1wbGUuY29tL3Rva2VuIiwiaWF0IjoxNDE4Njk4ODE0LCJleHAiOjE0MTg2OTg4Nz\
QsImp0aSI6IjE0MTg2OTg4MTQvZmNmNDQ2OGY2MDVjNjE1NjliOWYyNGY5ODJlMTZhZW\
Y2OTU4In0.md7mFdNBaGhiJfE_pFkAAWA5S-JBvDw9Dk7pOOJEWcL08JGgDFoi9UDbg3\
sHeA5DrrCYGC_zw7fCGc9ovpfMB7W6YN53hGU19LtzzFN3tv9FNRq4KIzhK15pns9jck\
Ktui3HZ25L_B-BnxHe7xNo3kA1M-p51uYYIM0hw1SRi2pfwBKG5O8WntybLjuJ0R3X97\
zvqHn2Q7xdVyKlInyNPA8gIZK0HVssXxHOI6yRrAqvdMn_sneDTWPrqVpaR_c7rt8Ddd\
7drf_nTD1QxESVhYqKTax5Qfd-aq8gZz8gJCzS0yyfQh6DmdhmwgrSCCRC6BUQkeFNvj\
MVEYHQ9fr0NA
&client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertio\
n-type%3Ajwt-bearer
&client_id=a2c36919-01ff-4810-a829-400fad357351
&token=eyJhbGciOiJSUzI1NiJ9.eyJleHAiOjE0MTg3MDI0MTQsImF1ZCI6WyJlNzFm\
YjcyYS05NzRmLTQwMDEtYmNiNy1lNjdjMmJjMDAzN2YiXSwiaXNzIjoiaHR0cHM6XC9c\
L2FzLXZhLmV4YW1wbGUuY29tXC8iLCJqdGkiOiIyMWIxNTk2ZC04NWQzLTQzN2MtYWQ4\
My1iM2YyY2UyNDcyNDQiLCJpYXQiOjE0MTg2OTg4MTR9.FXDtEzDLbTHzFNroW7w27RL\
k5m0wprFfFH7h4bdFw5fR3pwiqejKmdfAbJvN3_yfAokBv06we5RARJUbdjmFFfRRW23\
cMbpGQCIk7Nq4L012X_1J4IewOQXXMLTyWQQ_BcBMjcW3MtPrY1AoOcfBOJPx1k2jwRk\
YtyVTLWlff6S5gK-ciYf3b0bAdjoQEHd_IvssIPH3xuBJkmtkrTlfWR0Q0pdpeyVePkM\
SI28XZvDaGnxA4j7QI5loZYeyzGR9h70xQLVzqwwl1P0-F_0JaDFMJFO1yl4IexfpoZZ\
sB3HhF2vFdL6D_lLeHRy-H2g2OzF59eMIsM_Ccs4G47862w
]]></artwork>
                    </figure>

                    <t>
                        The client assertion parameter is structured as described in
                        <xref target="RequestsToTokenEndpoint"/>.
                    </t>

                    <t>Authorization servers respond to an introspection request with a JSON
                        object containing the following fields as
                        defined in <xref target="RFC7662">OAuth 2.0 Token Introspection</xref>.
                    </t>

                    <t>
                        <list style="hanging">
                            <t hangText="active">Boolean value indicating whether or not
                                this token
                                is currently active at this authorization server.
                                Tokens that
                                have been revoked, have expired, or were not issued
                                by this
                                authorization server are considered non-active.
                            </t>

                            <t hangText="scope">Space-separated list of OAuth 2.0 scope
                                values represented as a single string.
                            </t>

                            <t hangText="exp">Timestamp of when this token expires (integer
                                number of seconds since from 1970-01-01T00:00:00Z UTC)
                            </t>

                            <t hangText="sub">An opaque string that uniquely identifies the
                                user
                                who authorized this token at this authorization server (if
                                applicable). This string MAY be diversified per client.
                            </t>

                            <t hangText="client_id">An opaque string that uniquely
                                identifies the OAuth
                                2.0 client that requested this token
                            </t>
                        </list>
                    </t>

                    <t>The following example is a response from the introspection
                        endpoint:
                    </t>

                    <figure>
                        <artwork><![CDATA[HTTP/1.1 200 OK
Date: Tue, 16 Dec 2014 03:00:14 GMT
Access-Control-Allow-Origin: *
Content-Type: application/json;charset=ISO-8859-1
Content-Language: en-US
Content-Length: 266
Connection: close

{
   "active": true,
   "scope": "file search visa",
   "exp": 1418702414,
   "sub": "{sub\u003d6WZQPpnQxV, iss\u003dhttps://idp-p.example.com/}",
   "client_id": "e71fb72a-974f-4001-bcb7-e67c2bc0037f",
   "token_type": "Bearer"
}
]]></artwork>
                    </figure>

                    <t>
                        Authorization servers MUST require authentication of resource servers
                        for the introspection endpoint using either private_key_jwt or Mutual-TLS
                        methods as described for clients in
                        <xref target="RequestsToTokenEndpoint"/>. Authorization servers MUST NOT allow clients to
                        use token introspection endpoints.
                    </t>

                </section>
            </section>
            
        </section>

        <section title="Protected Resource Profile">
 
            <section title="Connections with Clients">
                <t>Protected resources MUST interpret access tokens using either JWT, token introspection, or a combination of the two</t>
                    <t>Protected resources MUST check the
                    <spanx style="verb">aud</spanx>
                    (audience) claim in tokens to ensure that it
                    includes the protected resource's identifier.</t>
                
                <t>
                    Protected resources MUST accept tokens passed in the
                    authorization header as described in
                    <xref target="RFC6750"/>. A
                    protected resource MUST NOT accept tokens passed in the
                    form
                    parameter or query parameter methods.
                </t>

                <t>Protected resources MUST define and document which scopes are
                    required for access to the resource and any authentication strength or recency requirements for each scope.
                </t>

                <t> If a client <xref target="RFC8705">mTLS</xref> to sender-constrain tokens, the protected resource
                MUST verify that the certificate matches the certificate associated with the
                access token. If they do not match, the resource access attempt MUST be denied.
                </t>
                <t>Protected resources MAY use authentication context or step up authentication to implement access controls.
</t>

                <t>If the authentication event associated with the access token does not satisfy the requirements of the resource server for the given request,
                the protected resource MUST return a 401 Unauthorized status code along with a WWW-Authenticate header as defined in <xref target="RFC9470">OAuth
                2.0 Step Up Authentication Challenge Protocol</xref>. This header MUST include the insufficient_user_authentication error code to indicate that the
                presented access token is inadequate. </t>
                
                <t>Additionally, the response MUST include the acr_values and/or max_age auth-params to communicate the necessary authentication context
                class reference values and the allowable elapsed time since the last active authentication event, respectively. The acr_values parameter
                should list the required authentication context class reference values in order of preference, while the max_age parameter should indicate
                the maximum permissible time in seconds since the last user authentication.</t>
                
                <t>The mechanisms by which the protected resource determines whether the authentication requirements are met are outside the scope of this profile.</t>
                <t>Furthermore, protected resources MAY include both acr_values and max_age if both are relevant.</t>
                
                <t>Protected resources MAY include the scope parameter if additional scopes are required to access the resource, as per Section 3.1 of
                <xref target="RFC6750">The OAuth 2.0 Authorization Framework: Bearer Token Usage</xref>.
                </t>
                    
            </section>

            <section anchor="ProtectingResources" title="Protecting Resources">
            
            <section anchor="TrustLevels" title="Trust Levels and Scopes">
                <t>Protected Resources grant access to clients if they present a valid sender-constrained
                    <spanx style="verb">access_token</spanx> with the appropriate
                    scopes. Resource servers trust the
                    authorization server to authenticate the end user and client appropriately
                    for the importance, risk, and value level of the protected
                    resource scope.
                </t>

                <t>Protected resources MAY use <xref target="RFC9470">OAuth 2.0 Step Up Authentication Challenge Protocol</xref> to implement access controls.</t>

                <t> If a protected resources requires a higher end-user authentication trust
                    level to access certain resources, the protected resource MUST associate those resources with a
                    unique scope and MUST associate acceptable acr values for each scope as descibed in
                    <xref target="RFC9470">OAuth 2.0 Step Up Authentication Challenge Protocol</xref>.
                    Protected Resources may also specify a max_age for each scope.
                </t>
                <t>Protected resources MAY include the scope parameter if additional scopes are required to access the resource, as per Section 3.1 of 
                <xref target="RFC6750">The OAuth 2.0 Authorization Framework: Bearer Token Usage</xref>.</t>
 
            </section>

            <section anchor="TrustExample" title="Trust Levels Example">
                <t>For example, a resource server associates
                    scopes with data classified as "public" and "sensitive".
                    Access to data with scope "sensitive" requires the user to perform a two-factor authentication
                    and limits those access grants to only 15 minutes.
                    The resource server associates scope "sensitive" with acr="MFA".
                    </t>
                
                    <t>
                    For a client to obtain access to both "public" and "sensitive" data,
                    it makes an authorization request to the authorization server with
                    <spanx style="verb">scope=public+sensitive</spanx>, acr_values="MFA", and
                    max_age=900. The authorization
                    server authenticates the end-user as required to meet the required trust level
                    (two-factor authentication or some approved equivalent) and issues an
                    <spanx style="verb">access_token</spanx> for the "public" and "sensitive" scopes
                    with an expiry time of 15 minutes and a <spanx style="verb">refresh_token</spanx>
                    for the "public" scope with an expiry time of 24 hrs.
                    </t>
                    
                    <t>
                    The client can access both
                    "public" and "sensitive" data for 15mins with the access_token. When the
                    access_token expires, the client will NOT be able to access "public" or "sensitive"
                    data any longer as the access_token has expired, and must obtain a
                    new access_token.
                    </t>
                    
                    <t>
                    The client makes a
                    refresh token request (as described in <xref target="RFC6749">OAuth 2.0</xref>
                    section 6) with the refresh_token,
                    and the reduced scope of just "public". The token endpoint validates the refresh_token,
                    and issues a new access_token for just the "public" scope with an expiry time set to 24hrs.
                    An access grant request for a new access_token with the "sensitive" scope would be
                    rejected, and require the client to get the end-user to re-authenticate/authorize the
                    "sensitive" scope request.
                </t>
                    
                <t> In this manner, protected resources and authorization servers work together to meet
                    risk tolerance levels for sensitive resources and end-user authentication.
                </t>
                </section>

            </section>
            <section title="Connections with Authorization Servers">

                <t>Protected resources MUST provide a JWKS URI endpoint to distribute public keys to support signing, encryption, and 
                authentication to authorization server revocation and introspection endpoints. <xref target="RFC9728">OAuth 2.0 Protected Resource Metadata</xref> 
                defines a metadata format that a client or authorization server can use to obtain the information needed to interact with a protected resource.
                This metadata facilitates enhanced interoperability and security, including advertisement and discovery of a protected 
                resource's public key via its jwks_uri.
                </t>
                
                <t>Protected resources calling the
                introspection endpoint MUST use
                credentials distinct from any other
                OAuth client registered at the authorization
                server.</t>
                
                <t>Protected resources MAY cache the response from the
                    introspection endpoint for a period of time no greater than half
                    the
                    lifetime of the token. A protected resource MUST NOT accept a
                    token
                    that is not active according to the response from the
                    introspection
                    endpoint.
                </t>
                
                <t>Protected
                    resources
                    MUST ensure that the rights associated with the token are
                    sufficient
                    to grant access to the resource. For example, this can be
                    accomplished
                    by querying the scopes and acr value associated with the token from
                    the
                    authorization server's token introspection endpoint.
                </t>

                <t>Protected resources MUST limit which authorization servers it
                    will
                    accept valid tokens from. A resource server MAY accomplish
                    this using
                    a whitelist of trusted servers, a dynamic policy engine,
                    or other
                    means.
                </t>
                

            </section>
        </section>

        <section title="Security Considerations">
        
                <!--  Need to add data from John's RFC regarding registration security -->
            <section title="DNSSEC Considerations">
                <t>For a comprehensive protection against network attackers, all endpoints should additionally use <xref target="RFC9364">DNSSEC</xref> to protect
                 against DNS spoofing attacks that can lead to the issuance of rogue domain-validated TLS certificates.
                </t>
            </section>
            
           
            <section title="Best Practices">
                <t>Authorization server, client, and protected resource implementations SHOULD consider including requirements from
                    <xref target="BCP240">Best Current Practice for OAuth 2.0 Security</xref>,
                    <xref target="RFC8725">JSON Web Token Best Current Practices</xref> and
                    <xref target="RFC9068">JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens</xref> that are not
                    explicitly mentioned in this profile.
                </t>
            </section>
            
            <section title="Other Considerations">

                <t> Authorization Servers SHOULD take device posture into account, when possible. Some examples of device posture include:</t>
                    <t><list style="symbols">
                    <t>the user's lock screen setting</t>
                    <t>the client's level of privilege over the device operating system (e.g. if the client has 'root access', the
                    device operating system may be compromised to gain additional privileges not intended by the vendor)</t>
                    <t>the availability of a device attestation to validate the client</t>
                    </list></t>
                <t>
                    Specific policies or capabilities are outside the scope of this specification.
                </t>

                <t>
                    This profile does not protect against the attacks described in
                    <xref target="pkce-vs-nonce">The Stronger Attacker Model</xref>, in which an attacker
                    could inject the authorization request and read the authorization response.
                    Although using request object signatures would provide mitigation, this profile does not require
                    request object signatures because of the lack of available implementations.
                </t>
            </section>
        </section>
            <section title="Privacy Considerations">
                <t>This profile addresses the privacy threats identified in <xref target="RFC6973">Privacy Considerations for Internet Protocols</xref> with normative
                language throughout the document. In particular, this profile requires the use of TLS for all network connections, PKCE, and sender constrained tokens
                to mitigate the threats in <xref target="RFC6973"></xref>
                </t>
                <t>In OpenID Connect implementations, cilents and servers SHOULD implement the privacy threat mitigations in Section 17 of
                <xref target="OpenID.Core">OpenID Connect Core 1.0</xref>.
                </t>
            </section>
    </middle>

    <back>
        <references title="Normative References">
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6749"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6750"/>
      
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6797"/>
      
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6819"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6973"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7009"/>
      
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7515"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7516"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7517"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7519"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7523"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7591"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7636"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7662"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7518"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7638"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7800"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8414"/>
      
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8252"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8705"/>
      
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8725"/>
      
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9068"/>
       
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9364"/>
      
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9449"/>
      
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9470"/>
  
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9728"/>
        
      <reference anchor="BCP195" target="http://www.rfc-editor.org/info/bcp195">
                <front>
                    <title>Recommendations for Secure Use of Transport Layer Security
                        (TLS) and Datagram Transport Layer Security (DTLS)</title>

                    <author fullname="Y. Sheffer" initials="Y." surname="Sheffer">
                        <organization/>
                    </author>

                    <author fullname="R. Holz" initials="R." surname="Holz">
                        <organization/>
                    </author>

                    <author fullname="P. Saint-Andre" initials="P." surname="Saint-Andre">
                        <organization/>
                    </author>

                    <date month="May" year="2015"/>

                    <abstract>
                        <t>Transport Layer Security (TLS) and Datagram Transport Layer
                            Security (DTLS) are widely used to protect data exchanged over
                            application protocols such as HTTP, SMTP, IMAP, POP, SIP, and
                            XMPP. Over the last few years, several serious attacks on TLS
                            have
                            emerged, including attacks on its most commonly used cipher
                            suites
                            and their modes of operation. This document provides
                            recommendations for improving the security of deployed services
                            that use TLS and DTLS. The recommendations are applicable to the
                            majority of use cases.
                        </t>
                    </abstract>
                </front>

                <seriesInfo name="BCP" value="195"/>

                <seriesInfo name="RFC" value="7525"/>
                
                <seriesInfo name="DOI" value="10.17487/RFC7525"/>

                <format octets="60283" type="ASCII"/>
            </reference>

      <reference anchor="BCP240" target="http://www.rfc-editor.org/info/bcp240">
                <front>
                    <title>Best Current Practice for OAuth 2.0 Security</title>

                    <author fullname="Torsten Lodderstedt" initials="T." surname="Lodderstedt">
                                            <organization/>
                    </author>
                    <author fullname="John Bradley" initials="J." surname="Bradley">
                                            <organization/>
                    </author>
                    <author fullname="Andrey Labunets" initials="A." surname="Labunets">
                                            <organization/>
                    </author>
                    <author fullname="Daniel Fett" initials="D." surname="Fett">
                                            <organization/>
                    </author>

                    <date month="January" year="2025"/>

                    <abstract>
                        <t>   This document describes best current security practice for OAuth 2.0.
                               It updates and extends the threat model and security advice given in
                               RFCs 6749, 6750, and 6819 to incorporate practical experiences
                               gathered since OAuth 2.0 was published and covers new threats
                               relevant due to the broader application of OAuth 2.0.  Further, it
                               deprecates some modes of operation that are deemed less secure or
                               even insecure.
                        </t>
                    </abstract>
                </front>

                <seriesInfo name="BCP" value="240"/>

                <seriesInfo name="RFC" value="9700"/>
                
                <seriesInfo name="DOI" value="10.17487/RFC9700"/>

                <format octets="60283" type="ASCII"/>
            </reference>

            <reference anchor="OpenID.Core" target="http://openid.net/specs/openid-connect-core-1_0.html">
                <front>
                    <title>OpenID Connect Core 1.0</title>

                    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
                        <organization abbrev="NRI">Nomura Research Institute,
                            Ltd.</organization>
                    </author>

                    <author fullname="John Bradley" initials="J." surname="Bradley">
                        <organization abbrev="Ping Identity">Ping Identity</organization>
                    </author>

                    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
                        <organization abbrev="Microsoft">Microsoft</organization>
                    </author>

                    <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
                        <organization abbrev="Google">Google</organization>
                    </author>

                    <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
                        <organization abbrev="Salesforce">Salesforce</organization>
                    </author>

                    <date day="3" month="August" year="2015"/>
                </front>
            </reference>

            <reference anchor="OpenID.Discovery" target="http://openid.net/specs/openid-connect-discovery-1_0.html">
                <front>
                    <title>OpenID Connect Discovery 1.0</title>

                    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
                        <organization abbrev="NRI">Nomura Research Institute,
                            Ltd.</organization>
                    </author>

                    <author fullname="John Bradley" initials="J." surname="Bradley">
                        <organization abbrev="Ping Identity">Ping Identity</organization>
                    </author>

                    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
                        <organization abbrev="Microsoft">Microsoft</organization>
                    </author>

                    <author fullname="Edmund Jay" initials="E." surname="Jay">
                        <organization abbrev="Illumila">IllumilaJSON</organization>
                    </author>

                    <date day="3" month="August" year="2015"/>
                </front>
            </reference>

            <reference anchor="OpenID.iGov" target="https://openid.net/specs/openid-igov-openid-connect-1_0.html">
                <front>
                    <title>International Government Assurance Profile (iGov) for OpenID Connect 1.0</title>
                    <author fullname="Michael Varleyy" initials="M." surname="Varley"/>
                    <author fullname="Paul Grassi" initials="P." surname="Grassi"/>
                    <date day="3" month="August" year="2023"/>
                </front>
            </reference>

            <reference anchor="JWS.JWE.Algs">
                <front>
                    <title>JSON Web Signature and Encryption Algorithms registry</title>

                    <author>
                        <organization/>
                    </author>

                    <date day="8" month="August" year="2016"/>
                </front>
            </reference>
            
            <reference anchor="mlkem.ikev2" target="https://datatracker.ietf.org/doc/draft-kampanakis-ml-kem-ikev2/">
                <front>
                    <title>Post-quantum Hybrid Key Exchange with ML-KEM in the Internet Key Exchange Protocol Version 2 (IKEv2)</title>
                    <author fullname="Panos Kampanakis" initials="P." surname="Kampanakis"/>
                    <author fullname="Gerardo Ravago" initials="G." surname="Ravago"/>
                    <date day="4" month="November" year="2024"/>
                </front>
            </reference>
            
            <reference anchor="pkce-vs-nonce" target="https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/">
                <front>
                    <title>PKCE vs. Nonce: Equivalent or Not?</title>
                    <author fullname="Daniel Fett" initials="D." surname="Fett"/>
                    <date day="16" month="May" year="2020"/>
                </front>
            </reference>

            <reference anchor="browser-based-apps" target="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps">
                <front>
                    <title>OAuth 2.0 for Browser-Based Applications</title>
                    <author fullname="Aaron Parecki" initials="A." surname="Parecki"/>
                    <author fullname="David Waite" initials="D." surname="Waite"/>
                    <author fullname="Philippe De Ryck" initials="P." surname="De Ryck"/>
                    <date day="17" month="January" year="2025"/>
                </front>
            </reference>


        </references>

        <section anchor="Acknowledgements" title="Acknowledgements">
            <t>The OpenID Community would like to thank the following people for
                their contributions to this specification: Mark Russel, Mary
                Pulvermacher, David Hill, Dale Moberg, Adrian Gropper, Eve Maler,
                Danny van Leeuwen, John Moehrke, Aaron Seib, John Bradley, Debbie
                Bucci, Josh Mandel, Sarah Cecchetti, Giuseppe De Marco, Joseph Heenan,
                Jim Fenton, Ryan Galluzzo, Bjorn Hjelm, Aaron Parecki, Michael B. Jones, and Stas Mironov.
            </t>
            <t> Special thank you to the original iGov Profile editors: Paul Grassi, Justin Richer,
                and Michael Varley.
                </t>

            <t>The original version of this specification was part of the Secure
                RESTful Interfaces project from The MITRE Corporation, available
                online
                at http://secure-restful-interface-profile.github.io/pages/
            </t>
        </section>

        <section anchor="Notices" title="Notices">
            <t>Copyright (c) 2025 The OpenID Foundation.</t>

            <t>The OpenID Foundation (OIDF) grants to any Contributor, developer, implementer, or other interested party a non-exclusive, royalty free, worldwide copyright license to reproduce,
            prepare derivative works from, distribute, perform and display, this Implementers Draft, Final Specification, or Final Specification Incorporating Errata Corrections solely for the
            purposes of (i) developing specifications, and (ii) implementing Implementers Drafts, Final Specifications, and Final Specification Incorporating Errata Corrections based on such
            documents, provided that attribution be made to the OIDF as the source of the material, but that such attribution does not indicate an endorsement by the OIDF.</t>

            <t>The technology described in this specification was made available from contributions from various sources, including members of the OpenID Foundation and others. Although the
            OpenID Foundation has taken steps to help ensure that the technology is available for distribution, it takes no position regarding the validity or scope of any intellectual property
            or other rights that might be claimed to pertain to the implementation or use of the technology described in this specification or the extent to which any license under such rights
            might or might not be available; neither does it represent that it has made any independent effort to identify any such rights. The OpenID Foundation and the contributors to this
            specification make no (and hereby expressly disclaim any) warranties (express, implied, or otherwise), including implied warranties of merchantability, non-infringement, fitness
            for a particular purpose, or title, related to this specification, and the entire risk as to implementing this specification is assumed by the implementer. The OpenID Intellectual
            Property Rights policy (found at openid.net) requires contributors to offer a patent promise not to assert certain patent claims against other contributors and against implementers.
            OpenID invites any interested party to bring to its attention any copyrights, patents, patent applications, or other proprietary rights that may cover technology that may be required
            to practice this specification.</t>
        </section>

        <section anchor="History" title="Document History">
      <t>[[ To be removed from the final specification ]]</t>
 
 <t>
    -08
    <list style="symbols">
    <t>
        Added description of resource server requirements for authentication context and step-up
      </t>
      <t>
        Restructured the document so the text flows better
      </t>
      <t>
        Added a method to securely discover or declare JWKS-URI for PR/RS
      </t>
      <t>
        Removed public clients to align with FAPI
      </t>
      <t>
        Moved requirements to correct section
      </t>
      <t>
        Realigned requirements among AS, client, and PR/RS
      </t>
      <t>
        Changed date, version, and document history
      </t>
      </list>
      </t>
      <t>
    -06-07
    <list style="symbols">
      <t>
        Addressed comments from WGLC request Jan 31, 2025
      </t>
      </list>
      </t>
     <t>
    -05
    <list style="symbols">
      <t>
        Updated BCP mitigations, aligned with FAPI
      </t>
      <t>
        Harmonized cryptography, sender constrained tokens with FAPI
      </t>
      <t>
        Added requirement and optionality for authentication context and support for Step-up (RFC 9470)
      </t>
      <t>
        Added Privacy Considerations (RFC 6973)
      </t>
      <t>
        Added optionality to support enterprise tailoring, especially RFC 8705 mTLS with PKI
      </t>
      </list>
      </t>
      <t>
    -04
    <list style="symbols">
      <t>
        Enable building with https://author-tools.ietf.org/.
      </t>
      <t>
        Applied OpenID specification conventions.
      </t>
        </list>
      </t>

      <t>
    -03
    <list style="symbols">
      <t>
        First Implementer's Draft
      </t>
        </list>
      </t>

            <t>-2017-06-01</t>

            <t>
                <list style="symbols">
                    <t>Aligned with prior version of iGov.</t>
                    <t>Added guidance text around using scopes and refresh_tokens to protect sensitive resources.</t>
                    <t>Removed ACR reference.</t>
                </list>
            </t>

            <t>-2018-05-07</t>

            <t>
                <list style="symbols">
                    <t>Imported content from HEART OAuth profile.</t>
                </list>
            </t>
        </section>
    </back>
</rfc>
