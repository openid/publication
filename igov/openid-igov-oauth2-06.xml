<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN" "http://xml2rfc.tools.ietf.org/authoring/rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='http://xml2rfc.tools.ietf.org/authoring/rfc2629.xslt' ?>
<!-- NOTE: This XML file is input used to produce the authoritative copy 
	of an OpenID Foundation specification. The authoritative copy is the HTML 
	output. This XML source file is not authoritative. The statement ipr="none" 
	is present only to satisfy the document compilation tool and is not indicative 
	of the IPR status of this specification. The IPR for this specification is 
	described in the "Notices" section. This is a public OpenID Foundation document 
	and not a private document, as the private="..." declaration could be taken 
	to indicate. -->
<rfc 
  category="std" 
  
  docName="openid-igov-oauth2-1_06" 
  
  ipr="none" 
  
  xmlns:xi="http://www.w3.org/2001/XInclude" 
  
  submissionType="IETF" 
  
  consensus="true" >

  <?rfc tocInclude="yes" ?> 

  <?rfc tocdepth="5" ?> 

  <?rfc symrefs="yes" ?> 

  <?rfc sortrefs="yes" ?>

  <?rfc strict="yes" ?> 

  <?rfc iprnotified="no" ?> 

  <?rfc private="Draft" ?> 
  
	<front>
		<title abbrev="iGov OAuth 2.0">International Government Assurance Profile (iGov)
			for OAuth 2.0 - draft 06</title>

		<author fullname="Kelley Burgin" initials="K." role="editor" surname="Burgin">
			<organization abbrev="MITRE">The MITRE Corporation</organization>
			<address>
				<email>kburgin@mitre.org</email>

			</address>
		</author>
		<author fullname="Tom Clancy" initials="T." role="editor" surname="Clancy">
			<organization abbrev="MITRE">The MITRE Corporation</organization>
			<address>
				<email>tclancy@mitre.org</email>

			</address>
		</author>

		<date day="28" month="February" year="2025"/>

		<workgroup>OpenID iGov Working Group</workgroup>

		<abstract>
			<t>The OAuth 2.0 protocol framework defines a mechanism to allow a
				resource owner to delegate access to a protected resource for a
				client
				application.
			</t>

			<t>This specification profiles the OAuth 2.0 protocol framework to
				increase baseline security, provide greater interoperability, and
				structure deployments in a manner specifically applicable, but not limited to
				consumer-to-government deployments.
			</t>
		</abstract>
	</front>

	<middle>
		<section anchor="Introduction" title="Introduction">
			<t>This document profiles the OAuth 2.0 web authorization framework
				for
				use in the context of securing web-facing application programming
				interfaces (APIs), particularly Representational State Transfer
				(RESTful) APIs. The OAuth 2.0 specifications accommodate a wide
				range of
				implementations with varying security and usability
				considerations,
				across different types of software clients. The OAuth
				2.0 client,
				protected resource, and
				authorization server profiles
				defined in this document serve two
				purposes:
			</t>

			<t>
				<list style="numbers">
					<t>Define a mandatory baseline set of security controls suitable
						for
						a wide range of government use cases, while maintaining
						reasonable
						ease of
						implementation and functionality
					</t>

					<t>Identify optional, advanced security controls for sensitive use
						cases where increased risk justifies more stringent controls.
					</t>
				</list>
			</t>

			<t>
				This OAuth profile is intended to be shared broadly, and has been
				greatly influenced
				by the
				<xref target="HEART.OAuth2">HEART OAuth2 Profile</xref>.
			</t>

			<section anchor="rnc" title="Requirements Notation and Conventions">
				<t>
					The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
					"SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY",
					and
					"OPTIONAL" in this document are to be interpreted as described
					in
					<xref target="RFC2119">RFC 2119</xref>
					.
				</t>

				<t>
					All uses of
					<xref target="RFC7515">JSON Web Signature (JWS)</xref>
					and
					<xref target="RFC7516">JSON Web Encryption (JWE)</xref>
					data
					structures in this specification utilize the JWS Compact
					Serialization
					or the JWE Compact Serialization; the JWS JSON
					Serialization and the
					JWE JSON Serialization are not used.
				</t>
			</section>

			<section anchor="Terminology" title="Terminology">
				<t>
					This specification uses the terms "Access Token", "Authorization
					Code", "Authorization Endpoint", "Authorization Grant",
					"Authorization
					Server", "Client", "Client Authentication", "Client
					Identifier",
					"Client Secret", "Grant Type", "Protected Resource",
					"Redirection
					URI", "Refresh Token", "Resource Owner", "Resource
					Server", "Response
					Type", and "Token Endpoint" defined by
					<xref target="RFC6749">OAuth
						2.0</xref>
					, the terms "Claim Name", "Claim Value", and "JSON Web Token
					(JWT)"
					defined by
					<xref target="RFC7519">JSON Web Token (JWT)</xref>
					,
					and the terms defined by
					<xref target="OpenID.Core">OpenID Connect
						Core 1.0</xref>
					.
				</t>
			</section>

			<section title="Conformance">
				<t>This specification defines requirements for the following
					components:
				</t>

				<t>
					<list style="symbols">
						<t>OAuth 2.0 clients.</t>

						<t>OAuth 2.0 authorization servers.</t>

						<t>OAuth 2.0 protected resources.</t>
					</list>
				</t>

				<t>The specification also defines features for interaction between
					these components:
				</t>

				<t>
					<list style="symbols">
						<t>Client to authorization server.</t>

						<t>Protected resource to authorization server.</t>
					</list>
				</t>

				<t>When an iGov-compliant component is interacting with other
					iGov-compliant components, in any valid combination, all components
					MUST fully conform to the features and requirements of this
					specification. All interaction with non-iGov components is outside
					the scope of this specification.
				</t>

				<t>An iGov-compliant OAuth 2.0 authorization server MUST support all
					features as described in this specification. A general-purpose
					authorization server MAY support additional features for use with
					non-iGov clients and protected resources.
				</t>

				<t>An iGov-compliant OAuth 2.0 client MUST use all functions as
					described in this specification. A general-purpose client library
					MAY
					support additional features for use with non-iGov authorization
					servers and protected resources.
				</t>

				<t>An iGov-compliant OAuth 2.0 protected resource MUST use all
					functions as described in this specification. A general-purpose
					protected resource library MAY support additional features for use
					with non-iGov authorization servers and clients.
				</t>
			</section>


			<section title="Global Requirements">
             
	             <t>All network connections MUST be made using TLS 1.3 or above.
    	         Each originator of a TLS connection MUST verify the destination's certificate.
        	     Additionally, the following four TLS 1.2 cipher suites MAY be used:
  					<list>
  					<t>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</t>
					<t>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</t>
					<t>TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256</t>
					<t>TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384</t>
					</list>
 	        	 </t>
	 	         <t>Implementers of this profile SHOULD monitor the progress of specifications of post-quantum 
				 cryptography for TLS implementations.
				 Implementers MAY adopt a cipher suite not included in <xref target="BCP195">BCP195</xref> when post quantum safety 
				 is required if the cipher suite is supported in the implementation environment.
				 </t>
				 <t>An example of an emerging PQ cipher suite that is broadly supported at the time of writing is X25519MLKEM768, specified by 
				 <xref target="mlkem.ikev2">Post-quantum Hybrid Key Exchange with ML-KEM in the Internet Key Exchange Protocol Version 2 (IKEv2)</xref>.
				 </t>
				 <t>
    	         For the authorization_endpoint, the authorization server MAY allow
        	     additional cipher suites that are permitted by the latest version of <xref target="BCP195">BCP195</xref>,
	             if necessary to allow sufficient interoperability with users' web browsers or as required by local regulations.
 		         </t>
	 	         <t>
    	         NOTE: Permitted cipher suites are those listed in <xref target="BCP195">BCP195</xref> that do not explicitly say MUST NOT use.
  	    	     </t>
         
 		         <t>Endpoints for use by web browsers MUST use mechanisms to ensure that connections cannot be downgraded 
				 using TLS Stripping attacks. Protected resources MAY implement an HTTP Strict Transport Security policy as defined in 
				 <xref target="RFC6797">HTTP Strict Transport Security (HSTS)</xref> to mitigate these attacks. Protected resources SHOULD 
				 consider registering web domain names with browsers that offer browser-side ("preload") HSTS policy enforcement to further mitigate 
				 TLS downgrade attacks.
        	     </t>

			</section>

		</section>

		<section anchor="ClientProfiles" title="Client Profiles">
			<t/>
<section anchor="ClientTypes" title="Client Types">
                <t>
                    OAuth defines two client types, based on their ability to
                       authenticate securely with the authorization server
                </t>
                <t>
                    <list style="hanging">
                        <t hangText="confidential clients:">Clients that have credentials with the authorization server.</t>
                        <t hangText="public clients:">Clients without credentials.
                            </t>
                        </list>
                    </t>

            </section> <!-- End of ClientTypes section -->

            <section anchor="UseCases" title="Client Type Use Cases">
                <t>This specification has been designed around the following client use cases:</t>
                
                <t>
                    <list style="hanging">
                        <t hangText="web application:">A web application is a client running on a web
                               server.  Resource owners access the client via an HTML user
                               interface rendered in a user agent on the device used by the
                               resource owner.  The client credentials as well as any access
                               tokens issued to the client are stored on the web server and are
                               not exposed to or accessible by the resource owner. In this use case, web applications are confidential clients.
                        </t>

                        <t hangText="native application:">A native application is a client installed and
                            executed on the device used by the resource owner.  Protocol data
                            and credentials are accessible to the resource owner.  It is
                            assumed that any client authentication credentials included in the
                            application can be extracted.  Dynamically issued access tokens
                            and refresh tokens can receive an acceptable level of protection.
                            On some platforms, these credentials are protected from other
                            applications residing on the same device. Best current practices for native applications are detailed in 
							<xref target="RFC8252">OAuth 2.0 for Native Apps</xref>. In this use case, native applications are public clients.
                        </t>
                        
                        <t hangText="browser-based application:">A browser-based application is a client
                  in which the client code is downloaded from a web server and
                  executes within a user agent (e.g., web browser) on the device
                  used by the resource owner.  Protocol data and credentials are
                  easily accessible (and often visible) to the resource owner.  If
                  such applications wish to use client credentials, it is
                  recommended to utilize the backend for frontend pattern.  Since
                  such applications reside within the user agent, they can make
                  seamless use of the user agent capabilities when requesting
                  authorization. This use case is out of scope due to the inherent lack of security provided by browser-based applications. 
				  However, best current practices are detailed in <xref target="browser-based-apps">OAuth 2.0 for Browser-Based Applications</xref>..</t>
                        </list>
                    </t>
                </section>


            <section anchor="PoPTokens" title="Sender-constrained Tokens">
                <t> While a bearer token can be used by anyone in possession of the token, a sender-constrained token is
                bound to a particular symmetric or asymmetric key issued to, or already possessed by, the client. 
				The association of the key to the token is also communicated to the protected resource. When the client 
				presents the token to the protected resource, it is also required to demonstrate possession of the corresponding key.
            		</t>

             	<t>As described in <xref target="BCP240">Best Current Practice for OAuth 2.0 Security</xref>, sender-constrained tokens could
                prevent a number of attacks on OAuth that entail the misuse of stolen and leaked access tokens by unauthorized parties. 
				The attacker would need to obtain the legitimate client's cryptographic key along with the access
                token to gain access to protected resources.
                	</t>
            
            <t> All clients MUST use proof of possession to sender-constrain access tokens using either <xref target="RFC8705">mTLS</xref> or 
			<xref target="RFC9449">DPoP</xref>.
                </t>
				
			</section>

			<section anchor="AuthNContext" title="Authentication Context and Step-Up Authentication Challenge Protocol Support">
				<t>OAuth 2.0 clients and Authorization Servers MUST support the mechanism specified in <xref target="RFC9470">OAuth 2.0 Step Up Authentication Challenge 
				Protocol"</xref> to communicate authentication context and implement interoperable step up authentication.</t>
				<t>Protected resources MAY use authentication context or step up authentication to implement access controls.</t>
				<t>This profile acknowledges government use cases will likely operate within an ecosystem of authentication methods of highly variable security 
				value for the foreseeable future by imposing requirements to enable protected resources with basic capabilities to communicate
				requirements for authentication strength and recency to supporting authorization clients and servers, as well as the capability to enforce access 
				policies using access tokens augmented with the strength and recency of the authentication event that led to the issuance of each specific access token.</t>
				<t>This profile will leverage the supporting server metadata, request, token claims and values, and error messages from <xref target="RFC9470">OAuth 2.0 Step Up Authentication Challenge 
				Protocol"</xref> and <xref target="OpenID.Core">OpenID Connect Core 1.0</xref>.</t>
				<t>Digital identity policies and semantic mappings to string values are required for implementation but are out of scope for this technical profile.</t>
				<t>OAuth 2.0 MUST NOT be used as an authentication protocol. Use of the <xref target="OpenID.iGov">iGov OpenID Connect Profile"</xref> is RECOMMENDED to provide the identity 
				authentication layer for iGov OAuth 2.0 delegated access use cases.  
				</t> 
			</section>

			<section anchor="ClientRegistration" title="Client Registration">
				<t>All clients MUST register with the authorization server. For
					client software that may be installed on multiple client
					instances,
					such as native applications or single page app (SPA),
					each client	instance MAY receive a unique client identifier from
					the	authorization server. 
				</t>
				
				<t>Client registration MAY be completed by either static configuration 
					(out-of-band, through an administrator, etc...) or dynamically.</t>

			    <t> If a client uses <xref target="RFC8705">mTLS</xref> for client authentication or to sender-constrain tokens, the client MUST include the tls_client_certificate_bound_access_tokens parameter in its registration metadata.
                    </t>
                
                <t> If a client uses <xref target="RFC9449">DPoP</xref> to sender constrain tokens, the client MUST include the dpop_bound_access_tokens parameter in its registration metadata.
                    </t>
              	
				<t>Clients using mTLS for client authentication or to sender-constrain tokens MUST register their TLS certificate's subject DN with the authorization server. 
				Clients using self-signed certificate option are not guaranteed uniqueness of their certificate fingerprint.</t>

              	<section anchor="RedirectURI" title="Redirect URI">
					<t>Clients using the authorization code grant type
						MUST register
						their full redirect URIs. The Authorization Server
						MUST validate
						the redirect URI given by the client at the
						authorization endpoint
						using strict string comparison.
					</t>

					<t>A client MUST protect the values passed back to its redirect
						URI by ensuring that the redirect URI is one of the following:
					</t>

					<t>
						<list style="symbols">
							<t>Hosted on a website with Transport Layer Security (TLS)
								protection (a Hypertext Transfer Protocol - Secure
								(HTTPS) URI)
							</t>

							<t>Hosted on a client-specific non-remote-protocol URI scheme
								(e.g., myapp://)
							</t>

							<t>Hosted on the local domain of the client (e.g.,
								http://localhost/)
							</t>

						</list>
					</t>

					<t>Clients MUST use a unique redirect URI for each logical authorization server.
					</t>

					<t>Clients MUST NOT forward values passed back to their redirect
						URIs to other arbitrary or user-provided URIs (a practice known
						as
						an "open redirector").</t>
					<t>Refer to <xref target="BCP240">Best Current Practice for OAuth 2.0 Security</xref> Section 2.4.1
					for additional guidance for implementation of edge cases.
					</t>
				</section>
			</section>

			<section title="Connection to the Authorization Server">
				<section anchor="RequestsToAuthorizationEndpoint" title="Requests to the Authorization Endpoint">
					<t>All clients MUST use the PKCE S256 code challenge method as described in 
					<xref target="RFC7636">Proof Key for Code Exchange by OAuth Public Clients</xref> and 
					include the "code_challenge" parameter 
					and "code_challenge_method", set to "S256", in the authorization request. 
					The PKCE code_verifier value MUST contain at least 128 bits of entropy.
					</t>
					<t>
						Clients making a request to the
						authorization endpoint MUST use an unpredictable value for the
						state
						parameter with at least 128 bits of entropy. Clients MUST
						validate
						the value of the
						<spanx style="verb">state</spanx>
						parameter upon
						return to the redirect URI and MUST ensure that the
						state value is
						securely tied to the user's current session
						(e.g., by
						relating
						the state value to a session identifier issued by
						the client
						software to the browser).
					</t>

					<t>Clients MUST include their full redirect URI in the
						authorization request. To prevent open redirection and other
						injection attacks, the authorization server MUST match the entire
						redirect URI using a direct string comparison against registered
						values and MUST reject requests with an invalid or missing redirect
						URI.
					</t>
					
 					<t>The client MAY specify a strength of authentication and maximum age to the authorization server that should be met 
						when issuing an access token for the requesting client by including parameters in the authorization request:</t>
						<list style="hanging">
							<t hangText="acr_values"> a space-separated string listing the authentication context class reference values in order of preference.  
							The protected resource requires one of these values for the authentication event associated with the access token.  As defined
							in Section 1.2 of <xref target="OpenID.Core">OpenID Connect Core 1.0 </xref>, the authentication context conveys information about how 
							authentication takes place (e.g., what authentication 
							method(s) or assurance level to meet).  It is out of scope of this document to determine how an organization semantically maps their 
							digital identity practices to acr values that identify levels of assurance. 
							</t>
							<t hangText="max_age"> a non-negative integer value that indicates the allowable elapsed time in seconds since the last active authentication event 
							associated with the access token. 
							</t>
							</list>
							
						<t>Furthermore, if the authorization request is a follow-up to a prior request that did not meet the resource server's initial or subsequent 
						authentication strength or recency requirements, the client should include the acr_values and/or max_age values sent by the resource server with 
						the insuffient_user_authentication error code that specify expected strength and recency requirements to be provided to the authentication provider, 
						such as the OpenID Provider, in a new authentication request.</t>
						
					<t>The following is a sample response from a client to
						the
						end user's browser for the purpose of redirecting the end
						user
						to the authorization server's authorization endpoint:
					</t>

					<figure>
						<artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

HTTP/1.2 302 Found
Cache-Control: no-cache
Connection: close
Content-Type: text/plain; charset=UTF-8
Date: Wed, 07 Jan 2015 20:24:15 GMT
Location: \
  https://idp-p.example.com/authorize?client_id=55f9f559-2496-49d4-b\
6c3-351a586b7484&response_type=code&scope=openid+email&redirect_uri=\
https%3A%2F%2Fclient.example.org%2Fcb&acr_values=myACR&max_age=1800\
Status: 302 Found
]]></artwork>
					</figure>

					<t>This causes the browser to send the following (non-normative) request to the
						authorization endpoint (inline wraps for display purposes only):
					</t>

					<figure>
						<artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

GET /authorize?
   client_id=55f9f559-2496-49d4-b6c3-351a586b7484
  &nonce=cd567ed4d958042f721a7cdca557c30d
  &response_type=code
  &scope=openid+email
  &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb HTTP/1.1
Host: idp-p.example.com
]]></artwork>
					</figure>
			</section>

			<section anchor="RequestsToTokenEndpoint" title="Requests to the Token Endpoint">
					<t>
						Full clients, native clients with dynamically registered keys, 
						and direct access clients as defined above MUST
						authenticate to the authorization server's token endpoint using either 
						the private_key_jwt method as defined in
						<xref target="OpenID.Core">OpenID Connect Core</xref>
						or 
						the mutually-authenticated transport layer security (MTLS) request method
						defined in
						<xref target="RFC8705">OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens</xref>.
						If using the private_key_jwt method, the request MUST be a JWT assertion as defined by the
						<xref target="RFC7523">JWT Profile for OAuth 2.0 Client Authentication and Authorization Grants</xref>.
						If using the mTLS method, the request must be made over a mutually authenticated TLS channel.

						For both methods, the request MUST include the following parameters:
					</t>

					<t>
						<list style="hanging">
							<t hangText="iss">the client ID of the client creating the
								token
							</t>

							<t hangText="sub">the client ID of the client creating the
								token
							</t>

							<t hangText="aud">the URL of the authorization server's issuer
								endpoint
							</t>

							<t hangText="iat">the time that the token was created by the
								client
							</t>

							<t hangText="exp">the expiration time, after which the token
								MUST be
								considered invalid
							</t>

							<t hangText="jti">a unique identifier generated by the client
								for this
								authentication. This identifier MUST contain at least
								128 bits of
								entropy and MUST NOT be re-used by any subsequent
								authentication
								token.
							</t>
						</list>
						</t>



						<t>Additionally, if the client uses <xref target="RFC8705">mTLS</xref> for client authentication or to sender-constrain 
						tokens, the client MUST include the following claim in the client assertion.
						</t>
						<list style="hanging">						
							<t hangText="cnf">Confirmation, as defined in 
							<xref target="RFC7800">Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs)</xref> and 
							<xref target="RFC8705">OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens</xref>.
							The confirmation claim value MUST be computed using the X.509 Certificate SHA-256 Thumbprint method and include confirmation 
							method value "x5t#256".
							</t>
						</list>
						<t>The following sample claim set illustrates the use of the
						required
						claims for a client authentication JWT as defined in this
						profile using the private_key_jwt authentication method;
						additional claims MAY be included in the claim set.
						</t>

					<figure>
						<artwork><![CDATA[{
   "iss": "55f9f559-2496-49d4-b6c3-351a586b7484",
   "sub": "55f9f559-2496-49d4-b6c3-351a586b7484",
   "aud": "https://idp-p.example.com/token",
   "iat": 1418698788,
   "exp": 1418698848,
   "jti": "1418698788/107c4da5194df463e52b56865c5af34e5595"
	"cnf":{
    	"x5t#S256":"A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0"
       	}
	   }
]]></artwork>
					</figure>

					<t>
						The JWT assertion MUST be signed by the client using the client's
						private key. See
						<xref target="ClientRegistration"/>
						for mechanisms
						by which the client can make its public key known to
						the server. The
						authorization server MUST support the RS256
						signature method (the
						Rivest, Shamir, and Adleman (RSA) signature
						algorithm with a
						256-bit
						hash) and MAY use other asymmetric
						signature methods listed in the
						JSON Web Algorithms (<xref target="RFC7518">JWA</xref>)						)
						specification.
					</t>

					<t>The following sample JWT contains the above claims and has been
						signed using the RS256 JWS algorithm and the client's own private
						key (with line breaks for display purposes only):
					</t>

					<figure>
						<artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.ew0KICAgImlzcyI6ICI1NWY5ZjU1OS0\
yNDk2LTQ5ZDQtYjZjMy0zNTFhNTg2Yjc0ODQiLA0KICAgInN1YiI6ICI1NWY5ZjU1OS0\
yNDk2LTQ5ZDQtYjZjMy0zNTFhNTg2Yjc0ODQiLA0KICAgImF1ZCI6ICJodHRwczovL2l\
kcC1wLmV4YW1wbGUuY29tL3Rva2VuIiwNCiAgICJpYXQiOiAxNDE4Njk4Nzg4LA0KICA\
gImV4cCI6IDE0MTg2OTg4NDgsDQogICAianRpIjogIjE0MTg2OTg3ODgvMTA3YzRkYTU\
xOTRkZjQ2M2U1MmI1Njg2NWM1YWYzNGU1NTk1Ig0KfQ.t-_gX8JQGq3G2OEc2kUCQ8zV\
j7pqff87Sua5nktLIHj28l5onO5VpsL4sRHIGOvrpo7XO6jgtPWy3iLXv3-NLyo1TWHb\
tErQEGpmf7nKiNxVCXlGYJXSDJB6shP3OfvdUc24urPJNUGBEDptIgT7-Lhf6BbwQNlM\
QubNeOPRFDqQoLWqe7UxuI06dKX3SEQRMqcxYSIAfP7CQZ4WLuKXb6oEbaqz6gL4l6p8\
3G7wKGDeLETOTHszt-ZjKR38v4F_MnSrx8e0iIqgZwurW0RtetEWvynOCJXk-p166T7q\
ZR45xuCxgOotXY6O3et4n77GtgspMgOEKj3b_WpCiuNEwQ
]]></artwork>
					</figure>

					<t>This is sent in the request to the token endpoint as in the
						following example:
					</t>

					<figure>
						<artwork><![CDATA[POST /token HTTP/1.1
NOTE: '\' line wrapping per RFC 8792

Content-Type: application/x-www-form-urlencoded
User-Agent: Rack::OAuth2 (1.0.8.7) (2.5.3.2, ruby 2.1.3 (2014-09-19))
Accept: */*
Date: Tue, 16 Dec 2014 02:59:48 GMT
Content-Length: 884
Host: idp-p.example.com

grant_type=authorization_code
&code=sedaFh
&scope=openid+email
&client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertio\
n-type%3Ajwt-bearer
&client_assertion=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.ew0KICAgImlzc\
yI6ICI1NWY5ZjU1OS0yNDk2LTQ5ZDQtYjZjMy0zNTFhNTg2Yjc0ODQiLA0KICAgInN1Y\
iI6ICI1NWY5ZjU1OS0yNDk2LTQ5ZDQtYjZjMy0zNTFhNTg2Yjc0ODQiLA0KICAgImF1Z\
CI6ICJodHRwczovL2lkcC1wLmV4YW1wbGUuY29tL3Rva2VuIiwNCiAgICJpYXQiOiAxN\
DE4Njk4Nzg4LA0KICAgImV4cCI6IDE0MTg2OTg4NDgsDQogICAianRpIjogIjE0MTg2O\
Tg3ODgvMTA3YzRkYTUxOTRkZjQ2M2U1MmI1Njg2NWM1YWYzNGU1NTk1Ig0KfQ.t-_gX8\
JQGq3G2OEc2kUCQ8zVj7pqff87Sua5nktLIHj28l5onO5VpsL4sRHIGOvrpo7XO6jgtP\
Wy3iLXv3-NLyo1TWHbtErQEGpmf7nKiNxVCXlGYJXSDJB6shP3OfvdUc24urPJNUGBED\
ptIgT7-Lhf6BbwQNlMQubNeOPRFDqQoLWqe7UxuI06dKX3SEQRMqcxYSIAfP7CQZ4WLu\
KXb6oEbaqz6gL4l6p83G7wKGDeLETOTHszt-ZjKR38v4F_MnSrx8e0iIqgZwurW0Rtet\
EWvynOCJXk-p166T7qZR45xuCxgOotXY6O3et4n77GtgspMgOEKj3b_WpCiuNEwQ
]]></artwork>
					</figure>

			</section>


			<section title="Client Keys">
					<t>
						Clients using the authorization code grant type or direct
						access
						clients using the client credentials grant type MUST have a
						public
						and private key pair for use in authentication to the token
						endpoint. These clients MUST register their public keys in their
						client registration metadata by either sending the public key
						directly in the
						<spanx style="verb">jwks</spanx>
						field or by
						registering a
						<spanx style="verb">jwks_uri</spanx>
						that MUST be
						reachable by the authorization server. It is
						RECOMMENDED that
						clients use a
						<spanx style="verb">jwks_uri</spanx>
						if possible as
						this allows for key rotation more easily. This applies to both
						dynamic and static (out-of-band) client registration.
					</t>

					<t>
						The
						<spanx style="verb">jwks</spanx>
						field or the content
						available from the
						<spanx style="verb">jwks_uri</spanx>
						of a client
						MUST contain a public key in
						<xref target="RFC7517">JSON Web Key Set
							(JWK Set)</xref>
						format. The authorization server MUST validate the
						content of the
						client's registered jwks_uri document and verify that
						it contains a
						JWK Set. The following example is of a 2048-bit RSA
						key:
					</t>

					<figure>
						<artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

{
   "keys": [
     {
       "alg": "RS256",
       "e": "AQAB",
      "n": "kAMYD62n_f2rUcR4awJX4uccDt0zcXRssq_mDch5-ifcShx9aTtTVza2\
3PTn3KaKrsBXwWcfioXR6zQn5eYdZQVGNBfOR4rxF5i7t3hfb4WkS50EK1gBYk2lO9NS\
rQ-xG9QsUsAnN6RHksXqsdOqv-nxjLexDfIJlgbcCN9h6TB-C66ZXv7PVhl19gIYVifS\
U7liHkLe0l0fw7jUI6rHLHf4d96_neR1HrNIK_xssr99Xpv1EM_ubxpktX0T925-qej9\
fMEpzzQ5HLmcNt1H2_VQ_Ww1JOLn9vRn-H48FDj7TxlIT74XdTZgTv31w_GRPAOfyxEw\
_ZUmxhz5Z-gTlQ",
       "kty": "RSA",
       "kid": "oauth-client"
     }
   ]
}
]]></artwork>
					</figure>

					<t>For reference, the corresponding public/private key pair for
						this
						public key is the following (in JWK format):
					</t>

					<figure>
						<artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

{
  "alg": "RS256",
  "d": "PjIX4i2NsBQuOVIw74ZDjqthYsoFvaoah9GP-cPrai5s5VUIlLoadEAdGbBr\
ss_6dR58x_pRlPHWh04vLQsFBuwQNc9SN3O6TAaai9Jg5TlCi6V0d4O6lUoTYpMR0cxF\
IU-xFMwII--_OZRgmAxiYiAXQj7TKMKvgSvVO7-9-YdhMwHoD-UrJkfnZckMKSs0BoAb\
jReTski3IV9f1wVJ53_pmr9NBpiZeHYmmG_1QDSbBuY35Zummut4QShF-fey2gSALdp9\
h9hRk1p1fsTZtH2lwpvmOcjwDkSDv-zO-4Pt8NuOyqNVPFahROBPlsMVxc_zjPck8ltb\
lalBHPo6AQ",
  "e": "AQAB",
  "n": "kAMYD62n_f2rUcR4awJX4uccDt0zcXRssq_mDch5-ifcShx9aTtTVza23PTn\
3KaKrsBXwWcfioXR6zQn5eYdZQVGNBfOR4rxF5i7t3hfb4WkS50EK1gBYk2lO9NSrQ-x\
G9QsUsAnN6RHksXqsdOqv-nxjLexDfIJlgbcCN9h6TB-C66ZXv7PVhl19gIYVifSU7li\
HkLe0l0fw7jUI6rHLHf4d96_neR1HrNIK_xssr99Xpv1EM_ubxpktX0T925-qej9fMEp\
zzQ5HLmcNt1H2_VQ_Ww1JOLn9vRn-H48FDj7TxlIT74XdTZgTv31w_GRPAOfyxEw_ZUm\
xhz5Z-gTlQ",
  "kty": "RSA",
  "kid": "oauth-client"
}
]]></artwork>
					</figure>

					<t>Note that the second example contains both the public and
						private
						keys, while the first example contains the public key only.
					</t>

			</section> <!-- End of Client keys -->
				
		</section> <!-- End of Connections to AS section -->

		<section title="Connection to the Protected Resource">
			<section anchor="RequestsToProtectedResource" title="Requests to the Protected Resource">
					<t>

						Clients MUST use the authorization request header field mechanism to send bearer tokens as defined by
						<xref target="RFC6750"/>.
					</t>


					<t>An example of an OAuth-protected call to the OpenID Connect
						UserInfo endpoint, sending the token in the Authorization header,
						follows:
					</t>

					<figure>
						<artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

GET /userinfo HTTP/1.1
Authorization: Bearer eyJhbGciOiJSUzI1NiJ9.eyJleHAiOjE0MTg3MDI0MTIsI\
\mF1ZCI6WyJjMWJjODRlNC00N2VlLTRiNjQtYmI1Mi01Y2RhNmM4MWY3ODgiXSwiaXNz\
IjoiaHR0cHM6XC9cL2lkcC1wLmV4YW1wbGUuY29tXC8iLCJqdGkiOiJkM2Y3YjQ4Zi1i\
YzgxLTQwZWMtYTE0MC05NzRhZjc0YzRkZTMiLCJpYXQiOjE0MTg2OTg4MTJ9.iHMz_tz\
Z90_b0QZS-AXtQtvclZ7M4uDAs1WxCFxpgBfBanolW37X8h1ECrUJexbXMD6rrj_uuWE\
qPD738oWRo0rOnoKJAgbF1GhXPAYnN5pZRygWSD1a6RcmN85SxUig0H0e7drmdmRkPQg\
bl2wMhu-6h2Oqize4dKmykN9UX_2drXrooSxpRZqFVYX8PkCvCCBuFy2O-HPRov_SwtJ\
Mk5qjUWMyn2I4Nu2s-R20aCA-7T5dunr0iWCkLQnVnaXMfA22RlRiU87nl21zappYb1_\
EHF9ePyq3Q353cDUY7vje8m2kKXYTgc_bUAYuW-W3SMSw5UlKa
]]></artwork>
					</figure>
					</section>
<section anchor="ResponseFromProtectedResource" title="Response From the Protected Resource">
	<t>If the authentication event associated with the access token does not satisfy the requirements of the resource server for the given request, 
	the protected resource MUST return a 401 Unauthorized status code along with a WWW-Authenticate header as defined in <xref target="RFC9470">OAuth 
	2.0 Step Up Authentication Challenge Protocol</xref>. This header MUST include the insufficient_user_authentication error code to indicate that the 
	presented access token is inadequate. </t>
	
	<t>Additionally, the response MUST include the acr_values and/or max_age auth-params to communicate the necessary authentication context 
	class reference values and the allowable elapsed time since the last active authentication event, respectively. The acr_values parameter 
	should list the required authentication context class reference values in order of preference, while the max_age parameter should indicate 
	the maximum permissible time in seconds since the last user authentication.</t> 
	
	<t>The mechanisms by which the protected resource determines whether the authentication requirements are met are outside the scope of this profile.</t>
	<t>Furthermore, if both acr_values and max_age are relevant, they may be included together in the response.</t>
	
	<t>The protected resource may also include the scope parameter if additional scopes are required to access the resource, as per Section 3.1 of 
	<xref target="RFC6750">The OAuth 2.0 Authorization Framework: Bearer Token Usage</xref>.
	</t>
		
				</section>
		</section> <!-- End of Connections to Protected Resource section -->


	</section> <!-- End of Client profile section -->

	<section anchor="ServerProfile" title="Authorization Server Profile">
			<t>
				All servers MUST conform to applicable recommendations found in the
				Security Considerations sections of
				<xref target="RFC6749"/>
				and those
				found in the
				<xref target="RFC6819">OAuth Threat Model
					Document</xref>.
			</t>

			<t>The authorization server MUST protect all communications to and
				from
				its OAuth endpoints using TLS as described in Section 1.4.
			</t>


			<section title="Connections with clients">
				<t/>

				<section title="Grant types">
					<t>
						The authorization server MUST support the
						<spanx style="verb">authorization_code</spanx>, and MAY support the
						<spanx style="verb">client_credentials</spanx>
						grant types as described in
						<xref target="ClientProfiles"/>. The
						authorization server MUST limit each registered client
						(identified
						by a client ID) to a single client type only, since a
						single piece of
						software will be functioning at runtime in only one
						of the modes
						described in
						<xref target="ClientProfiles"/>. Clients that have
						multiple modes of operation MUST have a
						separate client ID for each
						mode.
					</t>
				</section>

				<section title="Client authentication">
					<t>The authorization server MUST enforce client authentication as
						described above for the authorization code and client credentials
						grant types. Public clients cannot authenticate to the authorization server.
					</t> 

					<t> The authorization server MUST validate all redirect
						URIs for authorization code grant types.
					</t>
					<t> The authorization server MUST confirm thumbprints of client keys
						if mTLS is used for client authentication or sender-constraining tokens.
					</t>				</section>

				<section anchor="DynamicRegistration" title="Dynamic Registration">
					<t>
						Dynamic Registration allows for authorized Clients to on-board programmatically without administrative intervention. This is particularly important in ecosystems with many potential Clients, including Mobile Apps acting as independent Clients. Authorization servers MUST support dynamic client registration,
						and clients MAY register using the
						<xref target="RFC7591">Dynamic
							Client Registration Protocol</xref>
						for authorization code grant types. Clients MUST NOT
						dynamically
						register for the
						client credentials grant type.
						Authorization
						servers MAY limit the
						scopes available to dynamically
						registered
						clients.
					</t>

					<t>	Authorization
						<!-- Should we make this a MUST? -->
						servers MAY protect their Dynamic Registration endpoints by requiring clients to present credentials that the authorization server would recognize as authorized participants. Authorization servers MAY accept signed software statements as described in <xref target="RFC7591"/> 
						issued to client software developers from a
						trusted registration
						entity. The software statement can be used to
						tie together many
						instances of the same client software that will be
						run, dynamically
						registered, and authorized separately at runtime.
						The software
						statement MUST include the following client metadata
						parameters:
					</t>

					<t>
						<list style="hanging">
							<t hangText="redirect_uris">
								array of redirect URIs used by the
								client; subject to the
								requirements listed in
								<xref target="RedirectURI"/>
							</t>

							<t hangText="grant_types">grant type used by the client; must be
								"authorization_code" or "client_credentials"</t>

							<t hangText="client_name">human-readable name of the client</t>

	
							<t hangText="client_uri">URL of a web page containing further
								information
								about the client
							</t>
                            <t hangText="tls_client_certificate_bound_access_tokens">
                                REQUIRED. Boolean value indicating server support for mutual-TLS client certificate-bound access tokens.
                                                        </t>
														
							<t hangText="acr_values_supported">OPTIONAL. Indicates the client will include the acr_values and max_age
   								parameters in authorization requests, and send insufficient_user_authentication error messages in conformance
								with <xref target="RFC9470">OAuth 2.0 Step Up Authentication Challenge Protocol</xref>.</t>
                                                        
                            <t hangText="dpop_signing_alg_values_supported">
                                REQUIRED. A JSON array containing a list of the JWS alg values supported by the client for DPoP proof JWTs.
                                                        </t>

							<t hangText="jwks_uri or jwks">client's public key in a JWK Set [RFC7517], or
							    if jwks_uri is used it MUST be reachable by the Authorization Server and
								point to the client's public key set. If the PKI/tls_client_auth method is used, the public key must be issued 
								by a trusted Certificate Authority. 
								If either the self-signed mTLS method or private_key_jwt method for client authentication is used, the jwks MUST include a certificate.
							</t>

						</list>
						A client using the tls_client_auth authentication method MUST use exactly one of the below metadata parameters to indicate the certificate 
						subject value that the authorization server is to expect when authenticating the respective client:
						<list style="hanging">
							<t hangText="tls_client_auth_subject_dn">String value specifying the expected subject DN of the client certificate.</t>
							<t hangText="tls_client_auth_san_dns">String value specifying the expected dNSName SAN entry in the client certificate.</t>
							<t hangText="tls_client_auth_san_uri">String value specifying the expected uniformResourceIdentifier SAN entry in the client certificate.</t>
							<t hangText="tls_client_auth_san_ip">String value specifying the expected iPAddress SAN entry in the client certificate.</t>
							<t hangText="tls_client_auth_san_email">String value specifying the expected rfc822Name SAN entry in the client certificate.</t>
						</list>
					</t>
				</section>

				<section anchor="ClientApproval" title="Client Approval">
					<t>When prompting the end user with an interactive approval page,
						the authorization server MUST indicate to the user:
					</t>

					<t>
						<list style="symbols">
							<t>Whether the client was dynamically registered, or else
								statically registered by a trusted administrator, or a public client.
							</t>

							<t>Whether the client is associated with a software statement,
								and in which case provide information about the trusted issuer
								of the software statement.
							</t>

							<t>What kind of access the client is requesting, including
								scope, protected resources (if applicable beyond scopes), 
								and access duration.
							</t>
						</list>
					</t>
					
					<t>For example, for
						native clients a message indicating a new App installation has been 
						registered as a client can help users determine if this is the expected
						behaviour. This signal helps users protect themselves from potentially 
						rogue clients.
					</t> 
				</section>

         		<section title="Sender-constrained Tokens">
                    <t> The authorization server MUST support and verify sender-constraining tokens using <xref target="RFC8705">mTLS</xref> and <xref target="RFC9449">DPoP</xref>.
                        </t>
                    
                    <t>The Authorization Server MUST NOT issue the client an access token if the client included the 
					<spanx style="verb">tls_client_certificate_bound_access_tokens</spanx>
					parameter in its registration metadata and makes a request to the token endpoint over a non-mutual-TLS connection. 
                        </t>
                    </section>

				<section anchor="Discovery" title="Discovery">
					<t>
						The authorization server MUST provide an
						<xref target="OpenID.Discovery">OpenID Connect service discovery</xref>
						endpoint listing the components relevant to the OAuth 2.0 protocol:
						<list style="hanging">
							<t hangText="issuer"> REQUIRED. The fully qualified issuer URL of the
								server
							</t>

							<t hangText="authorization_endpoint">
								REQUIRED. The fully qualified URL of
								the server's authorization endpoint
								defined by
								<xref target="RFC6749">OAuth 2.0</xref>
							</t>

							<t hangText="token_endpoint">
								REQUIRED. The fully qualified URL of the
								server's token endpoint defined by
								<xref target="RFC6749">OAuth
									2.0</xref>
							</t>

							<t hangText="token_endpoint_auth_method">
								REQUIRED. String of values corresponding to permitted methods for client authentication to the authorization server 
								as defined in <xref target="RFC7591">OAuth 2.0 Dynamic Client Registration Protocol</xref>.
								Within this profile, the server MUST provide one or more of the following values: "private_key_jwt", "tls_client_auth", and "self_signed_tls_auth".
							</t>
							
							<t hangText="introspection_endpoint">
								OPTIONAL. The fully qualified URL of
								the server's introspection endpoint
								defined by
								<xref target="RFC7662">OAuth Token Introspection</xref>
							</t>

							<t hangText="revocation_endpoint">
								OPTIONAL. The fully qualified URL of the
								server's revocation endpoint
								defined by
								<xref target="RFC7009">OAuth 2.0 Token Revocation</xref>
							</t>
							<t hangText="mtls_endpoint_aliases">
								OPTIONAL. A JSON object containing alternative 
								authorization server endpoints that, when present, an OAuth client intending to perform 
								mutual TLS uses in preference to the conventional endpoints. Use of this parameter enables isolation
								of mTLS behavior to only clients intending to use mTLS for authentication or sender-constraining tokens.
								Usage of the parameter is specified in 
								<xref target="RFC8705">OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens</xref>
							</t>
							<t hangText="jwks_uri">
								REQUIRED. The fully qualified URI of the server's
								JWK as defined in 
								<xref target="RFC8414">OAuth 2.0 Authorization Server Metadata</xref>.
								If the self_signed_tls_auth method is used, a jwks_uri MUST be registered and MUST include a certificate.
							</t>
						</list>
					</t>
						
					<t>If the TLS method for client authentication is used, exactly one authentication method metadata value MUST be included.  
						<list style="hanging">
							<t hangText="tls_client_auth">Indicates that client authentication to the authorization server will occur with mutual TLS 
								utilizing the PKI method of associating a certificate to a client.</t>
							<t hangText="self_signed_tls_client_auth">Indicates that client authentication to the authorization server will occur using mutual TLS 
								with the client utilizing a self-signed certificate.</t>
						</list>
					</t>
					
					<t>If the authorization server is also an OpenID Connect Provider,
						it MUST provide a discovery endpoint meeting the requirements
						listed
						in Section 3.6 of the iGov OpenID Connect profile.
					</t>

					<t>The following example shows the JSON document found at a
						discovery endpoint for an authorization server:
					</t>

					<figure>
						<artwork><![CDATA[{
  "request_parameter_supported": true,
  "registration_endpoint": "https://idp-p.example.com/register",
  "userinfo_signing_alg_values_supported": [
    "HS256", "HS384", "HS512", "RS256", "RS384", "RS512"
  ],
  "token_endpoint": "https://idp-p.example.com/token",
  "request_uri_parameter_supported": false,
  "request_object_encryption_enc_values_supported": [
    "A192CBC-HS384", "A192GCM", "A256CBC+HS512",
    "A128CBC+HS256", "A256CBC-HS512",
    "A128CBC-HS256", "A128GCM", "A256GCM"
  ],
  "token_endpoint_auth_methods_supported": [
    "private_key_jwt",
  ],
  "jwks_uri": "https://idp-p.example.com/jwk",
  "authorization_endpoint": "https://idp-p.example.com/authorize",
  "require_request_uri_registration": false,
  "introspection_endpoint": "https://idp-p.example.com/introspect",
  "request_object_encryption_alg_values_supported": [
    "RSA-OAEP", ?RSA1_5", "RSA-OAEP-256"
  ],
  "service_documentation": "https://idp-p.example.com/about",
  "response_types_supported": [
    "code", "token"
  ],
  "token_endpoint_auth_signing_alg_values_supported": [
    "HS256", "HS384", "HS512", "RS256", "RS384", "RS512"
  ],
  "revocation_endpoint": "https://idp-p.example.com/revoke",
  "request_object_signing_alg_values_supported": [
    "HS256", "HS384", "HS512", "RS256", "RS384", "RS512"
  ],
  "grant_types_supported": [
    "authorization_code",
    "client_credentials"
  ],
  "scopes_supported": [
    "profile", "openid", "email", "address", "phone", "offline_access"
  ],
  "op_tos_uri": "https://idp-p.example.com/about",
  "issuer": "https://idp-p.example.com/",
  "op_policy_uri": "https://idp-p.example.com/about"
  "tls_client_certificate_bound_access_tokens": "true"
  "dpop_signing_alg_values_supported": ["PS256", "ES256"]
}
]]></artwork>
					</figure>

					<t>Clients and protected resources SHOULD cache this discovery
						information. It is RECOMMENDED that servers provide cache
						information through HTTP headers and make the cache valid for at
						least one week.
					</t>

					<t>The server MUST provide its public key in JWK Set format. The
						key
						MUST contain the following fields:
					</t>

					<t>
						<list style="hanging">
							<t hangText="kid">The key ID of the key pair used to sign this
								token
							</t>

							<t hangText="kty">The key type</t>

							<t hangText="alg">The default algorithm used for this key</t>
						</list>
					</t>

					<t>The following is an example of a 2048-bit RSA public key:</t>

					<figure>
						<artwork><![CDATA[{
NOTE: '\' line wrapping per RFC 8792

"keys": [
   {
     "alg": "RS256",
     "e": "AQAB",
     "n": "o80vbR0ZfMhjZWfqwPUGNkcIeUcweFyzB2S2T-hje83IOVct8gVg9FxvHP\
K1ReEW3-p7-A8GNcLAuFP_8jPhiL6LyJC3F10aV9KPQFF-w6Eq6VtpEgYSfzvFegNiPt\
pMWd7C43EDwjQ-GrXMVCLrBYxZC-P1ShyxVBOzeR_5MTC0JGiDTecr_2YT6o_3aE2SIJ\
u4iNPgGh9MnyxdBo0Uf0TmrqEIabquXA1-V8iUihwfI8qjf3EujkYi7gXXelIo4_gipQ\
YNjr4DBNlE0__RI0kDU-27mb6esswnP2WgHZQPsk779fTcNDBIcYgyLujlcUATEqfCaP\
DNp00J6AbY6w",
     "kty": "RSA",
     "kid": "rsa1"
    }
  ]
}
]]></artwork>
					</figure>

					<t>Clients and protected resources SHOULD cache this key. It is
						RECOMMENDED that servers provide cache information through HTTP
						headers and make the cache valid for at least one week.
					</t>
				</section>

				<section title="Revocation">
 
					<t>Token revocation allows a client to signal to an authorization
						server that a given token will no longer be used.
					</t>
					<t>Authorization Servers MUST support token revocation as follows.</t>
					<t>The AS MUST provide a revocation endpoint URL as
					specified in <xref target="RFC7009">OAuth 2.0 Token Revocation</xref>
					for end users to view a list of clients that have been granted access to resources on the 
					user's behalf, and for end users to revoke this access.</t>
					
					<t>An authorization server MUST revoke the token if the client
						requesting the revocation is the client to which the token was
						issued, the client has permission to revoke tokens, and the token
						is
						revocable.
					</t>

					<t>A client MUST immediately discard the token and not use it again
						after revoking it.
					</t>
				</section>

				<section title="PKCE">
					<t>The authorization server MUST require use of PKCE
						(<xref target="RFC7636">Proof Key for Code Exchange by OAuth Public Clients</xref>) by all clients, 
						rejecting requests to the authorization endpoint from clients that do not contain a code challenge.
						Authorization servers MUST support the S256 code challenge method. 
						Authorization servers MUST NOT allow a client to use the plain
						code challenge
						method.
					</t>

				</section>

				<section title="Redirect URIs">
					<t>The authorization server MUST compare a client's registered
						redirect URIs with the redirect URI presented during an
						authorization request using an exact string match.
					</t>
				</section>
				<section title="Refresh Tokens">
					<t>AS MAY issue refresh tokens to Full (confidential) and Native (public) clients.
					</t>

					<t>AS MUST NOT issue refresh tokens to Direct clients (browser-based apps).
					</t>
				</section>
			</section>

			<section title="Connections between authorization servers and protected resources">
				<t>This profile defines interoperability requirements between authorization servers and resource servers.
				</t>

				<section anchor="JWTokens" title="JSON Web Tokens (JWT)">
					<t>All iGov-compliant authorization servers MUST issue
						cryptographically signed sender-constrained tokens in the JSON Web Token (JWT)
						format as defined in <xref target="RFC9068">JSON Web Token (JWT) Profile for OAuth 
						2.0 Access Tokens</xref>.
						The information carried in the JWT is intended to allow a
						protected
						resource to quickly test the integrity of the token
						without
						additional network calls, and to allow the protected
						resource to
						determine which authorization server issued the token.
						The protected resource MAY use the authorization server token introspection service 
						to retrieve additional security information about the token.
					</t>

					<t>The server MUST issue tokens as JWTs with, at minimum, the
						following claims:
					</t>

					<t>
						<list style="hanging">
							<t hangText="iss">The issuer URL of the server that issued the
								token
							</t>

							<t hangText="client_id">The client id of the client to whom this token
								was
								issued
							</t>

							<t hangText="exp">The expiration time (integer number of seconds
								since from 1970-01-01T00:00:00Z UTC), after which the token MUST
								be considered invalid
							</t>

							<t hangText="jti">A unique JWT Token ID value with at least 128
								bits
								of entropy. This value MUST NOT be re-used in another
								token.
								Clients MUST check for reuse of jti values and reject all
								tokens
								issued with duplicate jti values.
							</t>

							<t hangText="sub">The identifier of the end-user that authorized
								this
								client, or the client id of a client acting on its own
								behalf
								(such as a bulk transfer). Since this information could
								potentially leak private user information, it should be used
								only when needed. End-user identifiers SHOULD be pairwise 
								anonymous identifiers unless the audience requires otherwise.
							</t>

							<t hangText="aud">The audience of the token, an array containing
								the
								identifier(s) of protected resource(s) for which the token
								is
								valid, if this information is known. The aud claim may
								contain
								multiple values if the token is valid for multiple
								protected
								resources. Note that at runtime, the authorization
								server may not
								know the identifiers of all possible protected
								resources at which
								a token may be used.
							</t>
							
							<t hangText="scope">The value of the scope claim is a JSON string containing a 
								space-separated list of scopes associated with the token, in the format 
								described in Section 3.3 of <xref target="RFC6749">The OAuth 2.0 Authorization 
								Framework</xref>.</t>
								
							<t hangText="iat">The "iat" (issued at) claim identifies the time at which the JWT 
								was issued.  This claim can be used to determine the age of the JWT.  Its value MUST 
								be a number containing a NumericDate value.
							</t>
							
						</list>
					</t>
		                    <t>In order to support backwards compatibility, AS MAY include the azp claim while resource servers 
							modernize.</t>
							
							<t>Additionally, if the client uses <xref target="RFC8705">mTLS</xref> for client authentication or to sender-constrain tokens, the server MUST include the following claim in the access token.
                                             </t>
                                        
                        <list style="hanging">
                            <t hangText="cnf">Confirmation, as defined in <xref target="RFC7800">Proof-of-Possession Key Semantics
                                                for JSON Web Tokens (JWTs)</xref> and <xref target="RFC8705">OAuth 2.0 Mutual-TLS
                                                Client Authentication and Certificate-Bound Access Tokens</xref>.  The confirmation claim value MUST be computed using
                                                X.509 Certificate SHA-256 Thumbprint and include confirmation
                                                method value "x5t#256".
                                            </t>
                                </list>

					<t>The following sample claim set illustrates the use of the
						required claims for an access token as defined in this profile;
						additional claims MAY be included in the claim set:
					</t>

					<figure>
						<artwork><![CDATA[{
   "exp": 1418702388,
   "client_id": "55f9f559-2496-49d4-b6c3-351a586b7484",
   "azp": "55f9f559-2496-49d4-b6c3-351a586b7484",
   "iss": "https://idp-p.example.com/",
   "sub" : "93ff28e3-3982-c34b-f2a4-98bb3d42b277",
   "jti": "2402f87c-b6ce-45c4-95b0-7a3f2904997f",
   "iat": 1418698788,
   "scope" : "MyResource1 MyResource2",
   "acr": "myACR",
   "auth_time": 16463400198,
   "cnf": {
       "x5t#S256":"A4DtL2JmUMhAsvJj5tKyn64SqzmuXbMrJa0n761y5v0"
       }
}
]]></artwork>
					</figure>

					<t>
						The access tokens MUST be signed with
						<xref target="RFC7515">JWS</xref>
						. If private_key_jwt is used, the authorization server MUST support
						the RS256 signature method
						for tokens and MAY use other asymmetric
						signing methods as defined
						in the
						<xref target="JWS.JWE.Algs">IANA
							JSON Web Signatures and Encryption
							Algorithms registry</xref>
						. The
						JWS header MUST contain the following fields:
					</t>

					<t>
						<list style="hanging">
							<t hangText="kid">The key ID of the key pair used to sign this
								token
							</t>
						</list>
					</t>

					<t>This example access token has been signed with the server's
						private key using RS256:
					</t>

					<figure>
						<artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

eyJhbGciOiJSUzI1NiJ9.ew0KICAgImV4cCI6IDE0MTg3MDIzODgsDQogICAiYXpwIjo\
gIjU1ZjlmNTU5LTI0OTYtNDlkNC1iNmMzLTM1MWE1ODZiNzQ4NCIsDQogICAiaXNzIjo\
gImh0dHBzOi8vaWRwLXAuZXhhbXBsZS5jb20vIiwNCiAgICJqdGkiOiAiMjQwMmY4N2M\
tYjZjZS00NWM0LTk1YjAtN2EzZjI5MDQ5OTdmIiwNCiAgICJpYXQiOiAxNDE4Njk4Nzg\
4LA0KICAgImtpZCI6ICJyc2ExIg0KfQ.iB6Ix8Xeg-L-nMStgE1X75w7zgXabzw7znWU\
ECOsXpHfnYYqb-CET9Ah5IQyXIDZ20qEyN98UydgsTpiO1YJDDcZV4f4DgY0ZdG3yBW3\
XqwUQwbgF7Gwza9Z4AdhjHjzQx-lChXAyfL1xz0SBDkVbJdDjtXbvaSIyfF7ueWF3M1C\
M70-GXuRY4iucKbuytz9e7eW4Egkk4Aagl3iTk9-l5V-tvL6dYu8IlR93GKsaKE8bng0\
EZ04xcnq8s4V5Yykuc_NARBJENiKTJM8w3wh7xWP2gvMp39Y0XnuCOLyIx-J1ttX83xm\
pXDaLyyY-4HT9XHT9V73fKF8rLWJu9grrA
]]></artwork>
					</figure>

					<t>
						Refresh tokens SHOULD be signed with
						<xref target="RFC7515">JWS</xref>
						using the same private key and contain
						the same set of claims as
						the
						access tokens.
					</t>

					<t>
						The authorization server MAY encrypt access tokens and refresh
						tokens using
						<xref target="RFC7516">JWE</xref>
						. Encrypted access
						tokens MUST be encrypted using the public key of
						the protected
						resource. Encrypted refresh tokens MUST be encrypted
						using the
						authorization server's public key. 
					</t>
				</section>

				<section title="Introspection">
					<t>Token introspection allows a protected resource to query the
						authorization server for metadata about a token. The protected
						resource makes a request over a mutually authenticated TLS connection like the following to the token
						introspection endpoint:
					</t>

					<figure>
						<artwork><![CDATA[
NOTE: '\' line wrapping per RFC 8792

POST /introspect HTTP/1.1
User-Agent: Faraday v0.9.0
Content-Type: application/x-www-form-urlencoded
Accept-Encoding: gzip;q=1.0,deflate;q=0.6,identity;q=0.3
Accept: */*
Connection: close
Host: as-va.example.com
Content-Length: 1412

client_assertion=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJhMm\
MzNjkxOS0wMWZmLTQ4MTAtYTgyOS00MDBmYWQzNTczNTEiLCJzdWIiOiJhMmMzNjkxOS\
0wMWZmLTQ4MTAtYTgyOS00MDBmYWQzNTczNTEiLCJhdWQiOiJodHRwczovL2FzLXZhLm\
V4YW1wbGUuY29tL3Rva2VuIiwiaWF0IjoxNDE4Njk4ODE0LCJleHAiOjE0MTg2OTg4Nz\
QsImp0aSI6IjE0MTg2OTg4MTQvZmNmNDQ2OGY2MDVjNjE1NjliOWYyNGY5ODJlMTZhZW\
Y2OTU4In0.md7mFdNBaGhiJfE_pFkAAWA5S-JBvDw9Dk7pOOJEWcL08JGgDFoi9UDbg3\
sHeA5DrrCYGC_zw7fCGc9ovpfMB7W6YN53hGU19LtzzFN3tv9FNRq4KIzhK15pns9jck\
Ktui3HZ25L_B-BnxHe7xNo3kA1M-p51uYYIM0hw1SRi2pfwBKG5O8WntybLjuJ0R3X97\
zvqHn2Q7xdVyKlInyNPA8gIZK0HVssXxHOI6yRrAqvdMn_sneDTWPrqVpaR_c7rt8Ddd\
7drf_nTD1QxESVhYqKTax5Qfd-aq8gZz8gJCzS0yyfQh6DmdhmwgrSCCRC6BUQkeFNvj\
MVEYHQ9fr0NA
&client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertio\
n-type%3Ajwt-bearer
&client_id=a2c36919-01ff-4810-a829-400fad357351
&token=eyJhbGciOiJSUzI1NiJ9.eyJleHAiOjE0MTg3MDI0MTQsImF1ZCI6WyJlNzFm\
YjcyYS05NzRmLTQwMDEtYmNiNy1lNjdjMmJjMDAzN2YiXSwiaXNzIjoiaHR0cHM6XC9c\
L2FzLXZhLmV4YW1wbGUuY29tXC8iLCJqdGkiOiIyMWIxNTk2ZC04NWQzLTQzN2MtYWQ4\
My1iM2YyY2UyNDcyNDQiLCJpYXQiOjE0MTg2OTg4MTR9.FXDtEzDLbTHzFNroW7w27RL\
k5m0wprFfFH7h4bdFw5fR3pwiqejKmdfAbJvN3_yfAokBv06we5RARJUbdjmFFfRRW23\
cMbpGQCIk7Nq4L012X_1J4IewOQXXMLTyWQQ_BcBMjcW3MtPrY1AoOcfBOJPx1k2jwRk\
YtyVTLWlff6S5gK-ciYf3b0bAdjoQEHd_IvssIPH3xuBJkmtkrTlfWR0Q0pdpeyVePkM\
SI28XZvDaGnxA4j7QI5loZYeyzGR9h70xQLVzqwwl1P0-F_0JaDFMJFO1yl4IexfpoZZ\
sB3HhF2vFdL6D_lLeHRy-H2g2OzF59eMIsM_Ccs4G47862w
]]></artwork>
					</figure>

					<t>
						The client assertion parameter is structured as described in
						<xref target="RequestsToTokenEndpoint"/>
						.
					</t>

					<t>The server responds to an introspection request with a JSON
						object representing the token containing the following fields as
						defined in the token introspection specification:
					</t>

					<t>
						<list style="hanging">
							<t hangText="active">Boolean value indicating whether or not
								this token
								is currently active at this authorization server.
								Tokens that
								have been revoked, have expired, or were not issued
								by this
								authorization server are considered non-active.
							</t>

							<t hangText="scope">Space-separated list of OAuth 2.0 scope
								values represented as a single string.
							</t>

							<t hangText="exp">Timestamp of when this token expires (integer
								number of seconds since from 1970-01-01T00:00:00Z UTC)
							</t>

							<t hangText="sub">An opaque string that uniquely identifies the
								user
								who authorized this token at this authorization server (if
								applicable). This string MAY be diversified per client.
							</t>

							<t hangText="client_id">An opaque string that uniquely
								identifies the OAuth
								2.0 client that requested this token
							</t>
						</list>
					</t>

					<t>The following example is a response from the introspection
						endpoint:
					</t>

					<figure>
						<artwork><![CDATA[HTTP/1.1 200 OK
Date: Tue, 16 Dec 2014 03:00:14 GMT
Access-Control-Allow-Origin: *
Content-Type: application/json;charset=ISO-8859-1
Content-Language: en-US
Content-Length: 266
Connection: close

{
   "active": true,
   "scope": "file search visa",
   "exp": 1418702414,
   "sub": "{sub\u003d6WZQPpnQxV, iss\u003dhttps://idp-p.example.com/}",
   "client_id": "e71fb72a-974f-4001-bcb7-e67c2bc0037f",
   "token_type": "Bearer"
}
]]></artwork>
					</figure>

					<t>
						The authorization server MUST require authentication of resource servers
						for both the
						revocation and introspection endpoints, using either private_key_jwt or Mutual-TLS
						methods as described for clients in
						<xref target="RequestsToTokenEndpoint"/>. Protected resources calling the
						introspection endpoint MUST use
						credentials distinct from any other
						OAuth client registered at the
						server. Authorization servers MUST NOT allow authorization clients to 
						use token introspection endpoints.
					</t>

					<t>A protected resource MAY cache the response from the
						introspection endpoint for a period of time no greater than half
						the
						lifetime of the token. A protected resource MUST NOT accept a
						token
						that is not active according to the response from the
						introspection
						endpoint.
					</t>
				</section>
			</section>

			<section title="Response to Authorization Requests">
				<t> The following data will be sent as an Authorization Response to
					the Authorization Code Flow as described <xref target="ClientProfiles" />. The authentication
					response is sent via HTTP redirect to the redirect URI specified in
					the request, consistent with <xref target="RFC6749">The OAuth 2.0 Authorization Framework</xref>.</t>

				<t>
					The following fields MUST be included in the response:
					<list style="hanging">

						<t hangText="state"> REQUIRED. The value of the state parameter passed in in the
							authentication request. This value MUST match exactly.</t>

						<t hangText="code"> REQUIRED. The authorization code, a random string issued by
							the IdP to be used in the request to the token endpoint.</t>

					</list>
				</t> 
				<t>
					PKCE parameters MUST be associated with the "code" as per Section 4.4 of 
					<xref target="RFC7636">Proof Key for Code Exchange by OAuth Public Clients (PKCE)</xref> 
				</t>
				<t> The following is an example response:</t>
				<figure>
					<artwork><![CDATA[
https://https://client.example.org/cb?
    state=2ca3359dfbfd0
   &code=gOIFJ1hV6Rb1sxUdFhZGACWwR1sMhYbJJcQbVJN0wHA
]]></artwork>
				</figure>
		</section>
			<section anchor="TokenLifetimes" title="Token Lifetimes">

				<t>Access tokens SHOULD have a valid lifetime no greater than one hour, and
					refresh tokens (if issued) SHOULD have a valid lifetime no greater
					than twenty-four hours. Specific applications MAY issue tokens with different lifetimes. 
					Any active token MAY be revoked at any time.
				</t>

			</section>

			<section anchor="Scopes" title="Scopes">
				<t>Scopes define individual pieces of authority that can be
					requested
					by clients, granted by resource owners, and enforced by
					protected
					resources. Specific scope values will be highly dependent
					on the
					specific types of resources being protected in a given
					interface.
					OpenID Connect, for example, defines scope values to
					enable access
					to
					different attributes of user profiles.
				</t>

				<t>Authorization servers SHOULD define and document default scope
					values that will be used if an authorization request does not
					specify
					a requested set of scopes.
				</t>

				<t>To facilitate general use across a wide variety of protected
					resources, authorization servers SHOULD allow for the use of
					arbitrary
					scope values at runtime, such as allowing clients or
					protected
					resources to use arbitrary scope strings upon
					registration.
					Authorization servers MAY restrict certain scopes from
					use by
					dynamically registered systems or public clients.
				</t>
				
				<t>Refer to <xref target="ClientApproval"/> for further information about
				displaying scopes to end users.
				</t>
			</section>
			
		</section>

		<section title="Protected Resource Profile">
			<section anchor="ProtectingResources" title="Protecting Resources">
			
			<section anchor="TrustLevels" title="Trust Levels and Scopes">
				<t>Protected Resources grant access to clients if they present a valid sender-constrained
					<spanx style="verb">access_token</spanx> with the appropriate 
					<spanx style="verb">scope</spanx>. Resource servers trust the 
					authorization server to authenticate the end user and client appropriately
					for the importance, risk, and value level of the protected 
					resource scope.
				</t>


				<t> If a protected resources requires a higher end-user authentication trust
				    level to access certain resources, the protected resource MUST associate those resources with a 
				    unique scope and MUST associate acceptable acr values for each scope as descibed in
					<xref target="RFC9470">OAuth 2.0 Step Up Authentication Challenge Protocol"</xref>.
					Protected Resources may also specify a max_age for each scope.
				</t>
				
				<t>
					Clients wishing access to these higher level resources MUST include the
					higher level scope and acr_values in their authorization request to the authorization server.  
				</t>

				<t> Authorization servers MUST only grant access to higher level scope resources to 
					clients that have permission to request these scope levels and have met . Client authorization 
					requests containing 
					scopes that are outside their permission MUST be rejected.
				</t>
		
				<t>Authorization servers MAY set the expiry time (<spanx style="verb">exp</spanx>)
				   of access_tokens associated with higher level resources to be shorter than 
				   access_tokens for less sensitive resources. 
				</t>
				
				<t>Authorization servers MAY allow a <spanx style="verb">refresh_token</spanx>
				 issued at a higher level to be
					used to obtain an access_token for a lower level resource scope with an 
					extended expiry time. The client MUST request both the higher level scope and 
					lower level scope in the original authorization request. This allows clients to
					continue accessing lower level resources after the higher level resource access
					has expired -- without requiring an additional user authentication/authorization.
				</t>
			</section>

			<section anchor="TrustExample" title="Trust Levels Example">	
				<t>For example: a resource server has resources classified as "public" and "sensitive" and assocaites
					scopes of the same name with those resources.
					Access to resources with scope "sensitive" requires the user to perform a two-factor authentication 
					and limits those access grants to only 15 minutes. 
					The resource server associates scope "sensitive" with acr="MFA".
					</t>
					<t>
					For a client to obtain access to both "public" and "sensitive" resources, 
					it makes an authorization request to the authorization server with 
					<spanx style="verb">scope=public+sensitive</spanx>, acr_values="MFA", and 
					max_age=900. The authorization
					server authenticates the end-user as required to meet the required trust level
					(two-factor authentication or some approved equivalent) and issues an 
					<spanx style="verb">access_token</spanx> for the "public" and "sensitive" scopes
					with an expiry time of 15mins, and a <spanx style="verb">refresh_token</spanx>
					for the "public" scope with an expiry time of 24 hrs. 
					</t>
					<t>
					The client can access both 
					"public" and "sensitive" resources for 15mins with the access_token. When the 
					access_token expires, the client will NOT be able to access "public" or "sensitive"
					resources any longer as the access_token has expired, and must obtain a 
					new access_token. 
					</t>
					<t>
					The client makes a 
					refresh token request (as described in <xref target="RFC6749">OAuth 2.0</xref> 
					section 6) with the refresh_token, 
					and the reduced scope of just "public". The token endpoint validates the refresh_token,
					and issues a new access_token for just the "public" scope with an expiry time set to 24hrs.
					An access grant request for a new access_token with the "sensitive" scope would be 
					rejected, and require the client to get the end-user to re-authenticate/authorize the
					"sensitive" scope request.   
				</t>
				<t> In this manner, protected resources and authorization servers work together to meet
					risk tolerance levels for sensitive resources and end-user authentication.
				</t>
				</section>

			</section>
			<section title="Connections with Clients">
				<t>
					A protected resource MUST accept bearer tokens passed in the
					authorization header as described in
					<xref target="RFC6750"/>
					. A
					protected resource MUST NOT accept bearer tokens passed in the
					form
					parameter or query parameter methods.
				</t>

				<t>Protected resources MUST define and document which scopes are
					required for access to the resource and any authentication strength or recency requirements for each scope.
				</t>

				<t> If a client uses the <xref target="RFC8705">mTLS</xref> method to sender-constrain tokens, the protected resource 
				MUST verify that the certificate matches the certificate associated with the 
				access token. If they do not match, the resource access attempt MUST be denied. 
				The client SHOULD use a certificate to sender-constrain tokens that is distinct from the certificate used to connect 
				to the protected resource. 
				</t>
			
			</section>

			<section title="Connections with Authorization Servers">
				<t>Protected resources MUST interpret access tokens using either
					JWT,
					token introspection, or a combination of the two.
				</t>

				<t>
					The protected resource MUST check the
					<spanx style="verb">aud</spanx>
					(audience) claim, if it exists in the token, to ensure that it
					includes the protected resource's identifier. The protected
					resource
					MUST ensure that the rights associated with the token are
					sufficient
					to grant access to the resource. For example, this can be
					accomplished
					by querying the scopes and acr associated with the token from
					the
					authorization server's token introspection endpoint.
				</t>

				<t>A protected resource MUST limit which authorization servers it
					will
					accept valid tokens from. A resource server MAY accomplish
					this using
					a whitelist of trusted servers, a dynamic policy engine,
					or other
					means.
				</t>
			</section>
		</section>

		<section title="Security Considerations">
		
				<!--  Need to add data from John's RFC regarding registration security -->
			<section title="DNSSEC Considerations">
                <t>For a comprehensive protection against network attackers, all endpoints should additionally use DNSSEC to protect 
				 against DNS spoofing attacks that can lead to the issuance of rogue domain-validated TLS certificates.
            	</t>
			</section>
			
			<section title="Protected Resource Metadata">
				<t><xref target="Resource.Metadata">OAuth 2.0 Protected Resource Metadata</xref>defines a metadata format that an 
				OAuth 2.0 client or authorization server can use to obtain the information needed to interact with an OAuth 2.0 protected resource,
				which may facilitate enhanced interoperability and security, including advertisement and discovery of a protected resource's public key
				via its jwks_uri.
				</t>
			</section>
			
			<section title="Best Practices">
				<t>Authorization servers, clients, and protected resources SHOULD consider internet best practices from 
					<xref target="BCP240">Best Current Practice for OAuth 2.0 Security</xref>, 
					<xref target="RFC8725">JSON Web Token Best Current Practices</xref> and
					<xref target="RFC9068">JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens</xref> that are not
					explicitly REQUIRED or RECOMMENDED in this profile.
				</t>
			</section>
			
			<section title="Other Considerations">

				<t> Authorization Servers SHOULD take into account device posture when dealing
					with native apps if possible. Some examples of device posture include:</t>
					<t><list style="symbols">
					<t>the user's lock screen setting</t>
					<t>the app's level of privilege over the device operating system (e.g. if the app has 'root access', the 
					device operating system may be compromised to gain additional privileges not intended by the vendor)</t>
					<t>the availability of a device attestation to validate the app</t>
					</list></t>
				<t>
					Specific policies or capabilities are outside the scope of this specification.
				</t>  

				<t>
					This profile does not protect against the attacks described in 
					<xref target="SAM">The Stronger Attacker Model</xref>, in which an attacker
					could inject the authorization request and read the authorization response.
					Although using request object signatures would provide mitigation, this profile does not require 
					request object signatures because of the lack of available implementations. 
				</t>
			</section>
		</section>
			<section title="Privacy Considerations">
                <t>This profile addresses the privacy threats identified in <xref target="RFC6973">Privacy Considerations for Internet Protocols</xref> with normative 
				language throughout the document. In particular, this profile requires the use of TLS for all network connections, PKCE, and sender constrained tokens 
				to mitigate the threats in <xref target="RFC6973"></xref>
				</t>
				<t>In OpenID Connect implementations, servers and clients SHOULD implement the privacy threat mitigations in Section 17 of 
				<xref target="OpenID.Core">OpenID Connect Core 1.0</xref>.
                </t>
			</section>
	</middle>

	<back>
		<references title="Normative References">
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6749"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6750"/>
	  
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6797"/>
	  
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6819"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6973"/>  

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7009"/>
	  
      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7515"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7516"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7517"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7519"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7523"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7591"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7636"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7662"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7518"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7800"/>

      <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8414"/>
	  
	  <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8252"/>

	  <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8705"/>
	  
	  <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8725"/>
	  
	  <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9068"/>
	  
	  <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9449"/>
	  
	  <xi:include href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9470"/>
	  
	  <reference anchor="BCP195" target="http://www.rfc-editor.org/info/bcp195">
				<front>
					<title>Recommendations for Secure Use of Transport Layer Security
						(TLS) and Datagram Transport Layer Security (DTLS)</title>

					<author fullname="Y. Sheffer" initials="Y." surname="Sheffer">
						<organization/>
					</author>

					<author fullname="R. Holz" initials="R." surname="Holz">
						<organization/>
					</author>

					<author fullname="P. Saint-Andre" initials="P." surname="Saint-Andre">
						<organization/>
					</author>

					<date month="May" year="2015"/>

					<abstract>
						<t>Transport Layer Security (TLS) and Datagram Transport Layer
							Security (DTLS) are widely used to protect data exchanged over
							application protocols such as HTTP, SMTP, IMAP, POP, SIP, and
							XMPP. Over the last few years, several serious attacks on TLS
							have
							emerged, including attacks on its most commonly used cipher
							suites
							and their modes of operation. This document provides
							recommendations for improving the security of deployed services
							that use TLS and DTLS. The recommendations are applicable to the
							majority of use cases.
						</t>
					</abstract>
				</front>

				<seriesInfo name="BCP" value="195"/>

				<seriesInfo name="RFC" value="7525"/>
				
				<seriesInfo name="DOI" value="10.17487/RFC7525"/>

				<format octets="60283" type="ASCII"/>
			</reference>

	  <reference anchor="BCP240" target="http://www.rfc-editor.org/info/bcp240">
				<front>
					<title>Best Current Practice for OAuth 2.0 Security</title>

					<author fullname="Torsten Lodderstedt" initials="T." surname="Lodderstedt">
											<organization/>
					</author>
					<author fullname="John Bradley" initials="J." surname="Bradley">
											<organization/>
					</author>
					<author fullname="Andrey Labunets" initials="A." surname="Labunets">
											<organization/>
					</author>
					<author fullname="Daniel Fett" initials="D." surname="Fett">
											<organization/>
					</author>

					<date month="January" year="2025"/>

					<abstract>
						<t>   This document describes best current security practice for OAuth 2.0.
							   It updates and extends the threat model and security advice given in
							   RFCs 6749, 6750, and 6819 to incorporate practical experiences
							   gathered since OAuth 2.0 was published and covers new threats
							   relevant due to the broader application of OAuth 2.0.  Further, it
							   deprecates some modes of operation that are deemed less secure or
							   even insecure.
						</t>
					</abstract>
				</front>

				<seriesInfo name="BCP" value="240"/>

				<seriesInfo name="RFC" value="9700"/>
				
				<seriesInfo name="DOI" value="10.17487/RFC9700"/>

				<format octets="60283" type="ASCII"/>
			</reference>

			<reference anchor="OpenID.Core" target="http://openid.net/specs/openid-connect-core-1_0.html">
				<front>
					<title>OpenID Connect Core 1.0</title>

					<author fullname="Nat Sakimura" initials="N." surname="Sakimura">
						<organization abbrev="NRI">Nomura Research Institute,
							Ltd.</organization>
					</author>

					<author fullname="John Bradley" initials="J." surname="Bradley">
						<organization abbrev="Ping Identity">Ping Identity</organization>
					</author>

					<author fullname="Michael B. Jones" initials="M.B." surname="Jones">
						<organization abbrev="Microsoft">Microsoft</organization>
					</author>

					<author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
						<organization abbrev="Google">Google</organization>
					</author>

					<author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
						<organization abbrev="Salesforce">Salesforce</organization>
					</author>

					<date day="3" month="August" year="2015"/>
				</front>
			</reference>

			<reference anchor="OpenID.Discovery" target="http://openid.net/specs/openid-connect-discovery-1_0.html">
				<front>
					<title>OpenID Connect Discovery 1.0</title>

					<author fullname="Nat Sakimura" initials="N." surname="Sakimura">
						<organization abbrev="NRI">Nomura Research Institute,
							Ltd.</organization>
					</author>

					<author fullname="John Bradley" initials="J." surname="Bradley">
						<organization abbrev="Ping Identity">Ping Identity</organization>
					</author>

					<author fullname="Michael B. Jones" initials="M.B." surname="Jones">
						<organization abbrev="Microsoft">Microsoft</organization>
					</author>

					<author fullname="Edmund Jay" initials="E." surname="Jay">
						<organization abbrev="Illumila">IllumilaJSON</organization>
					</author>

					<date day="3" month="August" year="2015"/>
				</front>
			</reference>

			<reference anchor="OpenID.iGov" target="https://openid.net/specs/openid-igov-openid-connect-1_0.html">
				<front>
					<title>International Government Assurance Profile (iGov) for OpenID Connect 1.0</title>
					<author fullname="Michael Varleyy" initials="M." surname="Varley"/>
					<author fullname="Paul Grassi" initials="P." surname="Grassi"/>
					<date day="3" month="August" year="2023"/>
				</front>
			</reference>

			<reference anchor="JWS.JWE.Algs">
				<front>
					<title>JSON Web Signature and Encryption Algorithms registry</title>

					<author>
						<organization/>
					</author>

					<date day="8" month="August" year="2016"/>
				</front>
			</reference>

			<reference anchor="HEART.OAuth2" target="http://openid.net/specs/openid-heart-oauth2-1_0-ID1.html">
				<front>
					<title>Health Relationship Trust Profile for OAuth 2.0</title>

					<author fullname="Justin Richer" initials="J." surname="Richer"/>

					<date day="25" month="April" year="2017"/>
				</front>
			</reference>
			
			<reference anchor="mlkem.ikev2" target="https://datatracker.ietf.org/doc/draft-kampanakis-ml-kem-ikev2/">
				<front>
					<title>Post-quantum Hybrid Key Exchange with ML-KEM in the Internet Key Exchange Protocol Version 2 (IKEv2)</title>
					<author fullname="Panos Kampanakis" initials="P." surname="Kampanakis"/>
					<author fullname="Gerardo Ravago" initials="G." surname="Ravago"/>
					<date day="4" month="November" year="2024"/>
				</front>
			</reference>

			<reference anchor="Resource.Metadata" target="https://datatracker.ietf.org/doc/draft-ietf-oauth-resource-metadata/">
				<front>
					<title>OAuth 2.0 Protected Resource Metadata</title>
					<author fullname="Mike Jones" initials="M." surname="Jones"/>
					<author fullname="Phil Hunt" initials="P." surname="Hunt"/>
					<author fullname="Aaron Parecki" initials="A." surname="Parecki"/>
					<date day="15" month="October" year="2024"/>
				</front>
			</reference>
			
			<reference anchor="SAM" target="https://danielfett.de/2020/05/16/pkce-vs-nonce-equivalent-or-not/">
				<front>
					<title>PKCE vs. Nonce: Equivalent or Not?</title>
					<author fullname="Daniel Fett" initials="D." surname="Fett"/>
					<date day="16" month="May" year="2020"/>
				</front>
			</reference>

			<reference anchor="browser-based-apps" target="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-browser-based-apps">
                <front>
                    <title>OAuth 2.0 for Browser-Based Applications</title>
                    <author fullname="Aaron Parecki" initials="A." surname="Parecki"/>
                    <author fullname="David Waite" initials="D." surname="Waite"/>
                    <author fullname="Philippe De Ryck" initials="P." surname="De Ryck"/>
                    <date day="17" month="January" year="2025"/>
                </front>
            </reference>


		</references>

		<section anchor="Acknowledgements" title="Acknowledgements">
			<t>The OpenID Community would like to thank the following people for
				their contributions to this specification: Mark Russel, Mary
				Pulvermacher, David Hill, Dale Moberg, Adrian Gropper, Eve Maler,
				Danny van Leeuwen, John Moehrke, Aaron Seib, John Bradley, Debbie
				Bucci, Josh Mandel, Sarah Cecchetti, Giuseppe De Marco, Joseph Heenan, 
				Jim Fenton, Ryan Galluzzo, Bjorn Hjelm, Aaron Parecki, and Michael B. Jones.
			</t>
			<t> Special thank you to the original iGov Profile editors: Paul Grassi, Justin Richer,
			    and Michael Varley.
				</t>

			<t>The original version of this specification was part of the Secure
				RESTful Interfaces project from The MITRE Corporation, available
				online
				at http://secure-restful-interface-profile.github.io/pages/
			</t>
		</section>

		<section anchor="Notices" title="Notices">
			<t>Copyright (c) 2025 The OpenID Foundation.</t>

			<t>The OpenID Foundation (OIDF) grants to any Contributor, developer, implementer, or other interested party a non-exclusive, royalty free, worldwide copyright license to reproduce, 
			prepare derivative works from, distribute, perform and display, this Implementers Draft, Final Specification, or Final Specification Incorporating Errata Corrections solely for the 
			purposes of (i) developing specifications, and (ii) implementing Implementers Drafts, Final Specifications, and Final Specification Incorporating Errata Corrections based on such 
			documents, provided that attribution be made to the OIDF as the source of the material, but that such attribution does not indicate an endorsement by the OIDF.</t>

			<t>The technology described in this specification was made available from contributions from various sources, including members of the OpenID Foundation and others. Although the 
			OpenID Foundation has taken steps to help ensure that the technology is available for distribution, it takes no position regarding the validity or scope of any intellectual property 
			or other rights that might be claimed to pertain to the implementation or use of the technology described in this specification or the extent to which any license under such rights 
			might or might not be available; neither does it represent that it has made any independent effort to identify any such rights. The OpenID Foundation and the contributors to this 
			specification make no (and hereby expressly disclaim any) warranties (express, implied, or otherwise), including implied warranties of merchantability, non-infringement, fitness 
			for a particular purpose, or title, related to this specification, and the entire risk as to implementing this specification is assumed by the implementer. The OpenID Intellectual 
			Property Rights policy (found at openid.net) requires contributors to offer a patent promise not to assert certain patent claims against other contributors and against implementers. 
			OpenID invites any interested party to bring to its attention any copyrights, patents, patent applications, or other proprietary rights that may cover technology that may be required 
			to practice this specification.</t>
		</section>

		<section anchor="History" title="Document History">
      <t>[[ To be removed from the final specification ]]</t>
 
 	<t>
	-05
	<list style="symbols">
	  <t>
	    Updated BCP mitigations, aligned with FAPI
	  </t>
	  <t>
	    Harmonized cryptography, sender constrained tokens with FAPI
	  </t>
	  <t>
	    Added requirement and optionality for authentication context and support for Step-up (RFC 9470)
	  </t>
	  <t>
	    Added Privacy Considerations (RFC 6973)
	  </t>
	  <t>
	    Added optionality to support enterprise tailoring, especially RFC 8705 mTLS with PKI
	  </t>	  
	  </list>
      </t>
      <t>
	-04
	<list style="symbols">
	  <t>
	    Enable building with https://author-tools.ietf.org/.
	  </t>
	  <t>
	    Applied OpenID specification conventions.
	  </t>
        </list>
      </t>

      <t>
	-03
	<list style="symbols">
	  <t>
	    First Implementer's Draft
	  </t>
        </list>
      </t>

			<t>-2017-06-01</t>

			<t>
				<list style="symbols">
					<t>Aligned with prior version of iGov.</t>
					<t>Added guidance text around using scopes and refresh_tokens to protect sensitive resources.</t>
					<t>Removed ACR reference.</t>
				</list>
			</t>

			<t>-2018-05-07</t>

			<t>
				<list style="symbols">
					<t>Imported content from HEART OAuth profile.</t>
				</list>
			</t>
		</section>
	</back>
</rfc>
