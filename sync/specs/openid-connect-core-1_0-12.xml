<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='http://xml.resource.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc PUBLIC "-//IETF//DTD RFC 2629//EN"
"http://xml.resource.org/authoring/rfc2629.dtd">
<rfc category="exp" docName="openid-connect-core-1_0" ipr="trust200902">

  <?rfc toc="yes" ?>
  <?rfc tocdepth="5" ?>
  <?rfc symrefs="yes" ?>
  <?rfc sortrefs="yes"?>
  <?rfc strict="no" ?>
  <?rfc iprnotified="no" ?>
  <?rfc private="Draft" ?>

  <front>
    <title abbrev="OpenID Connect Core 1.0">OpenID Connect Core 1.0 - draft 12</title>

    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
      <address>
        <email>n-sakimura@nri.co.jp</email>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization abbrev="Ping Identity">Ping Identity</organization>
      <address>
        <email>ve7jtb@ve7jtb.com</email>
      </address>
    </author>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization abbrev="Microsoft">Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
      </address>
    </author>

    <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
      <organization abbrev="Google">Google</organization>
      <address>
        <email>breno@google.com</email>
      </address>
    </author>

    <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
      <organization abbrev="Salesforce">Salesforce</organization>
      <address>
        <email>cmortimore@salesforce.com</email>
      </address>
    </author>

    <date day="24" month="September" year="2013" />

    <workgroup>OpenID Connect Working Group</workgroup>

    <abstract>
      <t>OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0
      protocol. It allows Clients to verify the identity of the End-User based
      on the authentication performed by an Authorization Server, as well as to
      obtain basic profile information about the End-User in an interoperable and 
      REST-like manner.</t>

      <t>
	This specification defines
	the core OpenID Connect functionality:
	authentication built on top of OAuth 2.0 and
	the use of Claims to communicate information about the End-User.
	It also describes the security and privacy considerations for using OpenID Connect.
      </t>
    </abstract>
  </front>

  <middle>
    <section anchor='Introduction' title='Introduction'>

      <t>OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0
      protocol. It allows Clients to verify the identity of the End-User based
      on the authentication performed by an Authorization Server, as well as to
      obtain basic profile information about the End-User in an interoperable and 
      REST-like manner.</t>

      <t>
	The OpenID Connect Core 1.0 specification defines
	the core OpenID Connect functionality:
	authentication built on top of OAuth 2.0 and
	the use of Claims to communicate information about the End-User.
	It also describes the security and privacy considerations for using OpenID Connect.
      </t>

      <t>
	As background,
	the <xref target="RFC6749">OAuth 2.0 Authorization Framework</xref>
	and <xref target="RFC6750">OAuth 2.0 Bearer Token Usage</xref>
	specifications provide a general framework for third-party applications
	to obtain and use limited access to HTTP resources.  They define
	mechanisms to obtain and use Access Tokens to access resources but
	do not define standard methods to provide identity information.
	Notably, without profiling OAuth 2.0, it is incapable of
	providing information about the authentication of an End-User.
      </t>

      <section anchor="rnc" title="Requirements Notation and Conventions">
	<t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
	"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
	document are to be interpreted as described in <xref
	target="RFC2119">RFC 2119</xref>.</t>

	<t>Throughout this document, values are quoted to indicate that they are
	to be taken literally. When using these values in protocol messages, the
	quotes MUST NOT be used as part of the value.</t>

	<t>
	  All uses of <xref target="JWS">JSON Web Signature (JWS)</xref>
	  and <xref target="JWE">JSON Web Encryption (JWE)</xref>
	  data structures in this specification utilize
	  the JWS Compact Serialization or the JWE Compact Serialization;
	  the JWS JSON Serialization and the JWE JSON Serialization are not used.
	</t>
      </section>

      <section anchor="terminology" title="Terminology">
	<t>
	  This section defines the terminology used by this specification.
	  This section is a normative portion of this specification,
	  imposing requirements upon implementations.  All the
	  capitalized words in the text of this specification, such as
	  "Issuer Identifier", reference these defined terms.
	  Whenever the reader encounters them, their definitions
	  found in this section must be followed.
	</t>

        <t>This specification uses the terms "Access Token", "Refresh Token",
        "Authorization Code", "Authorization Grant", "Authorization Server",
        "Authorization Endpoint", "Client", "Client Identifier", "Client Secret",
	"Protected Resource", "Resource Owner", "Resource Server", and
        "Token Endpoint" defined by
        <xref target="RFC6749">OAuth 2.0</xref>,
        and the terms "Claim Names" and "Claim Values" defined by
        <xref target="JWT">JSON Web Token (JWT)</xref>.
        </t>
        <t>
          This specification also defines the following terms:
          <list style="hanging">
            <t hangText="Authentication">
	      Process of verifying that an Entity is the owner of an Identity.
	      Typically this involves the verification of the current or past
	      possession of particular credentials, including what the entity knows,
	      possesses, has as physical features, or behaviors, or combinations of
	      these utilizing heuristics. The entity is often an End-User or a Client.
	    </t>

            <t hangText="Authentication Context">
              Information that the Relying Party can require before it makes an 
              entitlement decision with respect to an authentication response. 
              Such context can include, but is not limited to, the actual 
              authentication method used or level of assurance such as 
              <xref target="ISO29115">ISO/IEC 29115</xref> 
              entity authentication assurance level.
            </t>

            <t hangText="Authentication Context Class">
              Set of authentication methods or procedures that are considered
	      to be equivalent to each other in a particular context.
            </t>

            <t hangText="Authentication Context Class Reference">
              Identifier for an Authentication Context Class. 
            </t>

            <t hangText="Claim">
	      Piece of information asserted about an Entity.
	    </t>

	    <t hangText="Claim Type">
	      Syntax used for representing a Claim Value.
	      This specification defines Normal, Aggregated, and Distributed Claim Types.
	    </t>

            <t hangText="Claims Provider">
	      Server that can return Claims about an Entity.
	    </t>

	    <t hangText="Credential">
	      Data presented as evidence of the right to use an identity
	      or other resources.
	    </t>

            <t hangText="End-User">
              Human Resource Owner.
            </t>
            <t hangText="Entity">
              Something that has a separate and distinct existence and that can be
	      identified in a context. An End-User is one example of an Entity.
            </t>

            <t hangText="Essential Claim">
              Claim specified by the Client as being necessary to ensure a smooth
	      authorization experience for the specific task requested by the End-User.
            </t>

            <t hangText="ID Token">
              <xref target="JWT">JSON Web Token (JWT)</xref> that contains Claims about the authentication event.
	      It MAY contain other Claims.
            </t>

            <t hangText="Identifier">
	     Value that uniquely characterizes an Entity in a specific context.
	    </t>

            <t hangText="Identity">
	      Set of attributes related to an Entity.
	    </t>

            <t hangText="Issuer">Entity that issues a set of Claims.</t>

            <t hangText="Issuer Identifier">
	      Verifiable Identifier for an Issuer.
	      An Issuer Identifier is a case sensitive URL
	      using the <spanx style="verb">https</spanx> scheme that
	      contains scheme, host, and OPTIONALLY, port number and path
	      components and no query or fragment components.
	    </t>

            <t hangText="Message">Request or a response between an OpenID 
            Relying Party and an OpenID Provider.</t>

            <t hangText="OpenID Provider (OP)">
              OAuth 2.0 Authorization Server that is capable of 
              providing Claims to a Relying Party
              about the authentication event and the End-User
              in an ID Token and/or a UserInfo Endpoint response. 
            </t>

            <t hangText="OP Endpoints">Authorization Endpoint, Token Endpoint,
	    and UserInfo Endpoint.</t>

            <t hangText="Request Object">
	      JWT that contains a set of request parameters as its Claims.
	    </t>

	    <t hangText="Request URI">
	      URL that references a resource containing a Request Object.
	      The Request URI contents MUST be retrievable by the
	      Authorization Server.
	    </t>

            <t hangText="Pairwise Pseudonymous Identifier (PPID)">
	      Identifier that identifies the Entity to a Relying Party that cannot be correlated 
	      with the Entity's PPID at another Relying Party.
	    </t>

            <t hangText="Personally Identifiable Information (PII)">
              Information that (a) can be used to identify the natural person
              to whom such information relates, or
              (b) is or might be directly or indirectly linked to a
	      natural person to whom such information relates.
	    </t>

            <t hangText="Relying Party (RP)">
              OAuth 2.0 Client application requiring Claims from an OpenID Provider. 
            </t>

	    <t hangText="Self-Issued OpenID Provider">
	      Personal OpenID Provider that issues self-signed ID Tokens.
	    </t>

            <t hangText="UserInfo Endpoint">
              Protected resource that, when presented with an Access Token by the Client,
	      returns authorized information about the End-User represented by the corresponding 
              Authorization Grant.
            </t>
 
            <t hangText="Validation">
	      Process intended to establish the soundness or correctness of a construct.
	    </t>

            <t hangText="Verification">
	      Process intended to test or prove the truth or accuracy of a fact or value.
	    </t>

            <t hangText="Voluntary Claim">
              Claim specified by the Client as being useful but not Essential
              for the specific task requested by the End-User.
            </t>

          </list>
        </t>
	<t>
	  For more background on some of the terminology used,
	  see <xref target="RFC4949">Internet Security Glossary, Version 2</xref>,
	  <xref target="ISO29115">ISO/IEC 29115 Entity Authentication Assurance</xref>,
	  and <xref target="X.1252">ITU-T X.1252</xref>.
	</t>
      </section>

      <section anchor="Overview" title="Overview">
	<t>The OpenID Connect protocol, in abstract, follows the following
	steps.</t>

	<t>
	  <list style="numbers">
	    <t>The RP (Client) sends a request to the OP's (Authorization Server's) 
	    End-User Authorization Endpoint.</t>

	    <t>The OP authenticates the End-User and obtains 
	    appropriate authorization.</t>

	    <t>The OP responds with an Access Token and an ID Token.</t>
	    
	    <t>The RP can send a request with the Access Token to the UserInfo Endpoint,
	    per <xref target="userinfo"/>.</t>

	    <t>The UserInfo Endpoint returns Claims about the End-User.</t>

	  </list>
	</t>

      </section>
    </section>

    <section anchor="Messages" title="Messages">

      <t>In OpenID Connect, the RP interacts with these endpoints at the OP:</t>

      <t>
	<list style="numbers">
          <t>Authorization Endpoint: The RP sends a request to the 
          OP at the Authorization Endpoint. The OP 
          then authenticates the End-User.
	  Then, after potential authorization actions by the
          End-User, the Authorization Server returns an Authorization Response,
          which can include an Authorization Code value.
          For some Clients, the Implicit Grant will be used to obtain
	  an ID Token and Access Token without using an Authorization Code;
	  the <spanx style="verb">response_type</spanx> parameter value
	  <spanx style="verb">id_token&nbsp;token</spanx> does this.
          For some Clients, the Implicit Grant will be used to obtain only an ID Token;
	  the <spanx style="verb">response_type</spanx> parameter value
	  <spanx style="verb">id_token</spanx> does this.
	  </t>

          <t>Token Endpoint: Clients using an Authorization Code send an Access Token Request
	  containing the Authorization Code to the
          Token Endpoint to obtain an Access Token Response that includes an
          Access Token and an ID Token.
	  The Client can also send a Refresh Token to it to obtain a new Access Token.
	  </t>

          <t>UserInfo Endpoint: Clients using an Access Token send the Access Token to the UserInfo Endpoint
	  to obtain Claims about the End-User.</t>

        </list>
      </t>

      <section anchor="AuthorizationEndpoint" title="Authorization Endpoint">
	<t>
	  The Authorization Endpoint performs authentication of the
	  End-User and requests authorization from the End-User to release
	  information to an OpenID Connect Relying Party (Client). When an End-User 
	  accesses a Relying Party application that requires
	  the End-User's identity and other information, it sends the End-User to
	  the Authorization Server's Authorization Endpoint for authentication and
	  authorization. The Authorization Server then issues an ID Token that
	  asserts the End-User's identity and,
	  in some cases, also issues an Access Token that allows the
	  Client to access the End-User's information at Protected Resource
	  endpoints. Protected Resource endpoints MAY perform different actions or
	  return different information based on the scopes associated with the 
	  presented Access Token.
	</t>

	<section anchor="protocol_flows" title="Protocol Flows">
	  <!-- From Basic - TBD Do we want to use this language?
	  <t>Authorization Requests can follow one of two paths; the Implicit Flow
	  or the Authorization Code Flow. The Authorization Code Flow is
	  suitable for Clients that can securely maintain a Client Secret between
	  themselves and the Authorization Server whereas, the Implicit Flow is
	  suitable for Clients that cannot.</t>

	  <t>
	    This specification only provides information that is sufficient for
	    basic Clients using the Code Flow.
	  </t>
	  -->

	  <t>Authorization Requests follow two main paths to obtain Access Tokens
	  and ID Tokens, the Implicit Flow and the Authorization Code Flow. The 
	  flows determine how the Access Token and ID Token are returned to the 
	  Client. Access Tokens are credentials used to access Protected 
	  Resources, as defined in Section 1.4 of 
	  <xref target="RFC6749">OAuth 2.0</xref>. Access Tokens represent 
	  a Resource Owner's authorization and MUST NOT be exposed to 
	  unauthorized parties.</t>

	  <t>The Implicit Flow is mainly used by Clients implemented in a browser
	  using a scripting language. The Access Token and ID Token are returned
	  directly to the Client, which MAY expose them to the Resource Owner and
	  other applications that have access to the Resource Owner's User-Agent.
	  The Authorization Server does not perform Client Authentication before
	  issuing the Access Token.</t>

	  <t>The Authorization Code Flow returns an Authorization Code to the
	  Client, which can then exchange it for an Access Token directly. This
	  provides the added benefit of not exposing the Access Token to the 
	  Resource Owner and possibly other malicious applications with access
	  to the Resource Owner's User-Agent. The Authorization Server can also
	  authenticate the Client before exchanging the Authorization Code for an
	  Access Token. The Authorization Code flow is suitable for Clients that 
	  can securely maintain a Client Secret between themselves and the
	  Authorization Server whereas the Implicit flow is suitable for Clients
	  that cannot.</t>

	  <section anchor="retrieving_code_token" 
		   title="Obtaining the Authorization Code, ID Token, and Access Token">
	    <t>In this specification, the Client sends the Authorization Request 
	    to the Authorization Endpoint through the User-Agent to obtain the 
	    ID Token and Access Token.
	    It can obtain them from the Token Endpoint utilizing the Authorization Code
	    that it obtained from the Authorization Endpoint using the Authorization Code Flow
	    or from the Authorization Endpoint using the Implicit Flow.
	    </t>
	    
	  </section>

	  <section anchor="code_flow" title="Authorization Code Flow">
	    <t>The Authorization Code Flow goes through the following
	    steps.</t>          
	    <t><list style="numbers">
              <t>Client prepares an Authorization Request containing the desired
              request parameters.</t>

              <t>Client sends a request to the Authorization Server.</t>

              <t>Authorization Server Authenticates the End-User.</t>

              <t>Authorization Server Obtains the End-User
              Consent/Authorization.</t>

              <t>Authorization Server Sends the End-User back to the Client with
              an Authorization Code.</t>

              <t>Client requests a response using the Authorization Code at the
              Token Endpoint, per <xref target="token_ep"/>.</t>

              <t>Client receives a response that contains an Access Token and ID
              Token in the response body.</t>

              <t>Client validates the ID Token and retrieves the End-User's
              subject identifier.</t>

              <t>(OPTIONAL) Client accesses the UserInfo Endpoint with the Access Token,
	      per <xref target="userinfo"/>.</t>

              <t>(OPTIONAL) Client receives UserInfo Response.</t>
	      </list>Note that in each step, the party that receives a message
	      MUST validate it according to the validation rules in <xref
	      target="UserInfoResponseValidation"/>.</t>
	  </section>

	  <section anchor="implicit_flow" title="Implicit Flow">
	    <t>The Implicit Flow follows the following steps:</t>

	    <t><list style="numbers">
              <t>Client prepares an Authorization Request containing the desired
              request parameters.</t>

              <t>Client sends a request to the Authorization Server.</t>

              <t>Authorization Server Authenticates the End-User.</t>

              <t>Authorization Server Obtains the End-User
              Consent/Authorization.</t>

              <t>Authorization Server Sends the End-User back to the Client with
              an Access Token and an ID Token if requested.</t>

              <t>Client validates the ID Token and retrieves the End-User's
              subject identifier.</t>

              <t>(OPTIONAL) Client accesses the UserInfo Endpoint with the Access Token,
	      per <xref target="userinfo"/>.</t>

              <t>(OPTIONAL) Client receives UserInfo Response.</t>
	      </list>Note that in each step, the party that receives a message
	      MUST validate it according to the validation rules in <xref
	      target="UserInfoResponseValidation"/>.</t>
	  </section>

	</section>

        <section anchor="AuthorizationRequest" title="Authorization Request">
	  <t>When the Client wishes to access a Protected Resource and the
	  End-User Authorization has not yet been obtained, the Client
	  prepares an Authorization Request to the Authorization Endpoint.</t>

          <t>
            An Authorization Request is a message sent from an RP 
            to the OP's Authorization Endpoint. 
            It is an extended <xref target="RFC6749">OAuth 2.0</xref> 
            Authorization Request. 
            Section 4.1.1 and 4.2.1 of <xref target="RFC6749">OAuth 2.0</xref> 
            define the OAuth 2.0 Authorization Request parameters. 
          </t>

	  <t>
	    Communication with the Authorization Endpoint MUST utilize TLS.
	    See <xref target="TLS_requirements"/> for more information on using TLS.
	  </t>

	  <t>Authorization Servers MUST support the use of the HTTP <spanx style="verb">GET</spanx> and 
	  <spanx style="verb">POST</spanx> methods defined in <xref target="RFC2616">RFC 2616</xref> at the
	  Authorization Endpoint. </t>

	  <t>Clients MAY use the HTTP <spanx style="verb">GET</spanx> or
	  <spanx style="verb">POST</spanx> methods to send the
	  Authorization Request to the Authorization Server. If using the HTTP
	  <spanx style="verb">GET</spanx> method, the request parameters are serialized using
	  URI Query String Serialization, per <xref target="qss"/>.
	  If using the HTTP <spanx style="verb">POST</spanx>
	  method, the request parameters are serialized using 
	  Form Serialization, per <xref target="form_serialization"/>.</t>

	  <!-- TBD Move or Delete?  Seems redundant.
	  <t>
	    Clients MUST specify 
	    how the Access Token and ID Token are to be returned by using the
	    <spanx style="verb">response_type</spanx>
	    parameter in the Authorization Request.
	    The Authorization Response MAY contain an ID Token, Code, and/or Access Token,
	    depending on the <spanx style="verb">response_type</spanx> value used.
	  </t>
	   -->

          <section anchor="RequestParameters" title="Request Parameters">

            <t>
              OpenID Connect uses the following OAuth 2.0 request parameters:
	    </t>
	    <t>
              <list style="hanging">
                <t hangText="response_type">
		  REQUIRED.
		  OAuth 2.0 registered
		  response type value that determines how the Authorization Response
		  is returned to the Client.  As described in
		  <xref target="OAuth.Responses">OAuth 2.0 Multiple Response Type Encoding Practices</xref>,
		  the following registered values are supported by OpenID Connect:
		  <list style="symbols">
		    <t><spanx style="verb">code</spanx></t>

		    <t><spanx style="verb">code&nbsp;id_token</spanx></t>
		    
		    <t><spanx style="verb">id_token</spanx></t>

		    <t><spanx style="verb">id_token&nbsp;token</spanx></t>

		    <t><spanx style="verb">code&nbsp;token</spanx></t>

		    <t><spanx style="verb">code&nbsp;id_token&nbsp;token</spanx></t>
		  </list>
                </t>		<!-- Redundant? -->

                <t>
                  The OAuth 2.0 specification defines two response types:

                  <list style="hanging">
                    <t hangText="code">When supplied as the value for the
                    <spanx style="verb">response_type</spanx> parameter, a
                    successful response MUST include an Authorization Code as
                    defined in OAuth 2.0. Both successful
                    and error responses MUST be added as parameters to the
                    query component of the response.  All tokens are returned
                    from the Token Endpoint.
                    When used by OpenID Connect, an ID Token is also returned
                    from the Token Endpoint.
                    OpenID Providers that are not Self-Issued OPs MUST support
                    this <spanx style="verb">response_type</spanx>.</t>

                    <t hangText="token">When supplied as the value for the
                    <spanx style="verb">response_type</spanx> parameter, a
                    successful response MUST include an Access Token as
                    defined in OAuth 2.0.  Both successful
                    and error responses MUST be fragment-encoded.
                    No ID Token is provided to the Client;
                    therefore, this <spanx style="verb">response_type</spanx>
                    is not used by OpenID Connect.</t>
                  </list>
                </t>

                <t>OpenID Connect supports these <xref
                target="OAuth.Responses">additional response types</xref>,
                which have been registered with IANA:</t>

                <t>
                  <list style="hanging">
                    <t hangText="id_token">When supplied as the value
                    for the <spanx style="verb">response_type</spanx>
                    parameter, a successful response MUST include an ID Token.
                    Both successful and error responses SHOULD be fragment-encoded.
                    OpenID Providers MUST support this <spanx style="verb">response_type</spanx>.</t>

                    <t hangText="id_token&nbsp;token">When supplied as the value
                    for the <spanx style="verb">response_type</spanx>
                    parameter, a successful response MUST include both an
                    Access Token and an ID Token.
                    Both successful and error responses SHOULD be fragment-encoded.
                    OpenID Providers MUST support this <spanx style="verb">response_type</spanx>.</t>

                    <t hangText="code&nbsp;token">When supplied as the value for
                    the <spanx style="verb">response_type</spanx> parameter, a
                    successful response MUST include both an Access Token and
                    an Authorization Code as defined in OAuth 2.0.
                    When used by OpenID Connect, an ID Token is also returned
                    from the Token Endpoint.
                    Both successful and error responses SHOULD be fragment-encoded.</t>

                    <t hangText="code&nbsp;id_token">When supplied as the value for
                    the <spanx style="verb">response_type</spanx> parameter, a
                    successful response MUST include both an Authorization Code
                    and an ID Token.
                    Both successful and error responses SHOULD be fragment-encoded.</t>

                    <t hangText="code&nbsp;id_token&nbsp;token">When supplied as the
                    value for the <spanx style="verb">response_type</spanx>
                    parameter, a successful response MUST include an
                    Authorization Code, an ID Token, and an Access Token.
                    Both successful and error responses SHOULD be fragment-encoded.</t>
                  </list>
                </t>
                <t>
		  All OpenID Providers MUST support the
		  <spanx style="verb">id_token</spanx> response type and
		  all OpenID Providers that are not Self-Issued OPs MUST also support the
		  <spanx style="verb">id_token&nbsp;token</spanx> and
		  <spanx style="verb">code</spanx> response types.
		</t>		<!-- TBD Need to harmonize MTI -->
                <t>
		  The Client can use any OAuth 2.0 registered
		  response type supported by the OpenID Provider other than
		  <spanx style="verb">token</spanx> (which provides no ID Token).
		</t>

                <t hangText="client_id">
                  REQUIRED.
                  OAuth 2.0 Client Identifier.
                </t>

                <t hangText="scope">
                  REQUIRED.
                  Space delimited, case sensitive list of ASCII OAuth 2.0 scope values.
		  OpenID Connect requests MUST contain the <spanx style="verb">openid</spanx> scope value.
		  OPTIONAL scope values of
		  <spanx style="verb">profile</spanx>,
		  <spanx style="verb">email</spanx>,
		  <spanx style="verb">address</spanx>,
		  <spanx style="verb">phone</spanx>,
		  and <spanx style="verb">offline_access</spanx>
		  are also defined.
		  See <xref target="scopes"/> for more about the scope values defined by this specification.
                </t>

                <t hangText="redirect_uri">
                  REQUIRED.
		  Redirection URI to which the response will be sent.
		  This MUST be pre-registered with the OpenID Provider.
		  This URI MUST exactly match one of the
		  <spanx style="verb">redirect_uris</spanx> registered for the Client,
		  with the matching performed as described in
		  Section 6.2.1 of <xref target="RFC3986"/> (Simple String Comparison).
		  If the Client uses the OAuth implicit grant type, the redirection URI
		  MUST NOT use the <spanx style="verb">http</spanx> scheme
		  unless the Client is a native application, in which case it MAY
		  use the <spanx style="verb">http:</spanx> scheme with
		  <spanx style="verb">localhost</spanx> as the hostname.
		  If the Client only uses
		  the OAuth <spanx style="verb">authorization_code</spanx> grant type,
		  the redirection URI
		  MAY use the <spanx style="verb">http</spanx> scheme,
		  provided that the Client Type is
		  <spanx style="verb">confidential</spanx>,
		  as defined in Section 2.1 of OAuth 2.0.
                </t>

                <t hangText="state">
                  RECOMMENDED.
                  Opaque value used
                  to maintain state between the request and the callback.
		  Typically, Cross-Site Request Forgery (CSRF, XSRF)
		  mitigation is done by cryptographically binding the value of
		  this parameter with the browser cookie.
		</t>

              </list>
            </t>

            <t>
	      This specification also defines the following request parameters:
	    </t>

            <t>
              <list style="hanging">
                <t hangText="nonce">
                  REQUIRED or OPTIONAL.
		  String value used to associate a Client session 
		  with an ID Token, and to mitigate replay attacks.
		  The value is passed through unmodified from the Authorization Request to the ID Token.
		  Sufficient entropy MUST be present in the
		  <spanx style="verb">nonce</spanx> values used to prevent
		  attackers from guessing values.
		  One method to achieve this is to store a random value as a signed session cookie, and
		  pass the value in the <spanx style="verb">nonce</spanx> parameter.
		  In that case, the <spanx style="verb">nonce</spanx> in the returned ID Token
		  can be compared to the signed session cookie to detect ID Token replay by third 
		  parties.
                  Use of the nonce is REQUIRED for all requests where an ID Token
                  is returned directly from the Authorization Endpoint.  
                  It is OPTIONAL when the ID Token is returned from the 
                  Token Endpoint.
                </t>

                <t hangText="display">
                  OPTIONAL.
                  ASCII string value that specifies
                  how the Authorization Server displays the authentication and
                  consent user interface pages to the End-User.
		  The defined values are:

                  <list style="hanging">
                    <t hangText="page">The Authorization Server SHOULD display
                    authentication and consent UI consistent with a full User-Agent page
                    view. If the display parameter is not specified this is the
                    default display mode.</t>

                    <t hangText="popup">The Authorization Server SHOULD display
                    authentication and consent UI consistent with a popup User-Agent
                    window. The popup User-Agent window SHOULD be 450 pixels wide
                    and 500 pixels tall.</t>

                    <t hangText="touch">The Authorization Server SHOULD display
                    authentication and consent UI consistent with a device that
                    leverages a touch interface. The Authorization Server MAY attempt
                    to detect the touch device and further customize the interface.</t>

                    <t hangText="wap">The Authorization Server SHOULD display
                    authentication and consent UI consistent with a "feature phone"
                    type display.</t>
                  </list>
                </t>

                <t hangText="prompt">
                  OPTIONAL.
                  Space delimited, case sensitive list of ASCII string values
		  that specifies whether the Authorization Server prompts
		  the End-User for reauthentication and consent.
		  The defined values are:

                  <list style="hanging">
                    <t hangText="none">The Authorization Server
                    MUST NOT display any authentication or consent
                    user interface pages. An error is returned if the End-User 
                    is not already authenticated or the Client does not have 
                    pre-configured consent for the requested
                    Claims or does not fulfill other conditions for processing.
		    This can be used as a
                    method to check for existing authentication and/or consent.</t>

                    <t hangText="login">
		      The Authorization Server SHOULD prompt the
		      End-User for reauthentication.
		      If it cannot prompt the End-User, it MUST return an error.
		    </t>

                    <t hangText="consent">
		      The Authorization Server SHOULD prompt the End-User for consent
		      before returning information to the Client.
		    </t>

                    <t hangText="select_account">
		      The Authorization Server SHOULD
		      prompt the End-User to select a user account.  This allows 
		      an End-User who has multiple accounts at the Authorization Server
		      to select amongst the multiple accounts that they might have 
		      current sessions for.
		      If it cannot prompt the End-User, it MUST return an error.
		    </t>
                  </list>

                  The <spanx style="verb">prompt</spanx> parameter
                  can be used by the Client to make sure that the End-User is
                  still present for the current session or to bring attention to the
                  request. If this parameter contains <spanx style="verb">none</spanx>
                  with any other value, an
                  error is returned.
                </t>

                <t hangText="max_age">
                  OPTIONAL.
                  Maximum Authentication Age.
		  Specifies the allowable elapsed time in seconds
		  since the last time the End-User was actively
		  authenticated. If the elapsed time is greater than
		  this value, the OP MUST attempt to actively
		  re-authenticate the End-User.
                  (The <spanx style="verb">max_age</spanx> request parameter corresponds to
                  the OpenID 2.0 <xref target="OpenID.PAPE">PAPE</xref>
                  <spanx style="verb">max_auth_age</spanx> request parameter.)
                  When <spanx style="verb">max_age</spanx> is used, the ID Token returned
                  MUST include an <spanx style="verb">auth_time</spanx> Claim Value.
                </t>

                <t hangText="ui_locales">
                  OPTIONAL.
                  End-User's preferred languages and scripts for the user interface,
                  represented as a space-separated list of
                  <xref target="RFC5646">BCP47</xref> language tag values,
                  ordered by preference.
                  For instance, the value "fr-CA fr en" represents a preference
                  for French as spoken in Canada,
		  then French (without a region designation),
                  followed by English (without a region designation). 
                  An error SHOULD NOT result if some or all of the requested locales
                  are not supported by the OpenID Provider.
                </t>

                <t hangText="claims_locales">
                  OPTIONAL.
                  End-User's preferred languages and scripts for Claims being returned, 
                  represented as a space-separated list of
                  <xref target="RFC5646">BCP47</xref> language tag values,
                  ordered by preference.
                  An error SHOULD NOT result if some or all of the requested locales
                  are not supported by the OpenID Provider.
                </t>

                <t hangText="id_token_hint">
                  OPTIONAL.
                  Previously issued ID Token
                  passed to the Authorization Server as a hint about the End-User's current or past
                  authenticated session with the Client.
                  This SHOULD be present when <spanx style="verb">prompt=none</spanx> is used.
                  If the End-User identified by the ID Token is logged in or is logged in by the request,
                  then the Authorization Server returns a positive response;
                  otherwise, it SHOULD return a negative response.
		  The Authorization Server need not be listed as an
		  audience of the ID Token when it is used as an
		  <spanx style="verb">id_token_hint</spanx> value.
		</t>
		<t>
                  If the ID Token received by the RP is encrypted, the Client MUST
                  decrypt the signed ID Token contained within the encrypted ID Token.
                  The Client MAY re-encrypt the signed ID token to the Authentication Server
                  using a key that enables the server to decrypt the ID Token.
		</t>
		<t>
                  For a Self-Issued ID Token, the <spanx style="verb">sub</spanx> (subject) of the
                  signed ID Token MUST be sent as the <spanx style="verb">kid</spanx> (Key ID) of the JWE.
                </t>

                <t hangText="login_hint">
                  OPTIONAL.
                  Hint to the Authorization Server
                  about the login identifier the End-User might use to log in (if necessary).
                  This hint can be used by an RP if it first asks the End-User for their e-mail 
                  address (or other identifier) and then wants to pass that value as a hint
                  to the discovered authorization service.
                  It is RECOMMENDED that the hint value match the value used for discovery.
		  This value MAY also be a phone number in the format specified for the
		  <spanx style="verb">phone_number</spanx> Claim.
                  The use of this parameter is left to the OP's discretion.
                </t>

                <t hangText="acr_values">
                  OPTIONAL.
                  Requested Authentication Context Class Reference values. 
		  Space-separated string that specifies the <spanx style="verb">acr</spanx>
		  values that the Authorization Server is being requested to use 
		  for processing this authentication request,
		  with the values appearing in order of preference.
		  The Authentication Context Class satisfied by the authentication
		  performed is returned as the <spanx style="verb">acr</spanx> Claim Value,
		  as specified in <xref target="id_token"/>.
		  The <spanx style="verb">acr</spanx> Claim is requested as
		  a Voluntary Claim by this parameter.
                </t>

                <t hangText="claims">
                  OPTIONAL.
                  This parameter is used to request that specific Claims be returned.
                  The value is a JSON object listing the requested Claims,
		  as specified in <xref target="ClaimsRequest"/>.
                </t>

                <t hangText="registration">
                  OPTIONAL.
		  This parameter is used by the Client to provide information about itself
		  to a Self-Issued OP that would normally be provided to an OP during
		  Dynamic Client Registration,
		  as specified in <xref target="SelfIssuedRegistrationRequest"/>.
		  The <spanx style="verb">registration</spanx> parameter SHOULD NOT be used
		  when the OP is not a Self-Issued OP.
                </t>

                <t hangText="request">
                  OPTIONAL.
		  This parameter enables
		  OpenID Connect requests to be passed in a single,
		  self-contained parameter and to be signed and optionally encrypted.
		  The parameter value is a Request Object value,
		  as specified in <xref target="RequestObject"/>.
		  It represents the request as a JWT whose Claims are the request parameters
		  above.
		</t>
		<t>
		  When the <spanx style="verb">request</spanx> parameter is used,
		  the OpenID Connect request parameter values contained in the JWT
		  supersede those passed using the OAuth 2.0 request syntax.
		  Even if a <spanx style="verb">scope</spanx> parameter
		  is present in the Request Object value,
		  a <spanx style="verb">scope</spanx> parameter MUST always be passed using
		  the OAuth 2.0 request syntax containing the
		  <spanx style="verb">openid</spanx> scope value to indicate to the
		  underlying OAuth 2.0 logic that this is an OpenID Connect request.
                </t>

                <t hangText="request_uri">
                  OPTIONAL.
		  This parameter enables
		  OpenID Connect requests to be passed by reference, rather than by value.
		  The <spanx style="verb">request_uri</spanx> value is a URL
		  using the <spanx style="verb">https</spanx> scheme
		  referencing a resource containing a Request Object value,
		  which is a JWT containing the request parameters.
		  This parameter is used identically to the
		  <spanx style="verb">request</spanx> parameter, other than that
		  the Request Object value is retrieved from the specified URL,
		  rather than passed by value.
		  See <xref target="RequestUriParameter"/> for more information on using the
		  <spanx style="verb">request_uri</spanx> parameter.
                </t>
              </list>
            </t>

          </section>
        </section>

        <section anchor="Authenticates" title="Authorization Server Authenticates End-User">

          <t>
	    The Authorization Server validates the request to ensure all
	    REQUIRED parameters are present and all parameters are valid.
	    If the request is valid, the Authorization Server attempts
	    to log in the End-User or determines whether he is logged in,
	    depending upon the request parameter values used.
	    The methods used by the Authorization Server to log in the End-User
	    (e.g. username and password, session cookies, etc.)
	    are beyond the scope of this specification.
	    An authentication user interface MAY be displayed by
	    the Authorization Server, depending upon the request parameter values used
	    and the authentication methods used.
	  </t>

          <t>The Authorization Server MUST attempt to log in the 
          End-User in the following cases:
	    <list style="symbols">
	      <t>The End-User is not already logged in.</t>

	      <t>The Authorization Request contains the <spanx 
	      style="verb">prompt</spanx> parameter with the value
	      <spanx style="verb">login</spanx>.  In this case, the
	      Authorization Server MUST reauthenticate the End-User
	      even if the End-User is already authenticated.</t>
	    </list>
	  </t>
          <t>The Authorization Server MUST NOT interact with the End-User
          in the following case:
            <list style="symbols">
	      <t>The Authorization Request contains the <spanx 
	      style="verb">prompt</spanx> parameter with the value
	      <spanx style="verb">none</spanx>.  In this case,
	      the Authorization Server MUST return an error if the End-User
	      is not already logged in or could not be silently logged in.</t>
	    </list>
	  </t>

	  <t>
	    The Authorization Server MUST employ appropriate measures against
	    Cross-Site Request Forgery and Clickjacking as, described in
	    Sections 10.12 and 10.13 of <xref target="RFC6749">OAuth 2.0</xref>. 
	  </t>
        </section>

        <section anchor="Consent" title="Authorization Server Obtains End-User Consent/Authorization">

          <t>Once the End-User is authenticated, the Authorization Server MUST
          obtain an authorization decision. This MAY be done by presenting the
          End-User with a dialogue that allows the End-User to recognize what he is
          consenting to and obtain his consent or by establishing consent via
	  conditions for processing or
          other means (for example, via previous administrative consent).</t>

          <t>The Authorization Server MUST attempt to request authorization
          from the End-User in the following cases:
          <list style="symbols">
                <t>The End-User has not pre-authorized the Client for the
                Authorization Request.</t>

                <t>The Authorization Request contains the <spanx 
                style="verb">prompt</spanx> parameter with the value
		<spanx style="verb">consent</spanx>. The
                Authorization Server SHOULD request End-User authorization even if the
                End-User has previously authorized the Client.</t>
          </list></t>
          <t>The Authorization Server MUST NOT request End-User authorization in the
          following cases:
          <list style="symbols">
                <t>The Authorization Request contains the <spanx 
                style="verb">prompt</spanx> parameter with the value
		<spanx style="verb">none</spanx>.
                The Authorization Server MUST return an error if the End-User has
                not pre-authorized the Client.</t>
          </list></t>
	  
	  <t>
	    The Authorization Server MUST employ countermeasures against
	    Cross-Site Request Forgery and Clickjacking when interacting with the End-User.
	  </t>

        </section>

        <section anchor="AuthzResponse" title="Successful Authorization Response">

          <t>
	    Once the authorization is determined, the Authorization Server
	    returns a successful or error response.
	    This section describes the successful response.
	    <xref target="AuthError"/> describes the error response.
	  </t>

          <t>
	    An Authorization Response is a message returned from the 
	    OP's Authorization Endpoint in response to the Authorization Request 
	    by the RP.
	    Response parameters are returned to the Client by adding them to the
	    <spanx style="verb">redirect_uri</spanx> specified in the Authorization Request
	    using the "application/x-www-form-urlencoded" format.
	  </t>
	  <t>
	    Note that if the <spanx style="verb">response_type</spanx> parameter in the 
	    Authorization Request includes the string value 
	    <spanx style="verb">token</spanx> or <spanx style="verb">id_token</spanx>, 
	    all response parameters are added to the fragment component
	    of the redirection URI, as specified in
	    <xref target="OAuth.Responses">OAuth 2.0 Multiple Response Type Encoding Practices</xref>.
	    Otherwise, the response parameters 
	    are added to the query component of the redirection URI.
	  </t>

          <t>This specification only
          describes <xref target="RFC6750">OAuth 2.0 Bearer Token Usage</xref>. The
          OAuth 2.0 response parameter <spanx style="verb">token_type</spanx>
          MUST be set to <spanx style="verb">Bearer</spanx> unless another Token Type 
          has been negotiated with the Client.</t>

          <t>When the <spanx style="verb">response_type</spanx> in the request
          is <spanx style="verb">code</spanx>, the Authorization Response
	  MUST return the parameters defined in Section 4.1.2 of
          <xref target="RFC6749">OAuth 2.0</xref>.</t>

          <t>When the <spanx style="verb">response_type</spanx>
          includes other values, they MUST be returned as defined by
          their registration.  The
	  <spanx style="verb">id_token</spanx>,
	  <spanx style="verb">code&nbsp;id_token</spanx>,
	  <spanx style="verb">id_token&nbsp;token</spanx>,
	  <spanx style="verb">code&nbsp;token</spanx>,
	  and <spanx style="verb">code&nbsp;id_token&nbsp;token</spanx>
	  response types are defined in
          <xref target="OAuth.Responses">OAuth 2.0 Multiple Response Type Encoding Practices</xref>.</t>

          <section anchor="id_token" title="ID Token">

            <t>The ID Token is a security token that contains Claims about the
            authentication event and other requested Claims.  
            The ID Token is represented as a <xref target="JWT">JSON Web Token (JWT)</xref>.</t>

            <t>The ID Token is used to manage the authentication event and user
            identifier and is scoped to a particular Client via the <spanx
            style="verb">aud</spanx> (audience) and <spanx style="verb">nonce</spanx>
            Claims. </t>

            <t>The following Claims are used within the ID Token:</t>

            <t>
	      <list style="hanging">
                <t hangText="iss">
		  REQUIRED.
		  Issuer Identifier for the Issuer of the response.
		  The <spanx style="verb">iss</spanx> value is a case sensitive URL
		  using the <spanx style="verb">https</spanx> scheme that
		  contains scheme, host, and OPTIONALLY, port number and path
		  components and no query or fragment components.
		</t>

                <t hangText="sub">
		  REQUIRED.
		  Subject identifier.  A locally unique and never
		  reassigned identifier within the Issuer for the End-User, 
		  which is intended to be consumed by the Client,
		  e.g., <spanx style="verb">24400320</spanx>
		  or <spanx style="verb">AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4</spanx>.
		  It MUST NOT exceed 255 ASCII characters in length.
		  The <spanx style="verb">sub</spanx> value is a case sensitive string.
		</t>

                <t hangText="aud">
		  REQUIRED.
		  Audience(s) that this ID Token is intended for.
		  It MUST contain the OAuth 2.0 <spanx style="verb">client_id</spanx>
		  of the Relying Party as an audience value.
		  It MAY also contain identifiers for other audiences.
		  In the general case,
		  the <spanx style="verb">aud</spanx> value is an array of
		  case sensitive strings.
		  In the special case when there is one audience,
		  the <spanx style="verb">aud</spanx> value MAY be a single
		  case sensitive string.
		</t>

                <t hangText="exp">REQUIRED.
                Expiration time on or after which the ID Token MUST NOT be
                accepted for processing. The processing of this parameter
                requires that the current date/time MUST be before the
                expiration date/time listed in the value. Implementers MAY
                provide for some small leeway, usually no more than a few
                minutes, to account for clock skew.
		The time is represented as the number of seconds from
		1970-01-01T0:0:0Z as measured in UTC until the date/time.
		See <xref target="RFC3339">RFC 3339</xref>
                for details regarding date/times in general and UTC in
                particular.
		The <spanx style="verb">exp</spanx> value is a number.
		</t>
                
                <t hangText="iat">REQUIRED.
		Time at which the JWT was issued.
                The time is represented as the number of seconds from
		1970-01-01T0:0:0Z as measured in UTC until the date/time.
		The <spanx style="verb">iat</spanx> value is a number.
		</t>

                <t hangText="auth_time">
                  OPTIONAL or REQUIRED.
                  Time when the End-User authentication occurred.
		  The time is represented as the number of seconds from
		  1970-01-01T0:0:0Z as measured in UTC until the date/time.
                  When a <spanx style="verb">max_age</spanx> request is made
                  or when <spanx style="verb">auth_time</spanx> is requested
                  as an Essential Claim,
                  then this Claim is REQUIRED.
                  (The <spanx style="verb">auth_time</spanx> Claim semantically
                  corresponds to the OpenID 2.0 <xref target="OpenID.PAPE">PAPE</xref> 
                  <spanx style="verb">auth_time</spanx> response parameter.)
		  The <spanx style="verb">auth_time</spanx> value is a number.
                </t>

                <t hangText="nonce">
		  OPTIONAL or REQUIRED.
		  String value used to associate a Client session 
		  with an ID Token, and to mitigate replay attacks. 
		  The value is passed through unmodified from the Authorization Request to the ID Token.
		  If present in the ID Token,
		  Clients MUST verify that
		  the <spanx style="verb">nonce</spanx> Claim Value is equal to
		  the value of the <spanx style="verb">nonce</spanx>
		  parameter sent in the Authorization Request.
		  If present in the Authorization Request, Authorization Servers
		  MUST include a <spanx style="verb">nonce</spanx> Claim in the
		  ID Token with the Claim Value
		  being the nonce value sent in the Authorization Request.
		  Authorization Servers SHOULD perform no other processing
		  on <spanx style="verb">nonce</spanx> values used.
		  Use of the nonce is REQUIRED for all requests where an ID Token
		  is returned directly from the Authorization Endpoint.  
		  It is OPTIONAL when the ID Token is returned from the 
		  Token Endpoint.
		  The <spanx style="verb">nonce</spanx> value is a case sensitive string.
		</t>

                <t hangText="at_hash">
		  OPTIONAL or REQUIRED. 
		  Access Token hash value.
		  If the ID Token is issued from the Authorization Endpoint with an 
		  <spanx style="verb">access_token</spanx>, this is REQUIRED.
		  This is OPTIONAL when the ID Token is issued from the Token Endpoint.
		  Its value is the base64url encoding of the left-most half of the
		  hash of the octets of the ASCII representation of the
		  <spanx style="verb">access_token</spanx> value,
		  where the hash algorithm used is the hash algorithm
		  used in the <spanx style="verb">alg</spanx> parameter
		  of the ID Token's <xref target="JWS">JWS</xref> header.
		  For instance, if the <spanx style="verb">alg</spanx> is
		  <spanx style="verb">RS256</spanx>, hash the
		  <spanx style="verb">access_token</spanx> value
		  with SHA-256, then take the left-most 128 bits and base64url encode them.
		  The <spanx style="verb">at_hash</spanx> value is a case sensitive string.
		</t>

                <t hangText="c_hash">
		  Sometimes REQUIRED.
		  Code hash value.
		  If the ID Token is issued from the Authorization Endpoint with a 
		  <spanx style="verb">code</spanx>, this is REQUIRED.
		  Its value is the base64url encoding of the left-most half of the
		  hash of the octets of the ASCII representation of the
		  <spanx style="verb">code</spanx> value,
		  where the hash algorithm used is the hash algorithm
		  used in the <spanx style="verb">alg</spanx> parameter
		  of the ID Token's <xref target="JWS">JWS</xref> header.
		  For instance, if the <spanx style="verb">alg</spanx> is
		  <spanx style="verb">HS512</spanx>, hash the
		  <spanx style="verb">code</spanx> value
		  with SHA-512, then take the left-most 256 bits and base64url encode them.
		  The <spanx style="verb">c_hash</spanx> value is a case sensitive string.
		</t>

                <t hangText="acr">
		  OPTIONAL.
		  Authentication Context Class Reference.
		  String specifying an Authentication Context Class Reference value
		  that identifies the Authentication Context Class that the
		  authentication performed satisfied.
		  The value "0" indicates the End-User authentication
		  did not meet the requirements of
		  <xref target="ISO29115">ISO/IEC 29115</xref> level 1.
		  Authentication using a long-lived browser cookie, for instance, is one 
		  example where the use of "level 0" is appropriate. Authentications with 
		  level 0 SHOULD never be used to authorize access to any resource of any 
		  monetary value.  
		  (This corresponds to the OpenID 2.0
		  <xref target="OpenID.PAPE">PAPE</xref> 
		  <spanx style="verb">nist_auth_level</spanx> 0.)
		  An absolute URI or a <xref target="RFC6711">registered name</xref>
		  SHOULD be used as the <spanx style="verb">acr</spanx> value;
		  registered names MUST NOT be used with a different meaning than
		  that which is registered.
		  Parties using this claim will need to agree upon the meanings of
		  the values used, which may be context-specific.
		  The <spanx style="verb">acr</spanx> value is a case sensitive string.
                </t>

                <t hangText="amr">
		  OPTIONAL.
		  Authentication Methods References.
		  JSON array of strings that are identifiers for authentication methods
		  used in the authentication.
		  For instance, values might indicate that both password and OTP
		  authentication methods were used.
		  The definition of particular values to be used in the
		  <spanx style="verb">amr</spanx> Claim
		  is beyond the scope of this specification.
		  Parties using this claim will need to agree upon the meanings of
		  the values used, which may be context-specific.
		  The <spanx style="verb">amr</spanx> value is an array of
		  case sensitive strings.
		</t>

		<t hangText="azp">
		  OPTIONAL or REQUIRED.
		  Authorized Party - 
		  the party to which the ID Token was issued.
		  If present, it MUST contain the OAuth 2.0
		  <spanx style="verb">client_id</spanx> of the
		  party that will be using it.
		  This Claim is only REQUIRED when the party requesting the ID Token
		  is not the same as the sole audience of the ID Token.
		  It MAY be included even when the Authorized Party is the same
		  as the sole audience.
		  The <spanx style="verb">azp</spanx> value is a case sensitive string
		  containing a StringOrURI value.
		</t>

		<t hangText="sub_jwk">
		  NOT RECOMMENDED or REQUIRED.
		  Public key value used to check the signature of an ID Token
		  issued by a Self-Issued OpenID Provider,
		  as specified in <xref target="self_issued"/>.
		  The key is a bare key in JWK <xref target="JWK"/> format
		  (not an X.509 certificate value).
		  Use of the <spanx style="verb">sub_jwk</spanx> Claim
		  is REQUIRED when the OP is a Self-Issued OP and
		  is NOT RECOMMENDED when the OP is not Self-Issued.
		  The <spanx style="verb">iss</spanx> value is a JSON object.
		</t>

              </list>
	    </t>

	    <t>
	      ID Tokens MAY contain other Claims.
	      Any Claims used that are not understood MUST be ignored.
	    </t>

            <t>ID Tokens MUST be signed using <xref
            target="JWS">JWS</xref> and OPTIONALLY both signed and then
            encrypted using <xref target="JWS">JWS</xref> and <xref
            target="JWE">JWE</xref> respectively, thereby providing
            authentication, integrity,
	    non-repudiation, and optionally, confidentiality,
	    per <xref target="signing_order"/>.
	    ID Tokens MUST NOT use <spanx style="verb">none</spanx>
	    as the <spanx style="verb">alg</spanx> value.</t>
	    <t>
	      ID Tokens SHOULD NOT use the JWS or JWE
	      <spanx style="verb">x5u</spanx>,
	      <spanx style="verb">x5c</spanx>,
	      <spanx style="verb">jku</spanx>, or
	      <spanx style="verb">jwk</spanx>
	      header parameter fields.
	      Instead, key values and key references used for ID Tokens are
	      communicated in advance using Discovery and Registration parameters.
	    </t>
            <t>
              Clients MUST validate the ID Token per 
              <xref target="id.token.validation"/>. 
            </t>
            
	    <figure>
	      <preamble>The following is a non-normative example of a base64url decoded
	      ID Token:</preamble>

	      <artwork><![CDATA[
  {
   "iss": "https://server.example.com",
   "sub": "24400320",
   "aud": "s6BhdRkqt3",
   "nonce": "n-0S6_WzA2Mj",
   "exp": 1311281970,
   "iat": 1311280970,
   "auth_time": 1311280969,
   "acr": "urn:mace:incommon:iap:silver",
   "at_hash": "MTIzNDU2Nzg5MDEyMzQ1Ng"
  }
]]></artwork>
	    </figure>
	  </section>

	</section>

	<section anchor="AuthError" title="Authorization Error Response">
	  <t>If the End-User denies the access request or if the request
	  fails, the OP (Authorization Server) informs the RP (Client)
	  by using the Error Response parameters defined in
	  Sections 4.1.2.1 or 4.2.2.1 of <xref target="RFC6749">OAuth 2.0</xref>,
	  according to the <spanx style="verb">response_type</spanx> used.</t>
	  <t>
	    The Authorization Server returns the Client to
            the redirection URI specified in the Authorization Request
            with the appropriate error parameters. No
            other parameters SHOULD be returned.
	  </t>
	  <t>In addition to the error codes defined in Sections 4.1.2.1 and 4.2.2.1 of
	  OAuth 2.0, this specification also defines the following error codes:</t>

	  <t>
	    <list style="hanging">

	      <t hangText="interaction_required">The Authorization Server
	      requires End-User interaction of some form to proceed.
	      This error MAY be returned when the 
	      <spanx style="verb">prompt</spanx> parameter in the
	      Authorization Request is set to <spanx style="verb">none</spanx>
	      to request that the
	      Authorization Server SHOULD NOT display any user interfaces to
	      the End-User, but the Authorization Request cannot be completed
	      without displaying a user interface for End-User interaction.</t>

	      <t hangText="login_required">The Authorization Server requires
	      End-User authentication. This error MAY be returned when the 
	      <spanx style="verb">prompt</spanx> parameter in the
	      Authorization Request is set to
	      <spanx style="verb">none</spanx> to request that the
	      Authorization Server SHOULD NOT display any user interfaces to
	      the End-User, but the Authorization Request cannot be completed
	      without displaying a user interface for user authentication.
	      </t>

	      <t hangText="session_selection_required">The End-User is REQUIRED
	      to select a session at the Authorization Server. The End-User MAY
	      be authenticated at the Authorization Server with different
	      associated accounts, but the End-User did not select a session.
	      This error MAY be returned 
	      when the <spanx style="verb">prompt</spanx> parameter in the
	      Authorization Request is set to <spanx style="verb">none</spanx>
	      to request that the
	      Authorization Server SHOULD NOT display any user interfaces to
	      the End-User, but the Authorization Request cannot be completed
	      without displaying a user interface to prompt for a session to
	      use.</t>

	      <t hangText="consent_required">The Authorization Server
	      requires End-User consent. This error MAY be returned when the 
	      <spanx style="verb">prompt</spanx> parameter in the
	      Authorization Request is set to <spanx style="verb">none</spanx>
	      to request that the
	      Authorization Server SHOULD NOT display any user interfaces to
	      the End-User, but the Authorization Request cannot be completed
	      without displaying a user interface for End-User consent.</t>

	      <t hangText="invalid_request_uri">The 
	      <spanx style="verb">request_uri</spanx> in
	      the Authorization Request returns an error or contains invalid data.</t>

	      <t hangText="invalid_request_object">The 
	      <spanx style="verb">request</spanx> parameter contains an invalid 
	      Request Object.</t>

	      <t hangText="registration_not_supported">
		The OP does not support use of the
		<spanx style="verb">registration</spanx> parameter.
	      </t>

	      <t hangText="request_not_supported">
		The OP does not support use of the
		<spanx style="verb">request</spanx> parameter.
	      </t>

	      <t hangText="request_uri_not_supported">
		The OP does not support use of the
		<spanx style="verb">request_uri</spanx> parameter.
	      </t>

	    </list>
	  </t>

	  <t>
	    The error response parameters are the following:

	    <list style="hanging">
	      <t hangText="error">REQUIRED. Error code.</t>

	      <t hangText="error_description">OPTIONAL. Human-readable ASCII
	      encoded text description of the error.</t>

	      <t hangText="error_uri">OPTIONAL. URI of a web page that
	      includes additional information about the error.</t>

	      <t hangText="state">
		OAuth 2.0 state value.
		REQUIRED if the Authorization Request
		included the <spanx style="verb">state</spanx> parameter. Set
	      to the value received from the Client.</t>
	    </list>
	  </t>

	  <t>If the <spanx style="verb">response_type</spanx> parameter in the
	  Authorization Request includes the string value
	  <spanx style="verb">token</spanx> or <spanx style="verb">id_token</spanx>,
	  all error response parameters are be added to the 
	  fragment component of the redirection URI, as specified in
	  <xref target="OAuth.Responses">OAuth 2.0 Multiple Response Type Encoding Practices</xref>.
	  Otherwise, the response
	  parameters are added to the query component of the redirection URI.
	  </t>

	  <t>
	    <figure>
	      <preamble>The following is a non-normative example
	      response
	      (with line wraps within values for the display purposes only):</preamble>

	      <artwork><![CDATA[
  HTTP/1.1 302 Found
  Location: https://client.example.org/cb?
    error=invalid_request
    &error_description=
      the%20request%20is%20not%20valid%20or%20malformed
    &state=af0ifjsldkj
]]></artwork>
	    </figure>
	  </t>
	</section>
      </section>

      <section anchor="token_ep" title="Token Endpoint">
	<t>
	  When using the Authorization Code Flow,
	  the RP (Client) sends an Access Token Request to the Token Endpoint
	  to obtain an Access Token Response,
	  which MAY include an Access Token, a Refresh Token,
	  an ID Token, and other results.
	</t>

	<t>
	  Clients MUST use the HTTP <spanx style="verb">POST</spanx> method
	  to make requests to the Token Endpoint.
	  Request parameters are added using
	  Form Serialization, per <xref target="form_serialization"/>.
	  The Token Endpoint MUST support the use of the HTTP <spanx style="verb">POST</spanx>
	  method defined in <xref target="RFC2616">RFC 2616</xref> at the
	  Token Endpoint.
	</t>
	<t>
	  Communication with the Token Endpoint MUST utilize TLS.
	  See <xref target="TLS_requirements"/> for more information on using TLS.
	</t>

	<t>
	  All Token Endpoint responses that contain tokens, secrets, or other
	  sensitive information MUST include the following HTTP response header
	  fields and values:
	</t>

	<texttable title="HTTP Response Headers and Values">
	  <ttcol>Header Name</ttcol>

	  <ttcol>Header Value</ttcol>

	  <c>Cache-Control</c>

	  <c>no-store</c>

	  <c>Pragma</c>

	  <c>no-cache</c>
	</texttable>

	<section anchor="client_authentication" title="Client Authentication">

	  <t>
	    Clients MAY provide authentication parameters in the request to the
	    Token Endpoint, as described in this section.
	  </t>

	  <t>During Client Registration, the RP (Client) MAY register an authentication method.
	  If no method is registered, the default method of <spanx style="verb">client_secret_basic</spanx> MUST be used.</t>
	  <t>The Supported options are:</t>

	  <t><list style="hanging">

	    <t hangText="client_secret_basic"> 
	      Clients that have received a <spanx style='verb'>client_secret</spanx> value
	      from the Authorization Server, authenticate with the Authorization Server
	      in accordance with Section 3.2.1 of <xref
	      target="RFC6749">OAuth 2.0</xref> using HTTP Basic authentication scheme. </t>

	      <t hangText="client_secret_post">
		Clients that have received a <spanx style='verb'>client_secret</spanx> value 
		from the Authorization Server, authenticate with the Authorization Server
		in accordance with Section 3.2.1 of <xref
		target="RFC6749">OAuth 2.0</xref> by including the Client Credentials in the request body. </t>

		<t hangText="client_secret_jwt"> 
		  Clients that have received a <spanx style='verb'>client_secret</spanx> value 
		  from the Authorization Server create a JWT using an
		  HMAC SHA algorithm, such as HMAC SHA-256. 
		  The HMAC (Hash-based Message Authentication Code) is calculated using
		  the octets of the UTF-8 representation of
		  the <spanx style='verb'>client_secret</spanx> as the shared key.
		</t>
		<t>
		  The Client authenticates in accordance with Section 2.2 of <xref
		  target="OAuth.JWT">OAuth JWT Bearer Token Profiles</xref> and 
		  <xref target="OAuth.Assertions">OAuth 2.0 Assertion Profile</xref>.
		  The JWT MUST contain the following REQUIRED Claim Values and
		MAY contain the following OPTIONAL Claim Values:</t>

		<t><list style="hanging">
		  <t hangText="iss">REQUIRED.
		  Issuer.
		  This MUST contain the <spanx style="verb">client_id</spanx> of the OAuth Client.</t>

		  <t hangText="sub">REQUIRED.
		  Subject.
		  This MUST contain the <spanx style="verb">client_id</spanx> of the OAuth Client.</t>

		  <t hangText="aud">
		    REQUIRED.
		    Audience.
		    The <spanx style="verb">aud</spanx> (audience) Claim.
		    Value that identifies the Authorization Server as an intended audience.
		    The Authorization Server MUST verify that it is an intended audience
		    for the token.
		    The Audience SHOULD be the URL of the
		    Authorization Server's Token Endpoint.
		  </t>

		  <t hangText="jti">REQUIRED.
		  JWT ID.
		  A unique identifier for the token.  The
		  JWT ID MAY be used by implementations requiring message
		  de-duplication for one-time use assertions. </t>

		  <t hangText="exp">REQUIRED.
		  Expiration time on or after which the ID Token MUST NOT be
		  accepted for processing.</t>

		  <t hangText="iat">OPTIONAL.
		  Time at which the JWT was issued.
		  </t>
		</list></t>

		<t>
		  ID Tokens MAY contain other Claims.
		  Any Claims used that are not understood MUST be ignored.
		</t>

		<t>The authentication token MUST be sent as the value of the
		<xref target="OAuth.Assertions"/>
		<spanx style='verb'>client_assertion</spanx> parameter.</t>

		<t>The value of the
		<xref target="OAuth.Assertions"/>
		<spanx style='verb'>client_assertion_type</spanx> parameter
		MUST be "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
		per <xref target="OAuth.JWT"/>.</t>

		<t hangText="private_key_jwt">
		  Clients that have registered a public key sign a JWT using 
		  that key.
		  The Client authenticates in accordance with Section 2.2 of <xref
		  target="OAuth.JWT">OAuth JWT Bearer Token Profiles</xref> and 
		  <xref target="OAuth.Assertions">OAuth 2.0 Assertion Profile</xref>.
		  The JWT MUST contain the following REQUIRED Claim Values and
		MAY contain the following OPTIONAL Claim Values:</t>

		<t><list style="hanging">
		  <t hangText="iss">REQUIRED.
		  Issuer.
		  This MUST contain the <spanx style="verb">client_id</spanx> of the OAuth Client.</t>

		  <t hangText="sub">REQUIRED.
		  Subject.
		  This MUST contain the <spanx style="verb">client_id</spanx> of the OAuth Client.</t>

		  <t hangText="aud">
		    REQUIRED.
		    Audience.
		    The <spanx style="verb">aud</spanx> (audience) Claim.
		    Value that identifies the Authorization Server as an intended audience.
		    The Authorization Server MUST verify that it is an intended audience
		    for the token.
		    The Audience SHOULD be the URL of the
		    Authorization Server's Token Endpoint.
		  </t>

		  <t hangText="jti">REQUIRED.
		  JWT ID.
		  A unique identifier for the token.  The
		  JWT ID MAY be used by implementations requiring message
		  de-duplication for one-time use assertions. </t>

		  <t hangText="exp">REQUIRED.
		  Expiration time on or after which the ID Token MUST NOT be
		  accepted for processing.</t>

		  <t hangText="iat">OPTIONAL.
		  Time at which the JWT was issued.
		  </t>
		</list></t>

		<t>
		  The JWT MAY contain other Claims.
		  Any Claims used that are not understood MUST be ignored.
		</t>

		<t>The authentication token MUST be sent as the value of the
		<xref target="OAuth.Assertions"/>
		<spanx style='verb'>client_assertion</spanx> parameter.</t>

		<t>The value of the
		<xref target="OAuth.Assertions"/>
		<spanx style='verb'>client_assertion_type</spanx> parameter
		MUST be "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
		per <xref target="OAuth.JWT"/>.</t>

		<t>
		  <figure>
		    <preamble>
		      For example
		      (with line wraps within values for display purposes only):
		    </preamble>
		    <artwork><![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  grant_type=authorization_code&
    code=i1WsRn1uB1&
    client_id=s6BhdRkqt3&
    client_assertion_type=
    urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer&
    client_assertion=PHNhbWxwOl ... ZT
]]></artwork>
		</figure>
	      </t>
	    </list>
	  </t>

	</section>

	<section anchor="access_token_request" title="Access Token Request">

	  <t>
	    A Client using the Authorization Code Flow
	    obtains an Access Token by authenticating with the
	    Authorization Server and presenting its Authorization Grant (in the form of
	    an Authorization Code or Refresh Token) to the Token Endpoint.
	  </t>

	  <t>In addition to the Client authentication parameters,
	  if this is a Refresh Token Request, the Client MUST send the additional parameters 
	  specified in Section 6 of <xref target="RFC6749">OAuth 2.0</xref>.
	  Otherwise, the Client
	  MUST send the request parameters as
	  specified in Section 4.1.3 of <xref target="RFC6749">OAuth 2.0</xref>.</t>

          <t>To obtain an Access Token, Refresh Token or ID Token, the Client MUST
          authenticate to the Token Endpoint using the authentication method
	  registered for its <spanx style="verb">client_id</spanx>,
	  as described in <xref target="client_authentication"/>.
          The Client sends the parameters via HTTPS <spanx style="verb">POST</spanx> to the Token Endpoint using
          Form Serialization, per <xref target="form_serialization"/>,
	  as described in Section 4.1.3 of 
          <xref target="RFC6749">OAuth 2.0</xref>.</t>

          <figure>
            <preamble>The following is a non-normative example of an Access Token Request:</preamble>

            <artwork><![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded
  Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW

  grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
]]></artwork>
          </figure>
          <t>
            The Authorization Server MUST:
          </t>
          <t>
            <list style='symbols'>
              <t>
                Authenticate any Clients that were issued Client Credentials
		(or for which other Client Authentication methods can be used),
              </t>
              <t>
                Ensure the
                Authorization Code was issued to the authenticated Client,
              </t>
              <t>
                Verify that the Authorization Code is valid, and
              </t>
              <t>
                Ensure that the
		Scheme, Host, Path, and Query Parameter segments
		in the <spanx style='verb'>redirect_uri</spanx> parameter
		are identical to the <spanx style='verb'>redirect_uri</spanx>
		parameter value that was included in the initial Authorization Request.
		If the <spanx style='verb'>redirect_uri</spanx> parameter value
		not be present when there is only one registered
		<spanx style='verb'>redirect_uri</spanx> value,
		the Authorization Server MAY return an error
		(since the Client should have included the parameter)
		or MAY proceed without an error
		(since OAuth 2.0 permits the parameter to be omitted in this case).
              </t>
            </list>
          </t>

	</section>

	<section anchor="access_token_response" title="Access Token Response">
          <t>Upon receipt of the Token Request, the Authorization Server MUST
          return either a successful response or an error response that corresponds to
          the received Authorization Code.</t>

	  <t>After receiving and validating a valid and authorized Access Token Request
	  from the Client, the Authorization Server returns a successful
	  response that includes an Access Token and an ID Token.  The
	  parameters in the successful response are defined in Section 4.1.4
	  of <xref target="RFC6749">OAuth 2.0</xref>.</t>

	  <t>This specification only
	  describes <xref target="RFC6750">OAuth 2.0 Bearer Token Usage</xref>. The
	  OAuth 2.0 response parameter <spanx style="verb">token_type</spanx>
	  MUST be set to <spanx style="verb">Bearer</spanx> unless another Token Type 
	  has been negotiated with the Client. Servers SHOULD support 
	  <xref target="RFC6750">OAuth 2.0 Bearer Token Usage</xref> for interoperability.
	  For security reasons Servers MAY only allow Clients to register specific 
	  <spanx style="verb">token_type</spanx>. Clients MUST support 
	  <xref target="RFC6750">OAuth 2.0 Bearer Token Usage</xref> and MAY support other
	  <spanx style="verb">token_type</spanx>. </t>

	  <t>In addition to the OAuth 2.0 response parameters, the following
	  parameters MUST be included in the response if the 
	  <spanx style="verb">grant_type</spanx> value is 
	  <spanx style="verb">authorization_code</spanx>
	  and the Authorization Request <spanx style="verb">scope</spanx> parameter 
	  contained <spanx style="verb">openid</spanx>:</t>

	  <t><list style="hanging">
	    <t hangText="id_token">ID Token value associated with the
	    authenticated session.</t>
	  </list></t>

	  <t>
	    An <spanx style="verb">id_token</spanx> MUST be 
	    returned when the <spanx style="verb">grant_type</spanx> value is
	    <spanx style="verb">authorization_code</spanx>
	    and MAY be returned when other grant types are used.
	  </t>

	  <t>A successful response returns the <spanx style="verb">application/json</spanx>
	  media type.</t>

	  <figure>
	    <preamble>The following is a non-normative example of a token request:</preamble>

	    <artwork><![CDATA[
  {
   "access_token": "SlAV32hkKG",
   "token_type": "Bearer",
   "refresh_token": "8xLOxBtZp8",
   "expires_in": 3600,
   "id_token": "eyJ0 ... NiJ9.eyJ1c ... I6IjIifX0.DeWt4Qu ... ZXso"
  }
]]></artwork>
	  </figure>

	  <figure>
	    <preamble>The following is a non-normative example of a
	    successful token response:</preamble>

	    <artwork><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json
  Cache-Control: no-store
  Pragma: no-cache

  {
   "access_token": "SlAV32hkKG",
   "token_type": "Bearer",
   "refresh_token": "8xLOxBtZp8",
   "expires_in": 3600,
   "id_token": "eyJhbGciOiJSUzI1NiJ9.ew0KICAgICJpc3MiOiAiaHR0cDovL
     3NlcnZlci5leGFtcGxlLmNvbSIsDQogICAgInVzZXJfaWQiOiAiMjQ4Mjg5NzYxM
     DAxIiwNCiAgICAiYXVkIjogInM2QmhkUmtxdDMiLA0KICAgICJub25jZSI6ICJuL
     TBTNl9XekEyTWoiLA0KICAgICJleHAiOiAxMzExMjgxOTcwLA0KICAgICJpYXQiO
     iAxMzExMjgwOTcwDQp9.lsQI_KNHpl58YY24G9tUHXr3Yp7OKYnEaVpRL0KI4szT
     D6GXpZcgxIpkOCcajyDiIv62R9rBWASV191Akk1BM36gUMm8H5s8xyxNdRfBViCa
     xTqHA7X_vV3U-tSWl6McR5qaSJaNQBpg1oGPjZdPG7zWCG-yEJC4-Fbx2FPOS7-h
     5V0k33O5Okd-OoDUKoFPMd6ur5cIwsNyBazcsHdFHqWlCby5nl_HZdW-PHq0gjzy
     JydB5eYIvOfOHYBRVML9fKwdOLM2xVxJsPwvy3BqlVKc593p2WwItIg52ILWrc6A
     tqkqHxKsAXLVyAoVInYkl_NDBkCqYe2KgNJFzfEC8g"
  }
]]></artwork>
	  </figure>

	  <t>As in the <xref target="RFC6749">OAuth 2.0</xref>, Clients
	  SHOULD ignore unrecognized response parameters.</t>

	  <t>
	    If an ID Token is returned as a result of a token refresh request,
	    the following requirements apply:
	    <list style="symbols">
	      <t>
		its <spanx style="verb">iss</spanx> Claim value MUST be the same as
		in the ID Token issued when the original authentication occurred,
	      </t>
	      <t>
		its <spanx style="verb">sub</spanx> Claim value MUST be the same as
		in the ID Token issued when the original authentication occurred,
	      </t>
	      <t>
		its <spanx style="verb">iat</spanx> Claim MUST represent
		the time that the new ID Token is issued,
	      </t>
	      <t>
		its <spanx style="verb">aud</spanx> Claim value MUST be the same as
		in the ID Token issued when the original authentication occurred,
	      </t>
	      <t>
		if the ID Token contains an <spanx style="verb">auth_time</spanx> Claim,
		its value MUST represent the time of the original authentication - not
		the time that the new ID token is issued,
	      </t>
	      <t>
		its <spanx style="verb">azp</spanx> Claim value MUST be the same as
		in the ID Token issued when the original authentication occurred;
		if no <spanx style="verb">azp</spanx> Claim was present in the original
		ID Token, one MUST NOT be present in the new ID Token, and
	      </t>
	      <t>
		otherwise, the same rules apply as apply when issuing an ID Token
		at the time of the original authentication.
	      </t>
	    </list>
	  </t>
	</section>

	<section anchor="TokenErrorResponse" title="Access Token Error Response">
	  <t>
	    If the Token Request is invalid or unauthorized, the
	    Authorization Server constructs the error response. The parameters
	    of the Token Error Response are defined as in Section 5.2 of <xref
	    target="RFC6749">OAuth 2.0</xref>.
	    The HTTP response body uses the <spanx style="verb">application/json</spanx>
	    media type with HTTP response code of 400.
	  </t>

	  <figure>
	    <preamble>The following is a non-normative example token error response:</preamble>

	    <artwork><![CDATA[
  HTTP/1.1 400 Bad Request
  Content-Type: application/json
  Cache-Control: no-store
  Pragma: no-cache

  {
   "error": "invalid_request"
  }
]]></artwork>
	  </figure>
	</section>
      </section>

      <section anchor="RefreshingAccessToken" title="Refreshing Access Token">
         <t>To refresh an Access Token, the Client MUST
          authenticate to the Token Endpoint using the authentication method registered
	  for its <spanx style="verb">client_id</spanx>, as documented in
	  <xref target="client_authentication"/>.
	  The Client sends the parameters via HTTPS <spanx style="verb">POST</spanx> to the Token Endpoint using
          Form Serialization, per <xref target="form_serialization"/>,
	  as described in Section 6 of 
          <xref target="RFC6749">OAuth 2.0</xref>:</t>
        
        <t>The Authorization Server MUST validate the Refresh Token.
        </t>

        <section anchor="RefreshTokenResponse" title="Refresh Token Response">
          <t>Upon receipt of the Refresh Token Request, the Authorization Server MUST
          return either a successful response or an error response that corresponds to
          the received Refresh Token.</t>

          <t>Upon successful validation of the Refresh Token, a successful
          response returns the <spanx style="verb">application/json</spanx>
          media type and the response body is the Access Token Response of 
          <xref target="access_token_response"/>
	  except that it MUST NOT return an <spanx style="verb">id_token</spanx>.</t>
        
          <figure>
            <preamble>The following is a non-normative example of a
	    Refresh Token Request and Response:</preamble>

            <artwork><![CDATA[
  POST /token HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  client_id=s6BhdRkqt3
    &client_secret=some_secret12345
    &grant_type=refresh_token
    &refresh_token=8xLOxBtZp8
    &scope=openid%20profile

  HTTP/1.1 200 OK
  Content-Type: application/json
  Cache-Control: no-store
  Pragma: no-cache

  {
   "access_token": "TlBN45jURg",
   "token_type": "Bearer",
   "refresh_token": "9yNOxJtZa5",
   "expires_in": 3600
  }
]]></artwork>
          </figure>
        </section>

	<section anchor="RefreshTokenErrorResponse" title="Refresh Token Error Response">
	  <t>If the Refresh Token Request is invalid or unauthorized, the
	  Authorization Server returns the 
	  Token Error Response as defined in Section 5.2 of <xref
	  target="RFC6749">OAuth 2.0</xref>.</t>
	</section>
      </section>

      <section anchor="userinfo" title="UserInfo Endpoint">

	<t>
	  The UserInfo Endpoint is an OAuth 2.0 Protected Resource that
	  returns Claims about the authenticated End-User.
	  To obtain the requested Claims about the End-User, the Client
	  makes a <spanx style="verb">GET</spanx> or
	  <spanx style="verb">POST</spanx> request to the UserInfo Endpoint.
	  These Claims are represented by a JSON object that contains
	  a collection of name and value pairs for the Claims.
	</t>
	<t>
	  Communication with the UserInfo Endpoint MUST utilize TLS.
	  See <xref target="TLS_requirements"/> for more information on using TLS.
	</t>

	<t>The UserInfo Endpoint MUST support the use of the HTTP <spanx style="verb">GET</spanx> and HTTP
	<spanx style="verb">POST</spanx> methods defined in <xref target="RFC2616">RFC 2616</xref> at the
	UserInfo Endpoint. </t>

	<t>The UserInfo Endpoint MUST accept Access Tokens as
	<xref target="RFC6750">OAuth 2.0 Bearer Token Usage</xref>.</t>
	
	<t>The UserInfo Endpoint SHOULD support the use of 
	<xref target="CORS">Cross Origin Resource Sharing (CORS)</xref> and
	or other methods as appropriate to enable Java Script Clients to access the endpoint.</t>

	<section anchor="UserInfoRequest" title="UserInfo Request">
	  <t>
	    Clients send requests with the following parameters to the
	    UserInfo Endpoint to obtain Claims about the End-User:
	  </t>

	  <t>
	    <list style="hanging">
	      <t hangText="access_token">REQUIRED.
	      Access Token obtained
	      from an OpenID Connect Authorization Request. </t>
	    </list>
	  </t>

	  <t>
	    The Client sends the UserInfo Request using either
	    HTTPS <spanx style="verb">GET</spanx> or HTTPS <spanx style="verb">POST</spanx>.
	    It is RECOMMENDED that the Client use the
	    <spanx style="verb">Authorization</spanx> header field
	    method for all requests and that they use the <spanx style="verb">GET</spanx> method.
	  </t>

	  <t>The Access Token obtained
	  from an OpenID Connect Authorization Request MUST be sent as a Bearer Token.
	  Section 2 of the <xref target="RFC6750">OAuth 2.0 Bearer Token Usage</xref>
	  specification documents the permissible methods of sending the Access Token.</t> 

	  <figure>
	    <preamble>
	      The following is a non-normative example of a UserInfo request:
	    </preamble>

	    <artwork><![CDATA[
  GET /userinfo HTTP/1.1
  Host: server.example.com
  Authorization: Bearer SlAV32hkKG
]]></artwork>
	  </figure>
	</section>

	<section anchor="UserInfoResponse" title="UserInfo Response">
	  <t>
	    The UserInfo Claims MUST be returned as the members of a JSON object
	    unless a signed or encrypted response was requested during Client Registration.
	    The Claims defined in <xref target="StandardClaims"/> can be returned,
	    as can additional Claims not specified there.
	  </t>
	  <t>
	    If a Claim is not returned, that Claim Name SHOULD be
	    omitted from the JSON object representing the Claims; it
	    SHOULD NOT be present with a null or empty string value.
	  </t>
	  <t>
	    The <spanx style="verb">sub</spanx> (subject) Claim
	    MUST always be returned in the UserInfo Response.
	  </t>
	  <t>
	    NOTE: The UserInfo Endpoint response is not guaranteed to be about the
	    End-User identified by the <spanx style="verb">sub</spanx> (subject)
	    element of the ID Token.
	    The <spanx style="verb">sub</spanx> Claim in the UserInfo Endpoint response
	    MUST be verified to exactly match the
	    <spanx style="verb">sub</spanx> Claim in the ID Token
	    before using additional UserInfo Endpoint Claims.
	  </t>
	  <t>
	    Upon receipt of the UserInfo request, the UserInfo Endpoint MUST
	    return the JSON Serialization of the UserInfo response as in
	    <xref target="js"/> in the HTTP response
	    body unless a
	    different format was specified during Registration
	    <xref target="OpenID.Registration"/>.
	    The content-type of the HTTP response MUST be set to <spanx
	    style="verb">application/json</spanx> if the response body is a text
	    JSON structure;
	    the response body SHOULD be encoded using UTF-8.
	    If the JSON response is
	    signed or encrypted, then the
	    content-type MUST be set to <spanx style="verb">application/jwt</spanx>.
	  </t>
	  <t>
	    Upon receipt of the UserInfo Response, the Client MUST verify 
	    the response in accordance with
	    <xref target="UserInfoResponseValidation"/>.
	  </t>

	  <figure>
	    <preamble>The following is a non-normative example
	    of a UserInfo Response:</preamble>

	    <artwork><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json

  {
   "sub": "248289761001",
   "name": "Jane Doe",
   "given_name": "Jane",
   "family_name": "Doe",
   "email": "janedoe@example.com",
   "picture": "http://example.com/janedoe/me.jpg"
  }
]]></artwork>
	  </figure>
	</section>

	<section anchor="UserInfoError" title="UserInfo Error Response">

	  <t>
	    When an error condition occurs, the UserInfo Endpoint returns
	    an Error Response as defined in Section 3 of
	    <xref target="RFC6750">OAuth 2.0 Bearer Token Usage</xref>.
	  </t>

	  <figure>
	    <preamble>The following is a non-normative example
	    of a UserInfo Error Response:</preamble>

	    <artwork><![CDATA[
  HTTP/1.1 401 Unauthorized
  WWW-Authenticate: Bearer realm="example.com",
                       error="invalid_token",
                       error_description="The Access Token expired"
]]></artwork>
	  </figure>
	</section>
      </section>

      <section title="Scope Values" anchor="scopes">
	<t>OpenID Connect Clients use <spanx style="verb">scope</spanx> values as defined in 3.3 of 
	<xref target="RFC6749">OAuth 2.0</xref> to specify what
	access privileges are being requested for Access Tokens. The scopes associated
	with Access Tokens determine what resources will be available when they are 
	used to access OAuth 2.0 protected endpoints. For OpenID Connect, scopes
	can be used to request that specific sets of information
	be made available as Claim Values.
	This specification describes only the scope values used by OpenID Connect.</t>
	<t>
	  OpenID Connect allows additional scope values to be defined and used.
	  Scope values used that are not understood by an implementation SHOULD be ignored.
	</t>
	<t>
	  Claims requested by the following scopes are treated by Authorization Servers
	  as Voluntary Claims.
	</t>

	<t>OpenID Connect defines the following <spanx style="verb">scope</spanx> values:</t>
	<t>
	  <list style="hanging">
	    <t hangText="openid">REQUIRED. Informs the Authorization Server
	    that the Client is making an OpenID Connect request. If the
	    <spanx style="verb">openid</spanx> scope value is not present,
	    the behavior is entirely unspecified.
	    </t>

	    <t hangText="profile">OPTIONAL. This scope value 
	    requests access to the End-User's default profile Claims,
	    which are:

	    <spanx style="verb">name</spanx>,
	    <spanx style="verb">family_name</spanx>,
	    <spanx style="verb">given_name</spanx>,
	    <spanx style="verb">middle_name</spanx>,
	    <spanx style="verb">nickname</spanx>,
	    <spanx style="verb">preferred_username</spanx>,
	    <spanx style="verb">profile</spanx>,
	    <spanx style="verb">picture</spanx>,
	    <spanx style="verb">website</spanx>,
	    <spanx style="verb">gender</spanx>,
	    <spanx style="verb">birthdate</spanx>,
	    <spanx style="verb">zoneinfo</spanx>,
	    <spanx style="verb">locale</spanx>, and
	    <spanx style="verb">updated_at</spanx>.</t>

	    <t hangText="email">OPTIONAL. This scope value requests access to
	    the <spanx style="verb">email</spanx> and
	    <spanx style="verb">email_verified</spanx> Claims.</t>

	    <t hangText="address">OPTIONAL. This scope value requests access to
	    the <spanx style="verb">address</spanx> Claim.</t>

	    <t hangText="phone">OPTIONAL. This scope value requests access to
	    the <spanx style="verb">phone_number</spanx> and
	    <spanx style="verb">phone_number_verified</spanx> Claims.</t>

	    <t hangText="offline_access">OPTIONAL. This scope value requests
	    that an OAuth 2.0 Refresh Token be issued that can be used to
	    obtain an Access Token that grants access to the End-User's
	    UserInfo Endpoint even when the End-User is not present (not logged in).</t>

	  </list>
	</t>

	<t>Multiple scope values MAY be used by creating a space delimited, case
	sensitive list of ASCII scope values.</t>

	<t>
	  The Claims requested by the
	  <spanx style="verb">profile</spanx>,
	  <spanx style="verb">email</spanx>,
	  <spanx style="verb">address</spanx>, and
	  <spanx style="verb">phone</spanx> scope values
	  are returned from the UserInfo Endpoint,
	  as described in <xref target="UserInfoResponse"/>,
	  when a <spanx style="verb">response_type</spanx> value is used
	  that results in an Access Token being issued.
	  However, when the <spanx style="verb">response_type</spanx> value used is
	  <spanx style="verb">id_token</spanx> (which issues no Access Token),
	  the resulting Claims are returned in the ID Token.
	</t>

	<t>In some cases, the End-User will be given the option to
	have the OpenID Provider decline to provide some or all
	information requested by Clients.
	To minimize the amount of information that the End-User is being asked
	to disclose, a Client can elect to
	only request a subset of the information available from the
	UserInfo Endpoint.</t>

	<t>
	  <figure>
	    <preamble>The following is a non-normative example of a <spanx style="verb">scope</spanx>
	    Request:</preamble>

	    <artwork><![CDATA[
  scope=openid profile email phone
]]></artwork>
	  </figure>
	</t>
      </section>

      <section anchor="StandardClaims" title="Standard Claims">
	<t>This specification defines a set of standard Claims.
	They can be requested to be returned either in the
	UserInfo Response or in the ID Token.
	</t>

	<texttable anchor="ClaimTable" title="Reserved Member Definitions">
	  <ttcol align="left">Member</ttcol>

	  <ttcol align="left">Type</ttcol>

	  <ttcol align="left">Description</ttcol>

	  <c>sub</c>
	  <c>string</c>
	  <c>Subject - Identifier for the End-User at the Issuer.</c>

	  <c>name</c>
	  <c>string</c>
	  <c>
	    End-User's full name in displayable form including all name parts,
	    possibly including titles and suffixes,
	    ordered according to the End-User's locale and preferences.
	  </c>

	  <c>given_name</c>
	  <c>string</c>
	  <c>
	    Given name(s) or first name(s) of the End-User.
	    Note that in some cultures, people can have multiple given names;
	    all can be present, with the names being separated by space characters.
	  </c>

	  <c>family_name</c>
	  <c>string</c>
	  <c>
	    Surname(s) or last name(s) of the End-User.
	    Note that in some cultures, people can have multiple family names
	    or no family name;
	    all can be present, with the names being separated by space characters.
	  </c>

	  <c>middle_name</c>
	  <c>string</c>
	  <c>
	    Middle name(s) of the End-User.
	    Note that in some cultures, people can have multiple middle names;
	    all can be present, with the names being separated by space characters.
	    Also note that in some cultures, middle names are not used.
	  </c>

	  <c>nickname</c>
	  <c>string</c>
	  <c>Casual name of the End-User that may or may not be the same as the
	  <spanx style="verb">given_name</spanx>. For instance, a <spanx
	  style="verb">nickname</spanx> value of <spanx style="verb">Mike</spanx>
	  might be returned alongside a <spanx style="verb">given_name</spanx>
	  value of <spanx style="verb">Michael</spanx>.</c>

	  <c>preferred_username</c>
	  <c>string</c>
	  <c>Shorthand name that the End-User wishes to be referred to at the RP, such as
	  <spanx style="verb">janedoe</spanx> or <spanx style="verb">j.doe</spanx>. 
	  This value MAY be any valid JSON string including 
	  special characters such as <spanx style="verb">@</spanx>, 
	  <spanx style="verb">/</spanx>, or whitespace. This value MUST NOT
	  be relied upon to be unique by the RP. 
	  (See <xref target="claim.stability"></xref>.)</c>

	  <c>profile</c>
	  <c>string</c>
	  <c>
	    URL of the End-User's profile page.
	    The contents of this Web page SHOULD be about the End-User.
	  </c>

	  <c>picture</c>
	  <c>string</c>
	  <c>
	    URL of the End-User's profile picture.
	    This URL MUST refer to an image file
	    (for example, a PNG, JPEG, or GIF image file),
	    rather than to a Web page containing an image.
	    Note that this URL SHOULD specifically reference
	    a profile photo of the End-User
	    suitable for displaying when describing the End-User,
	    rather than an arbitrary photo taken by the End-User.
	  </c>

	  <c>website</c>
	  <c>string</c>
	  <c>
	    URL of the End-User's Web page or blog.
	    This Web page SHOULD contain information published by the End-User
	    or an organization that the End-User is affiliated with.
	  </c>

	  <c>email</c>
	  <c>string</c>
	  <c>
	    End-User's preferred e-mail address.
	    Its value MUST conform to the <xref target="RFC5322">RFC 5322</xref>
	    addr-spec syntax.
	    This value MUST NOT be relied upon to be unique by the RP,
	    as discussed in <xref target="claim.stability"></xref>.
	  </c>

	  <c>email_verified</c>
	  <c>boolean</c>
	  <c>
	    True if the End-User's e-mail address has been verified; otherwise false.
	    When this Claim Value is <spanx style="verb">true</spanx>,
	    this  means that the OP took affirmative steps
	    to ensure that this e-mail address was controlled by the End-User
	    at the time the verification was performed.
	    The means by which an e-mail address is verified is context-specific,
	    and dependent upon the trust framework or contractual agreements
	    within which the parties are operating.
	  </c>

	  <c>gender</c>
	  <c>string</c>
	  <c>End-User's gender.  Values defined by this
	  specification are <spanx style="verb">female</spanx> and
	  <spanx style="verb">male</spanx>.  Other values MAY be used
	  when neither of the defined values are applicable.</c>

	  <c>birthdate</c>
	  <c>string</c>
	  <c>End-User's birthday, represented as an
	  <xref target="ISO8601-2004">ISO 8601:2004</xref> <spanx style="verb">YYYY-MM-DD</spanx>
	  format. The year MAY be <spanx style="verb">0000</spanx>, indicating that it is omitted.
	  To represent only the year, <spanx style="verb">YYYY</spanx> format is allowed. Note that
	  depending on the underlying platform's date related function, providing just year can
	  result in varying month and day, so the implementers need to take this factor into account
	  to correctly process the dates. </c>

	  <c>zoneinfo</c>
	  <c>string</c>
	  <c>String from zoneinfo <xref target="zoneinfo"/> time zone
	  database representing the End-User's time zone.
	  For example, <spanx style="verb">Europe/Paris</spanx> or
	  <spanx style="verb">America/Los_Angeles</spanx>.</c>

	  <c>locale</c>
	  <c>string</c>
	  <c>End-User's locale, represented as a
	  <xref target="RFC5646">BCP47</xref> language tag.
	  This is typically an <xref target="ISO639-1">ISO 639-1 Alpha-2</xref>
	  language code in
	  lowercase and an <xref target="ISO3166-1">ISO 3166-1 Alpha-2</xref>
	  country code in uppercase, separated by a dash. For example,
	  <spanx style="verb">en-US</spanx> or <spanx style="verb">fr-CA</spanx>.
	  As a compatibility note, some implementations have used an underscore
	  as the separator rather than a dash, for example,
	  <spanx style="verb">en_US</spanx>; Implementations MAY choose to
	  accept this locale syntax as well.</c>

	  <c>phone_number</c>
	  <c>string</c>
	  <c>
	    End-User's preferred telephone number. <xref target="E.164">E.164</xref>
	    is RECOMMENDED as the format of this Claim,
	    for example, <spanx style="verb">+1 (425) 555-1212</spanx>
	    or <spanx style="verb">+56 (2) 687 2400</spanx>.
	    If the phone number contains an extension, it is RECOMMENDED that
	    the extension be represented using the
	    <xref target="RFC3966">RFC 3966</xref> extension syntax,
	    for example, <spanx style="verb">+1 (604) 555-1234;ext=5678</spanx>.
	  </c>

	  <c>phone_number_verified</c>
	  <c>boolean</c>
	  <c>
	    True if the End-User's phone number has been verified; otherwise false.
	    When this Claim Value is <spanx style="verb">true</spanx>,
	    this  means that the OP took affirmative steps
	    to ensure that this phone number was controlled by the End-User
	    at the time the verification was performed.
	    The means by which a phone number is verified is context-specific,
	    and dependent upon the trust framework or contractual agreements
	    within which the parties are operating.
	    When true, the <spanx style="verb">phone_number</spanx>
	    Claim MUST be in E.164 format
	    and any extensions MUST be represented in RFC 3966 format.
	  </c>

	  <c>address</c>
	  <c>JSON object</c>
	  <c>End-User's preferred address. The value of the <spanx
	  style="verb">address</spanx> member is a <xref
	  target="RFC4627">JSON</xref> structure containing some or all of
	  the members defined in <xref target="address_claim" />. </c>

	  <c>updated_at</c>
	  <c>number</c>
	  <c>
	    Time the End-User's information was last updated.
	    The time is represented as the number of seconds from
	    1970-01-01T0:0:0Z as measured in UTC until the date/time.
	  </c>
	</texttable>

	<t>For privacy reasons, OpenID Providers MAY elect to not return
	values for some requested Claims.</t>

	<t>The <spanx style="verb">sub</spanx> (subject) Claim in the UserInfo Endpoint response MUST exactly match the 
	<spanx style="verb">sub</spanx> Claim in the ID Token, before using additional UserInfo Endpoint Claims.</t>

	<t>The UserInfo Endpoint MUST return Claims in JSON format unless a
	different format was specified during Registration
	<xref target="OpenID.Registration"/>.
	The UserInfo Endpoint MAY return Claims in
	JWT format, which can be signed and/or encrypted.
	The UserInfo Endpoint MUST return a content-type header to indicate
	which format is being returned. The following are accepted content
	types:</t>

	<texttable style="all">
	  <ttcol>Content-Type</ttcol>

	  <ttcol>Format Returned</ttcol>

	  <c>application/json</c>

	  <c>plain text JSON object</c>

	  <c>application/jwt</c>

	  <c>JSON Web Token (JWT)</c>
	</texttable>

	<figure>
	  <preamble>The following is a non-normative example
	  of a UserInfo Response body:</preamble>
	  <artwork><![CDATA[
  {
   "sub": "248289761001",
   "name": "Jane Doe",
   "given_name": "Jane",
   "family_name": "Doe",
   "preferred_username": "j.doe",
   "email": "janedoe@example.com",
   "picture": "http://example.com/janedoe/me.jpg"
  }
]]></artwork>
	</figure>

	<section title="Address Claim" anchor="address_claim">
	  <t>
	    The Address Claim represents a physical mailing address. 
	    Implementations MAY return only a subset of the
	    fields of an <spanx style="verb">address</spanx>, depending upon
	    the information available and the End-User's privacy 
	    preferences. For
	    example, the <spanx style="verb">country</spanx> and <spanx 
	    style="verb">region</spanx> might be returned without returning
	    more fine-grained address information.
	  </t>
	  <t>
	    Implementations MAY return just the full address 
	    as a single string in the formatted sub-field, 
	    or they MAY return just the individual component 
	    fields using the other sub-fields, 
	    or they MAY return both. 
	    If both variants are returned, 
	    they SHOULD be describing the same address, 
	    with the formatted address indicating how the 
	    component fields are combined.
	  </t>
	  <t>
	    <list style="hanging">
	      <t hangText="formatted">
		Full mailing address, 
		formatted for display or use on a mailing label. 
		This field MAY contain multiple lines, separated by newline characters.
	      </t>

	      <t hangText="street_address">
		Full street address component, 
		which MAY include house number, street name, 
		Post Office Box, and multi-line extended street 
		address information.
		This field MAY contain multiple lines, separated by newline characters.
	      </t>

	      <t hangText="locality">City or locality component.</t>

	      <t hangText="region">State, province, 
	      prefecture or region component.</t>

	      <t hangText="postal_code">Zip code or 
	      postal code component.</t>

	      <t hangText="country">Country name component.</t>
	    </list>
	  </t>
	</section>

	<section anchor="ClaimsLanguagesAndScripts" title="Claims Languages and Scripts">
	  <t>
	    Human-readable Claim Values and Claim Values that reference human-readable values
	    MAY be represented in multiple languages and scripts.
	    To specify the languages and scripts, <xref
	    target="RFC5646">BCP47</xref> language tags are added to member names,
	    delimited by a <spanx style="verb">#</spanx> character.  For example,
	    <spanx style="verb">family_name#ja-Kana-JP</spanx> expresses the
	    Family Name in Katakana in Japanese, which is commonly used to index
	    and represent the phonetics of the Kanji representation of the same
	    represented as <spanx style="verb">family_name#ja-Hani-JP</spanx>.
	    As another example, both <spanx style="verb">website</spanx> and
	    <spanx style="verb">website#de</spanx> Claim Values might be returned,
	    referencing a Web site in an unspecified language and a Web site
	    in German.
	  </t>
	  <t>
	    Since Claim Names are case sensitive, it is strongly RECOMMENDED
	    that language tag values used in Claim Names be spelled using the
	    character case with which they are registered in the
	    <xref target="IANA.Language">IANA Language Subtag Registry</xref>.
	    In particular, normally language names are spelled with lowercase characters,
	    region names are spelled with uppercase characters, and
	    scripts are spelled with mixed case characters.
	    However, since BCP47 language tag values are case insensitive,
	    implementations SHOULD interpret the language tag values supplied
	    in a case insensitive manner.
	  </t>
	  <t>
	    Per the recommendations in BCP47, language tag values for Claims
	    SHOULD only be as specific as necessary.
	    For instance, using <spanx style="verb">fr</spanx> might be sufficient
	    in many contexts, rather than <spanx style="verb">fr-CA</spanx> or
	    <spanx style="verb">fr-FR</spanx>.
	    Where possible, OPs SHOULD try to match requested Claim locales with
	    Claims it has.  For instance, if the Client asks for a Claim with
	    a <spanx style="verb">de</spanx> (German) language tag and the OP
	    has a value tagged with <spanx style="verb">de-CH</spanx> (Swiss German)
	    and no generic German value, it would be appropriate for the OP
	    to return the Swiss German value to the Client.
	    (This intentionally moves as much of the complexity of language tag
	    matching to the OP as possible, to simplify Clients.)
	  </t>
	  <t>
	    A <spanx style="verb">claims_locales</spanx> request can be used to
	    specify the preferred languages and scripts to use for the returned Claims.
	    <xref target="IndividualClaimsLanguages"/> describes how to request
	    that specific Claims use particular languages and scripts.
	  </t>
	  <t>
	    When the OP determines, either through the
	    <spanx style="verb">claims_locales</spanx> parameter,
	    or by other means, that the End-User and Client are
	    requesting Claims in only one set of languages and scripts,
	    it is RECOMMENDED that OPs return Claims without language tags
	    when they employ this language and script.
	    It is also RECOMMENDED that Clients be written in a manner
	    that they can handle and utilize Claims using language tags.
	  </t>
	</section>

	<section anchor="claim.stability" title="Claim Stability and Uniqueness">

	  <t>
	    The <spanx style="verb">sub</spanx> (subject) and
	    <spanx style="verb">iss</spanx> (issuer) Claims are the only Claims that a Client
	    can rely upon as a stable identifier for the End-User,
	    since the <spanx style="verb">sub</spanx>
	    Claim MUST be locally unique and never reassigned within the Issuer
	    for a particular End-User, as described in <xref target="id_token"></xref>.
	    Therefore, the only guaranteed unique identifier for a given End-User is the
	    combination of the <spanx style="verb">iss</spanx> Claim
	    and the <spanx style="verb">sub</spanx> Claim.
	  </t>
	  <t>
	    All other Claims carry no such guarantees across different issuers in terms of
	    stability over time or uniqueness across users, and Issuers are permitted to
	    apply local restrictions and policies. For instance, an Issuer MAY re-use an
	    <spanx style="verb">email</spanx> Claim value across different
	    End-Users at different points in time, and the claimed 
	    <spanx style="verb">email</spanx> address for a given End-User MAY change 
	    over time.
	    Therefore, other Claims such as <spanx style="verb">email</spanx>,
	    <spanx style="verb">phone_number</spanx>, and
	    <spanx style="verb">preferred_username</spanx>
	    and MUST NOT be used as unique identifiers for the End-User.
	  </t>

	</section>

	<section anchor="AdditionalClaims" title="Additional Claims">
	  <t>
	    While this specification defines only small set of Claims as
	    standard Claims, other Claims MAY be used in conjunction
	    with the standard Claims.
	    When using such Claims, it is RECOMMENDED that
	    collision resistant names be used for the Claim Names,
	    as described in Section 4.2 (Public Claim Names) of the
	    <xref target="JWT">JSON Web Token (JWT)</xref> specification.
	    Alternatively, Private Claim Names can be safely used
	    when naming conflicts are unlikely to arise,
	    as described in 4.3 of the JWT specification.
	    Or, if specific additional Claims will have broad and general applicability,
	    they can be registered with Reserved Claim Names,
	    per Sections 4.1 and 9.1 of the JWT specification.
	  </t>
	</section>
      </section>

      <section anchor="ClaimsRequest" title="Claims Request">
	<t>
	  The <spanx style="verb">claims</spanx> parameter requests that specific Claims
	  be returned from the UserInfo Endpoint and/or in the ID Token.
	  It is represented as a JSON object containing lists of Claims being requested
	  from these locations.
	  Properties of the Claims being requested MAY also be specified.
	</t>
	<t>
	  Support for the <spanx style="verb">claims</spanx> parameter is OPTIONAL.
	  Should an OP not support this parameter and an RP uses it,
	  the OP SHOULD return a set of Claims to the RP that it believes would
	  be useful to the RP and the End-User using whatever heuristics it
	  believes are appropriate.
	  The <spanx style="verb">claims_parameter_supported</spanx>
	  Discovery result indicates whether the OP supports this parameter.
	</t>
	<t>
	  The <spanx style="verb">claims</spanx> parameter value is represented
	  in an OAuth 2.0 request as UTF-8 encoded JSON
	  (which ends up being form-urlencoded when passed as an OAuth parameter).
	  When used in a Request Object value, per <xref target="RequestObject"/>,
	  the JSON is used as the value of the
	  <spanx style="verb">claims</spanx> member.
	</t>
	<t>
	  The top-level members of the Claims request JSON object are:

	  <list style="hanging">
	    <t hangText="userinfo">
	      OPTIONAL.
	      Requests that the listed individual Claims be returned
	      from the UserInfo Endpoint.
	      If present, the listed Claims are being requested to be added to
	      any Claims that are being requested using
	      <spanx style="verb">scope</spanx> values.
	      If not present, the Claims being requested from the UserInfo Endpoint
	      are only those requested using  <spanx style="verb">scope</spanx> values.
	    </t>
	    <t>
	      When the <spanx style="verb">userinfo</spanx> member is used,
	      the request MUST also use a <spanx style="verb">response_type</spanx>
	      value that results in an Access Token being issued
	      to use at the UserInfo Endpoint.
	    </t>

	    <t hangText="id_token">
	      OPTIONAL.
	      Requests that the listed individual Claims be returned
	      in the ID Token.
	      If present, the listed Claims are being requested to be added to
	      the default Claims in the ID Token.
	      If not present, the default ID Token Claims are requested.
	    </t>

	  </list>

	  Other members MAY be present.
	  Any members used that are not understood MUST be ignored.
	</t>

	<t>
	  <figure>
	    <preamble>An example Claims request is as follows:</preamble>

	    <artwork><![CDATA[
  {
   "userinfo":
    {
     "given_name": {"essential": true},
     "nickname": null,
     "email": {"essential": true},
     "email_verified": {"essential": true},
     "picture": null,
     "http://example.info/claims/groups": null
    },
   "id_token":
    {
     "auth_time": {"essential": true},
     "acr": {"values": ["urn:mace:incommon:iap:silver"] }
    }
  }
]]></artwork>
	  </figure>
	  Note that a Claim that is not in the standard set defined in
	  <xref target="StandardClaims"/>, the (example)
	  <spanx style="verb">http://example.info/claims/groups</spanx> Claim,
	  is being requested.
	  Using the <spanx style="verb">claims</spanx> parameter is the only
	  way to request Claims outside the standard set.
	  It is also the only way to request specific combinations of the
	  standard Claims that cannot be specified using scope values.
	</t>

	<section anchor="IndividualClaimsRequests" title="Individual Claims Requests">
	  <t>
	    The <spanx style="verb">userinfo</spanx> and
	    <spanx style="verb">id_token</spanx> members of the
	    <spanx style="verb">claims</spanx> request both are JSON objects
	    with the names of the individual Claims being requested as the member names.
	    The member values MUST be one of the following:

	    <list style="hanging">
	      <t hangText="null">
		Indicates that this Claim is being requested in the default manner.
		In particular, this is a Voluntary Claim.
		For instance, the Claim request:

		<figure>
		  <artwork><![CDATA[
  "given_name": null
]]></artwork>
		</figure>

		requests the <spanx style="verb">given_name</spanx> Claim
		in the default manner.
	      </t>
	      <t hangText="JSON Object">
		Used to provide additional information about the Claim being 
		requested. This specification defines the following members: 

		<list style="hanging">
		  <t hangText="essential">
		    OPTIONAL.
		    Indicates whether the Claim being requested is an Essential Claim.
		    If the value is <spanx style="verb">true</spanx>, 
		    this indicates that the Claim is an Essential Claim.
		    For instance, the Claim request:

		    <figure>
		      <artwork><![CDATA[
  "auth_time": {"essential": true}
]]></artwork>
		    </figure>

		    can be used to specify that it is Essential to return an
		    <spanx style="verb">auth_time</spanx> Claim Value.
		  </t>
		  <t>
		    If the value is <spanx style="verb">false</spanx>,
		    it indicates that it is a Voluntary Claim.
		    The default is <spanx style="verb">false</spanx>.
		  </t>
		  <t>
		    By requesting Claims as Essential Claims
		    the Client indicates to the End-User 
		    that releasing these Claims will ensure a smooth authorization 
		    for the specific task requested by the End-User.
		    Note that even if the Claims are not available because 
		    the End-User did not authorize their release or they are not present,
		    the Authorization Server MUST NOT generate an error when
		    Claims are not returned, whether they are Essential or Voluntary.
		  </t>

		  <t hangText="value">
		    OPTIONAL.
		    Requests that the Claim be returned with a particular value.
		    For instance the Claim request:

		    <figure>
		      <artwork><![CDATA[
  "sub": {"value": "248289761001"}
]]></artwork>
		    </figure>

		    can be used to specify that the request apply to the End-User
		    with subject identifier <spanx style="verb">248289761001</spanx>.
		  </t>
		  <t>
		    The value of the <spanx style="verb">value</spanx> member
		    MUST be a valid value for the Claim being requested.
		    Definitions of individual Claims can include requirements on
		    how and whether the <spanx style="verb">value</spanx>
		    qualifier is to be used when requesting that Claim.
		  </t>
		  <t hangText="values">
		    OPTIONAL.
		    Requests that the Claim be returned with one of a set of values,
		    with the values appearing in order of preference.
		    For instance the Claim request:

		    <figure>
		      <artwork><![CDATA[
  "acr": {"essential": true,
          "values": ["urn:mace:incommon:iap:silver",
                     "urn:mace:incommon:iap:bronze"]}
]]></artwork>
		    </figure>

		    specifies that it is Essential that the <spanx style="verb">acr</spanx>
		    Claim be returned with either the value
		    <spanx style="verb">urn:mace:incommon:iap:silver</spanx> or
		    <spanx style="verb">urn:mace:incommon:iap:bronze</spanx>.
		  </t>
		  <t>
		    The values in the <spanx style="verb">values</spanx> member array
		    MUST be valid values for the Claim being requested.
		    Definitions of individual Claims can include requirements on
		    how and whether the <spanx style="verb">values</spanx>
		    qualifier is to be used when requesting that Claim.
		  </t>
		</list>

		Other members MAY be defined to provide additional 
		information about the requested Claims.
		Any members used that are not understood MUST be ignored.
	      </t>
	    </list>
	  </t>
	  <t>
	    Note that when the <spanx style="verb">claims</spanx> request parameter
	    is supported, the scope values that request Claims, as defined in
	    <xref target="scopes"/>, are effectively shorthand methods for
	    requesting sets of individual Claims.
	    For example, using the scope value <spanx style="verb">openid email</spanx>
	    and a <spanx style="verb">response_type</spanx> that returns an Access Token
	    is equivalent to using the scope value <spanx style="verb">openid</spanx>
	    and the following request for individual Claims.

	    <figure>
	      <preamble>
		Equivalent of using the <spanx style="verb">email</spanx> scope value:
	      </preamble>

	      <artwork><![CDATA[
  {
   "userinfo":
    {
     "email": null,
     "email_verified": null
    }
  }
]]></artwork>
	    </figure>
	  </t>
	</section>

	<section anchor="IndividualClaimsLanguages" title="Languages and Scripts for Individual Claims">
	  <t>
	    As described in <xref target="ClaimsLanguagesAndScripts"/>,
	    human-readable Claims values and Claim Values that reference human-readable values
	    MAY be represented in multiple languages and scripts.
	    Within a request for individual Claims, requested languages and scripts
	    for particular Claims MAY be requested by including Claim Names
	    that contain <spanx style="verb">#</spanx>-separated
	    <xref target="RFC5646">BCP47</xref> language tags
	    in the Claims request, using the Claim Name syntax specified in
	    <xref target="ClaimsLanguagesAndScripts"/>.
	    For example, a Family Name in Katakana in Japanese
	    can be requested using the Claim Name
	    <spanx style="verb">family_name#ja-Kana-JP</spanx>
	    and a Kanji representation of the Family Name in Japanese
	    can be requested using the Claim Name
	    <spanx style="verb">family_name#ja-Hani-JP</spanx>.
	    A German-language Web site can be requested with the Claim Name
	    <spanx style="verb">website#de</spanx>.
	  </t>
	  <t>
	    If an OP receives a request for human-readable Claims in a language and script
	    that it doesn't have, any versions of those Claims returned that don't use
	    the requested language and script SHOULD use a language tag in the Claim Name.
	  </t>
	</section>

      </section>

      <section anchor="ClaimTypes" title="Claim Types">
	<t>The UserInfo Endpoint MAY return the
	following three types of Claims:</t>

	<t><list style="hanging">
	  <t hangText="Normal Claims">Claims that are directly asserted by
	  the OpenID Provider.</t>

	  <t hangText="Aggregated Claims">Claims that are asserted by a
	  Claims Provider other than the OpenID Provider but are returned
	  by OpenID Provider.</t>

	  <t hangText="Distributed Claims">Claims that are asserted by a
	  Claims Provider other than the OpenID Provider but are returned
	  as references by the OpenID Provider.</t>
	</list>The UserInfo Endpoint MUST support Normal Claims.</t>

	<t>Aggregated and Distributed Claims support is OPTIONAL.</t>

	<section anchor="NormalClaims" title="Normal Claims">
	  <t>Normal Claims are represented as members in a JSON object. The
	  Claim Name is the member name and the Claim Value is the member
	  value.</t>

	  <t>The following is a non-normative response containing Normal Claims:</t>

	  <figure>
	    <artwork><![CDATA[
  {
   "name": "Jane Doe",
   "given_name": "Jane",
   "family_name": "Doe",
   "email": "janedoe@example.com",
   "picture": "http://example.com/janedoe/me.jpg"
  }
]]></artwork>
	  </figure>

	</section>

	<section anchor="AggregatedDistributedClaims" title="Aggregated and Distributed Claims">
	  <t>Aggregated and distributed Claims are represented by
	  using special <spanx style="verb">_claim_names</spanx> and
	  <spanx style="verb">_claim_sources</spanx> members
	  of the JSON object containing the Claims.</t>

	  <t>
	    <list style="hanging">
	      <t hangText="_claim_names">
		JSON object whose member
		names are the Claim Names for the Aggregated and Distributed
		Claims. The member values are references to the member names
		in the <spanx style="verb">_claim_sources</spanx> member from which
		the actual Claim Values can be retrieved.
	      </t>

	      <t hangText="_claim_sources">
		JSON object whose
		member names are referenced by the member values of the
		<spanx style="verb">_claim_names</spanx> member. The member values
		contain sets of Aggregated Claims or reference locations for
		Distributed Claims. The member values can have one of the
		following formats depending on whether it is providing
		Aggregated or Distributed Claims:

		<list style="hanging">

		  <t hangText="Aggregated Claims">JSON object that MUST
		  contain the <spanx style="verb">JWT</spanx> member whose value is a <xref
		  target="JWT">JWT</xref> that MUST contain all the Claims
		  in the <spanx style="verb">_claim_names</spanx> object that references the
		  corresponding <spanx style="verb">_claim_sources</spanx> member.
		  Other members MAY be present.
		  Any members used that are not understood MUST be ignored.

		    <list style="hanging">
		      <t hangText="JWT">REQUIRED.
		      JWT containing Claim Values.</t>
		    </list>
		  </t>
		  <t>
		    The JWT SHOULD NOT contain a <spanx style="verb">sub</spanx> (subject)
		    Claim unless its value is an identifier for the End-User at
		    the Claims Provider (and not for the OpenID Provider or another party);
		    this typically means that a <spanx style="verb">sub</spanx> Claim
		    SHOULD NOT be provided.
		  </t>

		  <t hangText="Distributed Claims">
		    JSON object that
		    contains the following members and values:

		    <list style="hanging">
		      <t hangText="endpoint">REQUIRED.
		      OAuth 2.0 resource endpoint from which the associated
		      Claim can be retrieved. The endpoint URL MUST return
		      the Claim as a JWT.</t>

		      <t hangText="access_token">OPTIONAL.
		      Access Token
		      enabling retrieval of the Claims from the endpoint URL
		      by using the <xref target="RFC6750">OAuth 2.0 Bearer Token Usage</xref>
		      protocol. Claims SHOULD be requested using
		      the Authorization Request header field and Claims Providers
		      MUST support this method. If the Access Token
		      is not available, Clients MAY need to retrieve the
		      Access Token out of band or use an a priori Access Token
		      that was negotiated between the Claims Provider and
		      Client, or the Claims Provider MAY reauthenticate the
		      End-User and/or reauthorize the Client.</t>
		    </list>
		  </t>
		  <t>
		    A <spanx style="verb">sub</spanx> (subject) Claim SHOULD NOT
		    be returned from the Claims Provider
		    unless its value is an identifier for the End-User at
		    the Claims Provider (and not for the OpenID Provider or another party);
		    this typically means that a <spanx style="verb">sub</spanx> Claim
		    SHOULD NOT be provided.
		  </t>
		</list>
	      </t>
	    </list>
	  </t>

	  <section anchor="AggregatedExample" title="Example of Aggregated Claims">

	    <t>
	      In this non-normative example, Claims from Claims Provider A
	      are combined with other Claims held by the OpenID provider, with the
	      Claims from Claims Provider A being returned as Aggregated Claims.
	    </t>
	    <t>
	      <figure>
		<preamble>
		  In this example, these Claims about Jane Doe have been issued by
		  Claims Provider A:
		</preamble>
		<artwork><![CDATA[
  {
   "address": {
     "street_address": "1234 Hollywood Blvd.",
     "locality": "Los Angeles",
     "region": "CA",
     "postal_code": "90210",
     "country": "US"},
   "phone_number": "+1 (310) 123-4567"
  }
]]></artwork>
	      </figure>
	    </t>

	    <t>
	      Claims Provider A signs the JSON Claims, representing them in a signed JWT:
	      jwt_header.jwt_part2.jwt_part3.
	      It is this JWT that is used by the OpenID Provider.
	    </t>
	    <t>
	      <figure>
		<preamble>
		  In this example, this JWT containing Jane Doe's Aggregated Claims
		  from Claims Provider A is combined with other Normal Claims,
		  and returned as the following set of Claims:
		</preamble>
		<artwork><![CDATA[
  {
   "name": "Jane Doe",
   "given_name": "Jane",
   "family_name": "Doe",
   "birthdate": "0000-03-22",
   "eye_color": "blue",
   "email": "janedoe@example.com",
   "_claim_names": {
     "address": "src1",
     "phone_number": "src1"
   },
   "_claim_sources": {
     "src1": {"JWT": "jwt_header.jwt_part2.jwt_part3"}
   }
  }
]]></artwork>
	      </figure>
	    </t>

	  </section>

	  <section anchor="DistributedExample" title="Example of Distributed Claims">

	    <t>
	      In this non-normative example, the OpenID Provider combines
	      Normal Claims that it holds with references to Claims held by
	      two different Claims Providers, B and C, incorporating references
	      to some of the Claims held by B and C as Distributed Claims.
	    </t>
	    <t>
	      <figure>
		<preamble>
		  In this example, these Claims about Jane Doe are held by
		  Claims Provider B (Jane Doe's bank):
		</preamble>
		<artwork><![CDATA[
  {
   "shipping_address": {
     "street_address": "1234 Hollywood Blvd.",
     "locality": "Los Angeles",
     "region": "CA",
     "postal_code": "90210",
     "country": "US"},
   "payment_info": "Some_Card 1234 5678 9012 3456",
   "phone_number": "+1 (310) 123-4567"
  }
]]></artwork>
	      </figure>
	    </t>

	    <t>
	      <figure>
		<preamble>
		  Also in this example, this Claim about Jane Doe is held by
		  Claims Provider C (a credit agency):
		</preamble>
		<artwork><![CDATA[
  {
   "credit_score": 650
  }
]]></artwork>
	      </figure>
	    </t>

	    <t>
	      <figure>
		<preamble>
		  The OpenID Provider returns Jane Doe's Claims along with references
		  to the Distributed Claims from Claims Provider B and Claims Provider C
		  by sending the Access Tokens and URLs of locations from which the	
		  Distributed Claims can be retrieved:
		</preamble>
		<artwork><![CDATA[
  {
   "name": "Jane Doe",
   "given_name": "Jane",
   "family_name": "Doe",
   "email": "janedoe@example.com",
   "birthdate": "0000-03-22",
   "eye_color": "blue",
   "_claim_names": {
     "payment_info": "src1",
     "shipping_address": "src1",
     "credit_score": "src2"
    },
   "_claim_sources": {
     "src1": {"endpoint":
                "https://bank.example.com/claim_source"},
     "src2": {"endpoint":
                "https://creditagency.example.com/claims_here",
              "access_token": "ksj3n283dke"}
   }
  }
]]></artwork>
	      </figure>
	    </t>
	  </section>

	</section>
      </section>

      <section anchor="idtype" title="Subject Identifier Types">
	<t>The OpenID Provider's Discovery document SHOULD list
	its supported identifier types in the 
	<spanx style="verb">subject_types_supported</spanx> element.
	If there is more than one type listed in the array, the Client MAY elect to
	provide its preferred identifier type using the
	<spanx style="verb">subject_type</spanx> parameter during Registration.
	The types supported by this specification are:</t>

	<t><list style="hanging">
	  <t hangText="public">
	    This provides the same <spanx style="verb">sub</spanx> (subject) value to all Clients. It is the default if
	  the provider has no <spanx style="verb">subject_types_supported</spanx> element in its discovery document.</t>
	  <t hangText="pairwise">
	    This provides a different <spanx style="verb">sub</spanx> value to each Client, to prevent
	  correlation of the End-User's activities by Clients without his permission.</t>
	</list></t>

	<section anchor="idtype.pairwise.alg" title="Pairwise Identifier Algorithm">

	  <t>The OpenID Provider MUST calculate a unique
	  <spanx style="verb">sub</spanx> (subject) value for each
	  Sector Identifier.  The subject value MUST NOT be reversible
	  by any party other than the OpenID Provider.</t>

	  <t>Providers who use pairwise <spanx style="verb">sub</spanx> values SHOULD 
	  support the <spanx style="verb">sector_identifier_uri</spanx> in 
	  <xref target="OpenID.Registration">Dynamic Client Registration</xref>.
	  It provides a way for a group of websites under common administrative 
	  control to have consistent pairwise <spanx style="verb">sub</spanx> 
	  values independent of the individual domain names.
	  It also provides a way for Clients to change 
	  <spanx style="verb">redirect_uri</spanx> domains without having to 
	  reregister all of their users.</t>

	  <t>If the Client has not provided a value for
	  <spanx style="verb">sector_identifier_uri</spanx> in 
	  <xref target="OpenID.Registration">Dynamic Client Registration</xref>,
	  the Sector Identifier
	  used for pairwise identifier calculation is the host component 
	  of the registered <spanx style="verb">redirect_uri</spanx>.
	  If there are multiple hostnames in the registered
	  <spanx style="verb">redirect_uris</spanx>, the Client MUST register a 
	  <spanx style="verb">sector_identifier_uri</spanx>.</t>

	  <t>When a <spanx style="verb">sector_identifier_uri</spanx>
	  is provided, the host component of that URL is used as
	  the Sector Identifier for the pairwise identifier calculation.
	  The value of the <spanx style="verb">sector_identifier_uri</spanx>
	  MUST be a URL using the <spanx style="verb">https</spanx> scheme that points to
	  a JSON file containing an array of
	  <spanx style="verb">redirect_uri</spanx> values.
	  The values of the registered <spanx style="verb">redirect_uris</spanx>
	  MUST be included in the elements of the array,
	  or the registration MUST fail.</t>

	  <t>
	    A number of algorithms can be used by OpenID Providers to
	    calculate pairwise identifiers.
	    Three example methods are:

	    <list style="numbers">

	      <t>
		The Sector Identifier can be concatenated with a local account ID and a salt 
		value that is kept secret by the Provider. The concatenated string is then 
		hashed using an appropriate algorithm.
		<vspace blankLines="1"/>
		Calculate <spanx style="verb">sub</spanx> = SHA-256 ( sector_identifier | local_account_id | salt ).
		<vspace blankLines="1"/>
	      </t>

	      <t>
		The Sector Identifier can be concatenated with a local account ID and a salt 
		value that is kept secret by the Provider. The concatenated string is then 
		encrypted using an appropriate algorithm.
		<vspace blankLines="1"/>
		Calculate <spanx style="verb">sub</spanx> = AES-128 ( sector_identifier | local_account_id | salt ).
		<vspace blankLines="1"/>
	      </t>

	      <t>
		The Issuer creates a Globally Unique Identifier (GUID) for the pair of
		Sector Identifier and local account ID and stores this value.
	      </t>

	    </list>
	  </t>

	</section>
      </section>

      <section anchor="JWTRequests" title="Passing Authorization Request Parameters as JWTs">

	<t>
	  This specification defines the <spanx style="verb">request</spanx>
	  and <spanx style="verb">request_uri</spanx> OAuth 2.0 extension parameters
	  to enable Authentication Requests to be signed and optionally encrypted.
	  Requests using these parameters are represented as JWTs, which are respectively
	  passed by value or by reference.
	  The ability to pass requests by reference is particularly useful for large requests.
	  If one of these parameters is used,
	  the other MUST NOT be used in the same request.
	</t>

	<section title="Passing a Request Object by Value" anchor="RequestObject">

	  <t>
	    The <spanx style="verb">request</spanx> parameter
	    enables OpenID Connect requests to be passed in a single,
	    self-contained parameter and to be signed and optionally encrypted.
	    It represents the request as a JWT whose Claims are the request parameters
	    specified in <xref target="RequestParameters"/>.
	    This JWT is called a Request Object.
	  </t>
	  <t>
	    Support for the <spanx style="verb">request</spanx> parameter is OPTIONAL.
	    The <spanx style="verb">request_parameter_supported</spanx>
	    Discovery result indicates whether the OP supports this parameter.
	    Should an OP not support this parameter and an RP uses it,
	    the OP MUST return the <spanx style="verb">request_not_supported</spanx>
	    error.
	  </t>
	  <t>
	    When the <spanx style="verb">request</spanx> parameter is used,
	    the OpenID Connect request parameter values contained in the JWT
	    supersede those passed using the OAuth 2.0 request syntax.
	    However, some parameters MAY be passed using the OAuth 2.0 request syntax
	    even when a Request Object is used;
	    this would typically be done to enable a cached,
	    pre-signed (and possibly pre-encrypted) Request Object value
	    to be used containing the fixed request parameters, while parameters that
	    can vary with each request, such as <spanx style="verb">state</spanx> and
	    <spanx style="verb">nonce</spanx>, are passed as OAuth 2.0 parameters.
	  </t>
	  <t>
	    Even if a <spanx style="verb">scope</spanx> parameter
	    is present in the Request Object value,
	    a <spanx style="verb">scope</spanx> parameter MUST always be passed using
	    the OAuth 2.0 request syntax containing the
	    <spanx style="verb">openid</spanx> scope value to indicate to the
	    underlying OAuth 2.0 logic that this is an OpenID Connect request.
	  </t>
	  <t>
	    The Request Object MAY be signed or unsigned (plaintext).
	    When it is plaintext, this is indicated by use of the
	    <spanx style="verb">none</spanx> algorithm <xref target="JWA" />
	    in the JWS header.  If signed, the Request Object
	    SHOULD contain the Claims
	    <spanx style="verb">iss</spanx> (issuer)
	    and <spanx style="verb">aud</spanx> (audience) as members,
	    with their semantics being as defined in the
	    <xref target="JWT">JWT</xref> specification.
	  </t>
	  <t>
	    The Request Object MAY also be encrypted using <xref target="JWE">JWE</xref>,
	    with nested signing and encryption
	    performed as described in the JWT <xref target="JWT"/> specification.
	  </t>
	  <t>
	    <spanx style="verb">request</spanx> and
	    <spanx style="verb">request_uri</spanx> parameters
	    MUST NOT be included in Request Objects.
	  </t>

	  <t>
	    <figure>
	      <preamble>
		The following is a non-normative example of the Claims in
		a Request Object before base64url encoding and signing:
	      </preamble>

	      <artwork><![CDATA[
  {
   "response_type": "code id_token",
   "client_id": "s6BhdRkqt3",
   "redirect_uri": "https://client.example.org/cb",
   "scope": "openid",
   "state": "af0ifjsldkj",
   "nonce": "n-0S6_WzA2Mj",
   "max_age": 86400,
   "claims": 
    {
     "userinfo": 
      {
       "given_name": {"essential": true},
       "nickname": null,
       "email": {"essential": true},
       "email_verified": {"essential": true},
       "picture": null
      },
     "id_token": 
      {
       "gender": null,
       "birthdate": {"essential": true},
       "acr": {"values": ["urn:mace:incommon:iap:silver"]}
      }
    }
  }
]]></artwork>
	    </figure>
	    <figure>
	      <preamble>
		Signing it with the <spanx style="verb">RS256</spanx> algorithm
		results in this Request Object value
		(with line wraps within values for display purposes only):
	      </preamble>

	      <artwork><![CDATA[
  eyJhbGciOiJSUzI1NiJ9.ew0KICJyZXNwb25zZV90eXBlIjogImNvZGUgaWRfdG9rZW
  4iLA0KICJjbGllbnRfaWQiOiAiczZCaGRSa3F0MyIsDQogInJlZGlyZWN0X3VyaSI6I
  CJodHRwczovL2NsaWVudC5leGFtcGxlLm9yZy9jYiIsDQogInNjb3BlIjogIm9wZW5p
  ZCIsDQogInN0YXRlIjogImFmMGlmanNsZGtqIiwNCiAibm9uY2UiOiAibi0wUzZfV3p
  BMk1qIiwNCiAibWF4X2FnZSI6IDg2NDAwLA0KICJjbGFpbXMiOiANCiAgew0KICAgIn
  VzZXJpbmZvIjogDQogICAgew0KICAgICAiZ2l2ZW5fbmFtZSI6IHsiZXNzZW50aWFsI
  jogdHJ1ZX0sDQogICAgICJuaWNrbmFtZSI6IG51bGwsDQogICAgICJlbWFpbCI6IHsi
  ZXNzZW50aWFsIjogdHJ1ZX0sDQogICAgICJlbWFpbF92ZXJpZmllZCI6IHsiZXNzZW5
  0aWFsIjogdHJ1ZX0sDQogICAgICJwaWN0dXJlIjogbnVsbA0KICAgIH0sDQogICAiaW
  RfdG9rZW4iOiANCiAgICB7DQogICAgICJnZW5kZXIiOiBudWxsLA0KICAgICAiYmlyd
  GhkYXRlIjogeyJlc3NlbnRpYWwiOiB0cnVlfSwNCiAgICAgImFjciI6IHsidmFsdWVz
  IjogWyIyIl19DQogICAgfQ0KICB9DQp9.bOD4rUiQfzh4QPIs_f_R2GVBhNHcc1p2cQ
  TgixB1tsYRs52xW4TO74USgb-nii3RPsLdfoPlsEbJLmtbxG8-TQBHqGAyZxMDPWy3p
  hjeRt9ApDRnLQrjYuvsCj6byu9TVaKX9r1KDFGT-HLqUNlUTpYtCyM2B2rLkWM08ufB
  q9JBCEzzaLRzjevYEPMaoLAOjb8LPuYOYTBqshRMUxy4Z380-FJ2Lc7VSfSu6HcB2nL
  SjiKrrfI35xkRJsaSSmjasMYeDZarYCl7r4o17rFclk5KacYMYgAs-JYFkwab6Dd56Z
  rAzakHt9cExMpg04lQIux56C-Qk6dAsB6W6W91AQ    
]]></artwork>
	    </figure>
	    <figure>
	      <preamble>
		The following is the RSA public key in JWK format that can be used to
		validate the Request Object signature in this
		and subsequent Request Object examples
		(with line wraps within values for display purposes only):
	      </preamble>

	      <artwork><![CDATA[
  {
   "kty":"RSA",
   "n":"y9Lqv4fCp6Ei-u2-ZCKq83YvbFEk6JMs_pSj76eMkddWRuWX2aBKG
  HAtKlE5P7_vn__PCKZWePt3vGkB6ePgzAFu08NmKemwE5bQI0e6kIChtt_6KzT5OaaXDF
  I6qCLJmk51Cc4VYFaxgqevMncYrzaW_50mZ1yGSFIQzLYP8bijAHGVjdEFgZaZEN9lsn_
  GdWLaJpHrB3ROlS50E45wxrlg9xMncVb8qDPuXZarvghLL0HzOuYRadBJVoWZowDNTpKp
  k2RklZ7QaBO7XDv3uR7s_sf2g-bAjSYxYUGsqkNA9b3xVW53am_UZZ3tZbFTIh557JICW
  KHlWj5uzeJXaw",
   "e":"AQAB"
  }
]]></artwork>
	    </figure>
	  </t>

	  <section anchor="request_use"
		   title='Client Sends Request using "request" Parameter'>
	    <t>The Client sends the Authorization Request to the
	    Authorization Endpoint.</t>

	    <t>
	      <figure>
		<preamble>The following is a non-normative example of an
		Authorization Request using the <spanx style='verb'>request</spanx>
		parameter
		(with line wraps within values for display purposes only):
		</preamble>

		<artwork><![CDATA[
  https://server.example.com/authorize?
    response_type=code%20id_token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid
    &state=af0ifjsldkj
    &nonce=n-0S6_WzA2Mj
    &request=eyJhbGciOiJSUzI1NiJ9.ew0KICJyZXNwb25zZV90eXBlIjogImNvZG
    UgaWRfdG9rZW4iLA0KICJjbGllbnRfaWQiOiAiczZCaGRSa3F0MyIsDQogInJlZG
    lyZWN0X3VyaSI6ICJodHRwczovL2NsaWVudC5leGFtcGxlLm9yZy9jYiIsDQogIn
    Njb3BlIjogIm9wZW5pZCIsDQogInN0YXRlIjogImFmMGlmanNsZGtqIiwNCiAibm
    9uY2UiOiAibi0wUzZfV3pBMk1qIiwNCiAibWF4X2FnZSI6IDg2NDAwLA0KICJjbG
    FpbXMiOiANCiAgew0KICAgInVzZXJpbmZvIjogDQogICAgew0KICAgICAiZ2l2ZW
    5fbmFtZSI6IHsiZXNzZW50aWFsIjogdHJ1ZX0sDQogICAgICJuaWNrbmFtZSI6IG
    51bGwsDQogICAgICJlbWFpbCI6IHsiZXNzZW50aWFsIjogdHJ1ZX0sDQogICAgIC
    JlbWFpbF92ZXJpZmllZCI6IHsiZXNzZW50aWFsIjogdHJ1ZX0sDQogICAgICJwaW
    N0dXJlIjogbnVsbA0KICAgIH0sDQogICAiaWRfdG9rZW4iOiANCiAgICB7DQogIC
    AgICJnZW5kZXIiOiBudWxsLA0KICAgICAiYmlydGhkYXRlIjogeyJlc3NlbnRpYW
    wiOiB0cnVlfSwNCiAgICAgImFjciI6IHsidmFsdWVzIjogWyIyIl19DQogICAgfQ
    0KICB9DQp9.bOD4rUiQfzh4QPIs_f_R2GVBhNHcc1p2cQTgixB1tsYRs52xW4TO7
    4USgb-nii3RPsLdfoPlsEbJLmtbxG8-TQBHqGAyZxMDPWy3phjeRt9ApDRnLQrjY
    uvsCj6byu9TVaKX9r1KDFGT-HLqUNlUTpYtCyM2B2rLkWM08ufBq9JBCEzzaLRzj
    evYEPMaoLAOjb8LPuYOYTBqshRMUxy4Z380-FJ2Lc7VSfSu6HcB2nLSjiKrrfI35
    xkRJsaSSmjasMYeDZarYCl7r4o17rFclk5KacYMYgAs-JYFkwab6Dd56ZrAzakHt
    9cExMpg04lQIux56C-Qk6dAsB6W6W91AQ
]]></artwork>
	      </figure>
	    </t>
	  </section>
	</section>

	<section title="Passing a Request Object by Reference" anchor="RequestUriParameter">
	  <t>
	    The <spanx style="verb">request_uri</spanx> parameter enables
	    OpenID Connect requests to be passed by reference, rather than by value.
	    This parameter is used identically to the
	    <spanx style="verb">request</spanx> parameter, other than that
	    the Request Object value is retrieved from the resource at the specified URL,
	    rather than passed by value.
	  </t>
	  <t>
	    The <spanx style="verb">request_uri_parameter_supported</spanx>
	    Discovery result indicates whether the OP supports this parameter.
	    Should an OP not support this parameter and an RP uses it,
	    the OP MUST return the <spanx style="verb">request_uri_not_supported</spanx>
	    error.
	  </t>
	  <t>
	    When the <spanx style="verb">request_uri</spanx> parameter is used,
	    the OpenID Connect request parameter values contained in the referenced JWT
	    supersede those passed using the OAuth 2.0 request syntax.
	    However, some parameters MAY be passed using the OAuth 2.0 request syntax
	    even when a <spanx style="verb">request_uri</spanx> is used;
	    this would typically be done to enable a cached,
	    pre-signed (and possibly pre-encrypted) Request Object value
	    to be used containing the fixed request parameters, while parameters that
	    can vary with each request, such as <spanx style="verb">state</spanx> and
	    <spanx style="verb">nonce</spanx>, are passed as OAuth 2.0 parameters.
	  </t>
	  <t>
	    Even if a <spanx style="verb">scope</spanx> parameter
	    is present in the referenced Request Object,
	    a <spanx style="verb">scope</spanx> parameter MUST always be passed using
	    the OAuth 2.0 request syntax containing the
	    <spanx style="verb">openid</spanx> scope value to indicate to the
	    underlying OAuth 2.0 logic that this is an OpenID Connect request.
	  </t>
	  <t>
	    Servers MAY cache the contents of the resources referenced by Request URIs.
	    If the contents of the referenced resource could ever change,
	    the URI SHOULD include the base64url encoded SHA-256 hash of the
	    referenced resource contents as the fragment component of the URI.
	    If the fragment value used for a URI changes, that signals the server
	    that any cached value for that URI with the old fragment value
	    is no longer valid.
	  </t>
	  <t>
	    Note that Clients MAY pre-register
	    <spanx style="verb">request_uri</spanx> values using the
	    <spanx style="verb">request_uris</spanx> parameter defined in
	    Section 2 of the <xref target="OpenID.Registration">OpenID Connect
	    Dynamic Client Registration 1.0</xref> specification.
	    OPs can require that <spanx style="verb">request_uri</spanx> values used
	    be pre-registered with the <spanx style="verb">require_request_uri_registration</spanx>
	    discovery parameter.
	  </t>
	  <t>
	    The entire Request URI MUST NOT exceed 512 ASCII characters.
	  </t>
	  <t>
	    The contents of the resource referenced by the URL MUST be a Request Object.
	    The scheme used in the 
	    <spanx style="verb">request_uri</spanx> value MUST be <spanx style="verb">https</spanx>, 
	    unless the target Request Object is signed in a way that is verifiable by the 
	    Authorization Server.
	    The <spanx style="verb">request_uri</spanx> value MUST be reachable by the
	    Authorization Server, and SHOULD be reachable by the Client.
	  </t>

	  <t>
	    <figure>
	      <preamble>The following is a non-normative example of
	      the contents of a Request Object resource that can be
	      referenced by a <spanx style="verb">request_uri</spanx>
	      (with line wraps within values for display purposes only):</preamble>

	      <artwork><![CDATA[
  eyJhbGciOiJSUzI1NiJ9.ew0KICJyZXNwb25zZV90eXBlIjogImNvZGUgaWRfdG9rZ
  W4iLA0KICJjbGllbnRfaWQiOiAiczZCaGRSa3F0MyIsDQogInJlZGlyZWN0X3VyaSI
  6ICJodHRwczovL2NsaWVudC5leGFtcGxlLm9yZy9jYiIsDQogInNjb3BlIjogIm9wZ
  W5pZCIsDQogInN0YXRlIjogImFmMGlmanNsZGtqIiwNCiAibm9uY2UiOiAibi0wUzZ
  fV3pBMk1qIiwNCiAibWF4X2FnZSI6IDg2NDAwLA0KICJjbGFpbXMiOiANCiAgew0KI
  CAgInVzZXJpbmZvIjogDQogICAgew0KICAgICAiZ2l2ZW5fbmFtZSI6IHsiZXNzZW5
  0aWFsIjogdHJ1ZX0sDQogICAgICJuaWNrbmFtZSI6IG51bGwsDQogICAgICJlbWFpb
  CI6IHsiZXNzZW50aWFsIjogdHJ1ZX0sDQogICAgICJlbWFpbF92ZXJpZmllZCI6IHs
  iZXNzZW50aWFsIjogdHJ1ZX0sDQogICAgICJwaWN0dXJlIjogbnVsbA0KICAgIH0sD
  QogICAiaWRfdG9rZW4iOiANCiAgICB7DQogICAgICJnZW5kZXIiOiBudWxsLA0KICA
  gICAiYmlydGhkYXRlIjogeyJlc3NlbnRpYWwiOiB0cnVlfSwNCiAgICAgImFjciI6I
  HsidmFsdWVzIjogWyIyIl19DQogICAgfQ0KICB9DQp9.bOD4rUiQfzh4QPIs_f_R2G
  VBhNHcc1p2cQTgixB1tsYRs52xW4TO74USgb-nii3RPsLdfoPlsEbJLmtbxG8-TQBH
  qGAyZxMDPWy3phjeRt9ApDRnLQrjYuvsCj6byu9TVaKX9r1KDFGT-HLqUNlUTpYtCy
  M2B2rLkWM08ufBq9JBCEzzaLRzjevYEPMaoLAOjb8LPuYOYTBqshRMUxy4Z380-FJ2
  Lc7VSfSu6HcB2nLSjiKrrfI35xkRJsaSSmjasMYeDZarYCl7r4o17rFclk5KacYMYg
  As-JYFkwab6Dd56ZrAzakHt9cExMpg04lQIux56C-Qk6dAsB6W6W91AQ
]]></artwork>
	    </figure>
	  </t>

	  <section anchor="request_uri_create"
		   title="Client Generates the URL of the Request Object">
	    <t>
	      The Client stores the Request Object resource either
	      locally or remotely at a URL the Server can access.
	      This is the Request URI, <spanx style="verb">request_uri</spanx>.
	    </t>
	    <t>
	      If the Request Object includes attribute 
	      values, it MUST NOT be revealed to anybody but the Authorization Server. 
	      As such, the <spanx style="verb">request_uri</spanx> MUST have
	      appropriate entropy for its lifetime.
	      It is RECOMMENDED that it be removed
	      if it is known that it will not be used again
	      or after a reasonable timeout
	      unless access control measures are taken.
	    </t>
	    <figure>
	      <preamble>The following is a non-normative example
	      of a Request URI value
	      (with line wraps within values for display purposes only):</preamble>

	      <artwork><![CDATA[
  https://client.example.org/request.jwt#
    GkurKxf5T0Y-mnPFCHqWOMiZi4VS138cQO_V7PZHAdM
]]></artwork>
	    </figure>

	  </section>

	  <section anchor="request_uri_use"
		   title='Client Sends Request using "request_uri" Parameter'>
	    <t>The Client sends the Authorization Request to the
	    Authorization Endpoint.</t>

	    <figure>
	      <preamble>The following is a non-normative example
	      of an Authorization Request using the <spanx style="verb">request_uri</spanx> parameter
	      (with line wraps within values for display purposes only):</preamble>

	      <artwork><![CDATA[
  https://server.example.com/authorize?
    response_type=code%20id_token
    &client_id=s6BhdRkqt3
    &request_uri=https%3A%2F%2Fclient.example.org%2Frequest.jwt
    %23GkurKxf5T0Y-mnPFCHqWOMiZi4VS138cQO_V7PZHAdM
    &state=af0ifjsldkj&nonce=n-0S6_WzA2Mj
    &scope=openid
]]></artwork>
	    </figure>
	  </section>

	  <section anchor="request_uri_get" title="Authorization Server Fetches Request Object">
	    <t>Upon receipt of the Request, the Authorization Server MUST
	    send a <spanx style="verb">GET</spanx> request to the <spanx style="verb">request_uri</spanx>
	    to retrieve the content unless it is already cached and parse it
	    to recreate the Authorization Request parameters.</t>

	    <t>Note that the RP SHOULD use a unique URI for each
	    request utilizing distinct parameters, or otherwise
	    prevent the Authorization Server from caching the <spanx style="verb">request_uri</spanx>.
	    </t>

	    <figure>
	      <preamble>The following is a non-normative example of this fetch
	      process:</preamble>

	      <artwork><![CDATA[
  GET /request.jwt HTTP/1.1
  Host: client.example.org
]]></artwork>
	    </figure>
	  </section>

	  <section anchor="RequestUriRationale" title="&quot;request_uri&quot; Rationale">
	    <t>
	      There are several reasons that one might choose to use the
	      <spanx style="verb">request_uri</spanx> parameter:
	    </t>
	    <t>
	      <list style="numbers">
		<t>
		  The set of request parameters can become large, and can exceed browser
		  URI size limitations.  Passing the request parameters by reference
		  can solve this problem.
		</t>
		<t>
		  Passing a <spanx style="verb">request_uri</spanx> value, rather than
		  a complete request by value, can reduce request latency.
		</t>
		<t>
		  Most requests for Claims from an RP are constant.
		  The <spanx style="verb">request_uri</spanx> is a way of creating
		  and sometimes also signing and encrypting a constant set of
		  request parameters in advance.
		  (The <spanx style="verb">request_uri</spanx> value becomes an "artifact"
		  representing a particular fixed set of request parameters.)
		</t>
		<t>
		  Pre-registering a fixed set of request parameters at registration time
		  enables OPs to cache and pre-validate the request parameters at
		  registration time, meaning they need not be retrieved at request time.
		</t>
		<t>
		  Pre-registering a fixed set of request parameters at
		  registration time enables OPs to vet the contents of
		  the request from consumer protection and other points
		  of views, either itself or by utilizing a third party.
		</t>
	      </list>
	    </t>
	  </section>
	</section>

      </section>
    </section>

    <section anchor="sigenc" title="Signatures and Encryption">
      <t>Depending on the transport through which the messages are sent, the
      integrity of the message might not be guaranteed and the originator of the
      message might not be authenticated. To mitigate these risks, 
      Request Object, Token Request, ID Token, and UserInfo Response values
      MAY utilize <xref target="JWS">JSON Web Signature
      (JWS)</xref> to sign the contents.</t>

      <t>To achieve message confidentiality, 
      Request Object, Token Request, ID Token, and UserInfo Response values
      MAY use
      <xref target="JWE">JSON Web Encryption (JWE)</xref> to encrypt the
      content.</t>

      <t>When the message is both signed and 
      encrypted, it MUST be
      signed first and then encrypted, per <xref target="signing_order"/>,
      with nesting performed in the same manner as
      specified for JWTs <xref target="JWT"/>.
      Note that all JWE encryption methods perform integrity checking.</t>

      <section anchor="sigenc.alg" title="Supported Algorithms">
	<t>The server advertises its supported signing and encryption algorithms
	in its discovery document.
	The algorithm identifiers are specified in <xref target="JWA">JWA</xref>.
	The related elements are:</t>

	<t><list style="hanging">
	  <t hangText="userinfo_signing_alg_values_supported">
	    JSON array containing a list of the JWS <xref target="JWS" /> signing algorithms
	    (<spanx style="verb">alg</spanx> values) <xref target="JWA" />
	    supported by the UserInfo Endpoint
	  to encode the Claims in a JWT <xref target="JWT" />.</t>

	  <t hangText="userinfo_encryption_alg_values_supported">
	    JSON array containing a list of the JWE <xref target="JWE" /> encryption algorithms
	    (<spanx style="verb">alg</spanx> values) <xref target="JWA" />
	    supported by the UserInfo Endpoint
	  to encode the Claims in a JWT <xref target="JWT" />.</t>

	  <t hangText="userinfo_encryption_enc_values_supported">
	    JSON array containing a list of the JWE encryption algorithms
	    (<spanx style="verb">enc</spanx> values) <xref target="JWA" />
	    supported by the UserInfo Endpoint
	  to encode the Claims in a JWT <xref target="JWT" />.</t>

	  <t hangText="id_token_signing_alg_values_supported">
	    JSON array containing a list of the JWS signing algorithms
	    (<spanx style="verb">alg</spanx> values)
	    supported by the Authorization Server for the ID Token
	  to encode the Claims in a JWT <xref target="JWT" />.</t>

	  <t hangText="id_token_encryption_alg_values_supported">
	    JSON array containing a list of the JWE encryption algorithms
	    (<spanx style="verb">alg</spanx> values)
	    supported by the Authorization Server for the ID Token
	  to encode the Claims in a JWT <xref target="JWT" />.</t>

	  <t hangText="id_token_encryption_enc_values_supported">
	    JSON array containing a list of the JWE encryption algorithms
	    (<spanx style="verb">enc</spanx> values)
	    supported by the Authorization Server for the ID Token
	  to encode the Claims in a JWT <xref target="JWT" />.</t>

	  <t hangText="request_object_signing_alg_values_supported">
	    JSON array containing a list of the JWS signing algorithms
	    (<spanx style="verb">alg</spanx> values)
	    supported by the Authorization Server for
	    Request Object values.
	    Servers SHOULD support <spanx style="verb">none</spanx> and <spanx style="verb">RS256</spanx>.
	  </t>

	  <t hangText="request_object_encryption_alg_values_supported">
	    JSON array containing a list of the JWE encryption algorithms
	    (<spanx style="verb">alg</spanx> values)
	    supported by the Authorization Server for
	    Request Object values.
	  </t>

	  <t hangText="request_object_encryption_enc_values_supported">
	    JSON array containing a list of the JWE encryption algorithms
	    (<spanx style="verb">enc</spanx> values)
	    supported by the Authorization Server for
	    Request Object values.
	  </t>

	  <t hangText="token_endpoint_auth_signing_alg_values_supported">
	    JSON array containing a list of the JWS signing algorithms
	    (<spanx style="verb">alg</spanx> values)
	    supported by the Token Endpoint for the <spanx style="verb">private_key_jwt</spanx> 
	    and <spanx style="verb">client_secret_jwt</spanx> methods
	    to encode the JWT <xref target="JWT" />.
	  Servers SHOULD support <spanx style="verb">RS256</spanx>.</t>

	</list></t>

	<t>The Client registers its REQUIRED algorithms for Signing and Encryption 
	using the following Registration parameters:</t>
	<t><list style="hanging">
	  <t hangText="request_object_signing_alg">OPTIONAL.
	  JWS signature algorithm <xref target="JWA" /> REQUIRED for Request Objects
	  by the Authorization Server. All Request Objects from
	  this <spanx style="verb">client_id</spanx> MUST be rejected if not signed by this algorithm.
	  Servers SHOULD support <spanx style="verb">RS256</spanx>.</t>

	  <t hangText="userinfo_signed_response_alg">OPTIONAL.
	  JWS signature algorithm <xref target="JWA" /> REQUIRED for UserInfo Responses. 
	  If this is specified the response will be 
	  <xref target="JWT">JWT</xref> serialized.</t>

	  <t hangText="userinfo_encrypted_response_alg">OPTIONAL.  
	  JWE <spanx style="verb">alg</spanx>
	  algorithm <xref target="JWA" /> REQUIRED for UserInfo Responses.
	  If this is requested in 
	  combination with signing, the response 
	  MUST be signed first then encrypted, per <xref target="signing_order"/>.
	  If this is specified, the response will be 
	  <xref target="JWT">JWT</xref> serialized.</t>

	  <t hangText="userinfo_encrypted_response_enc">OPTIONAL.
	  JWE <spanx style="verb">enc</spanx>
	  algorithm <xref target="JWA" /> REQUIRED for UserInfo Responses.
	  If <spanx style="verb">userinfo_encrypted_response_alg</spanx> is specified 
	  the default for this value is <spanx style="verb">A128CBC-HS256</spanx>.
	  </t>

	  <t hangText="id_token_signed_response_alg">OPTIONAL.
	  JWS signature algorithm <xref target="JWA" /> REQUIRED 
	  for ID Tokens issued to this <spanx style="verb">client_id</spanx>. 
	  The default if not specified is <spanx style="verb">RS256</spanx>.
	  The public key for validating the signature is provided by retrieving the 
	  JWK Set referenced by the
	  <spanx style="verb">jwks_uri</spanx> element from Discovery.</t>

	  <t hangText="id_token_encrypted_response_alg">OPTIONAL.  
	  JWE <spanx style="verb">alg</spanx> algorithm <xref target="JWA" />
	  REQUIRED for ID Tokens issued to this <spanx style="verb">client_id</spanx>. 
	  If this is requested, the response MUST be signed then encrypted. 
	  The default if not specified is no encryption.</t>

	  <t hangText="id_token_encrypted_response_enc">OPTIONAL.  
	  JWE <spanx style="verb">enc</spanx> 
	  algorithm <xref target="JWA" /> REQUIRED for 
	  ID Tokens issued to this <spanx style="verb">client_id</spanx>.
	  If <spanx style="verb">id_token_encrypted_response_alg</spanx> is specified 
	  the default for this value is <spanx style="verb">A128CBC-HS256</spanx>.
	  </t>
	</list></t>
      </section>

      <section anchor="sigenc.key" title="Keys">

	<t>
	  The OpenID Provider provides its public keys during Discovery
	  using the following element:
	  <list style="hanging">
	    <t hangText="jwks_uri">
	      REQUIRED.
	      URL of the OP's JSON Web Key Set <xref target="JWK"/> document.
	      This contains the signing key(s) the Client uses to validate signatures from the OP.
	      The JWK Set MAY also contain the Server's encryption key(s),
	      which are used by Clients to encrypt requests to the Server.
	      When both signing and encryption keys are made available,
	      a <spanx style="verb">use</spanx> (Key Use) parameter
	      value is REQUIRED for all keys in the document to indicate each key's intended usage.
	    </t>
	  </list>
	</t>
	<t>
	  Likewise, the Client can provide its public keys during Registration
	  using the following element:
	  <list style="hanging">
	    <t hangText="jwks_uri">
	      OPTIONAL.
	      URL for the Client's JSON Web Key Set <xref target="JWK"/> document.
	      If the Client signs requests to the Server,
	      it contains the signing key(s) the Server uses to validate signatures from the Client.
	      The JWK Set MAY also contain the Client's encryption keys(s),
	      which are used by the Server to encrypt responses to the Client.
	      When both signing and encryption keys are made available,
	      a <spanx style="verb">use</spanx> (Key Use) parameter
	      value is REQUIRED for all keys in the document to indicate each key's intended usage.
	    </t>
	  </list>
	</t>
	<t>
	  When both signing and encryption keys are made available,
	  the <spanx style="verb">use</spanx> (Key Use) parameter
	  value is REQUIRED for all keys in the JWK Set at the
	  <spanx style="verb">jwks_uri</spanx> to indicate each key's intended usage.
	  Although some algorithms allow the same key pair to be used for
	  both signatures and encryption, doing so is
	  NOT RECOMMENDED, as it is less secure.
	</t>
	<t>
	  In both cases, the JWK <spanx style="verb">x5c</spanx> parameter MAY be used
	  to provide X.509 representations of keys provided.  When used, the bare key
	  values MUST still be present and MUST match those in the certificate.
	</t>

      </section>

      <section anchor="sigs" title="Signing">
	<t>The signing party MUST select a signature algorithm 
	based on the supported algorithms of the recipient in <xref
	target="sigenc.alg"></xref>.</t>

	<t><list style="hanging">
	  <t hangText="Asymmetric Signatures">
	    When using RSA or ECDSA Signatures, 
	    the <spanx style="verb">alg</spanx>
	    Claim of the JWS header MUST be set to the appropriate algorithm
	    as defined in <xref target="JWA">JSON Web Algorithms</xref>.
	    The private key MUST be the one associated with the 
	    Public Signing Key provided in
	    <xref target="sigenc.key"/>.
	    If there are multiple keys in the referenced JWK document, a
	    <spanx style="verb">kid</spanx> value MUST be provided in the JWS header.
	    The key usage of the respective keys MUST support signature.
	  </t>
	  <t hangText="Symmetric Signatures">
	    When using MAC-based signatures,
	    the <spanx style="verb">alg</spanx>
	    Claim of the JWS header MUST be set to a MAC algorithm,
	    as defined in <xref target="JWA">JSON Web Algorithms</xref>. 
	    The MAC key used is
	    the octets of the UTF-8 representation of
	    the <spanx style="verb">client_secret</spanx> value.
	    See <xref target="SymmetricKeyEntropy"/> for a discussion of
	    entropy requirements for <spanx style="verb">client_secret</spanx> values.
	    Symmetric signatures MUST never be used by public (non-confidential) Clients
	    because of their inability to keep secrets.
	  </t>
	</list></t>
	<t>
	  See <xref target="NeedForSignedRequests"/> for Security Considerations
	  about the need for signed requests.
	</t>
	<section anchor="rotate.sig.keys" title="Rotation of Asymmetric Signing Keys">
	  <t>Rotation of signing keys can be accomplished with the following approach. The signer publishes
	  its keys in a JWK Set at the <spanx style="verb">jwks_uri</spanx> location
	  and includes the <spanx style="verb">kid</spanx> of the
	  signing key in the JWS header of each message
	  to indicate to the verifier which key is to be used to validate the signature. Keys can be rolled over
	  by periodically adding new keys to the JWK Set at <spanx style="verb">jwks_uri</spanx>.
	  The signer can begin using a new key at its
	  discretion and signals the change to the verifier using the <spanx style="verb">kid</spanx> value.
	  The verifier knows to go back to the <spanx style="verb">jwks_uri</spanx>
	  to re-retrieve the keys when it sees an unfamiliar
	  <spanx style="verb">kid</spanx> value. The JWK Set document at the <spanx style="verb">jwks_uri</spanx>
	  SHOULD retain recently decommissioned signing keys for a reasonable period of time to facilitate a
	  smooth transition.
	  </t>
	</section>

      </section>

      <section anchor="enc" title="Encryption">
	<t>The encrypting party MUST select an encryption algorithm
	based on the supported algorithms of the recipient in <xref
	target="sigenc.alg"></xref>.
	All JWTs MUST be signed before encryption
	to enable verification of the Issuer.</t>

	<t><list style="hanging">

	  <t hangText="Asymmetric Encryption: RSA">
	    Use the link registered/discovered in <xref target="sigenc.key"></xref>
	    to retrieve the relevant key.
	    If there are multiple keys in the referenced JWK document, a
	    <spanx style="verb">kid</spanx> value MUST be provided in the JWE header.
	    Use the supported RSA key wrapping algorithm to wrap a random 
	    <spanx style="verb">Content Master Key</spanx> to be used for encrypting 
	    the signed JWT.
	    The key usage of the respective keys MUST include encryption.
	  </t>
	  <t hangText="Asymmetric Encryption: Elliptic Curve">
	    Create an ephemeral Elliptic Curve public key for the <spanx style="verb">epk</spanx>
	    element of the JWE header. 
	    Use the link registered/discovered in <xref target="sigenc.key"></xref>
	    to retrieve the relevant key.
	    If there are multiple keys in the referenced JWK document, a
	    <spanx style="verb">kid</spanx> value MUST be provided in the JWE header.
	    Use the ECDH-ES algorithm to wrap a random 
	    <spanx style="verb">Content Master Key</spanx> to be used for encrypting 
	    the signed JWT.
	    The key usage of the respective keys MUST support encryption.
	  </t>
	  <t hangText="Symmetric Encryption">
	    The symmetric encryption key is derived from the
	    <spanx style="verb">client_secret</spanx> value by
	    using a left truncated SHA-256 hash of
	    the octets of the UTF-8 representation of
	    the <spanx style="verb">client_secret</spanx>.
	    The SHA-256 value MUST be left truncated to the appropriate bit length 
	    for the AES key wrapping algorithm used,
	    for instance, to 128 bits for <spanx style="verb">A128KW</spanx>.
	    If a key wrapping key with greater than 256 bits is needed, a different method
	    of deriving the key from the <spanx style="verb">client_secret</spanx>
	    would have to be defined by an extension.
	    Symmetric encryption MUST never be used by public (non-confidential) Clients
	    because of their inability to keep secrets.
	  </t>
	</list></t>
	<t>
	  See <xref target="NeedForEncryptedRequests"/> for Security Considerations
	  about the need for encrypted requests.
	</t>

	<section anchor="rotate.enc.keys" title="Rotation of Asymmetric Encryption Keys">
	  <t>Rotating encryption keys is necessarily a different process than for signing keys because
	  the encrypting party starts the process and thus cannot rely on a change in kid as a signal
	  to know that keys need to change. The encrypting party still uses the kid header in the JWE
	  to tell the decrypting party which private key to use to decrypt, however, the encrypting party
	  needs to first select the most appropriate key from those provided in the JWK Set at
	  <spanx style="verb">jwks_uri</spanx>. To rotate keys, the decrypting party can publish new keys
	  at <spanx style="verb">jwks_uri</spanx> and remove from the JWK Set those that are being decommissioned.
	  The <spanx style="verb">jwks_uri</spanx> SHOULD include a <spanx style="verb">Cache-Control</spanx>
	  header in the response that contains a <spanx style="verb">max-age</spanx> directive,
	  as defined in <xref target="RFC2616">RFC 2616</xref>,
	  which allows the encrypting party to safely cache the JWK Set and not have to re-retrieve
	  the document for every encryption event. The decrypting party SHOULD remove decommissioned keys
	  from the JWK Set at <spanx style="verb">jwks_uri</spanx> but retain them internally for some reasonable
	  period of time, coordinated with the cache duration, to facilitate a smooth transition between keys
	  by allowing the encrypting party some time to obtain the new keys. The cache duration SHOULD also
	  be coordinated with the issuance of new signing keys as described in <xref target="rotate.sig.keys"/>.</t>
	</section>

      </section>
    </section>

    <section anchor="Validation" title="Validation">

      <t>
	If any of the validation procedures defined in this specification fail, any operations requiring
	the information that failed to correctly validate MUST be aborted and
	the information that failed to validate MUST NOT be used.
      </t>

      <section anchor="AuthorizationRequestValidation" title="Authorization Request Validation">
	<t>Authorization Request Validation consists of two main 
	steps: (1) decryption and signature validation of 
	the value of <spanx style="verb">request</spanx> or 
	the content of <spanx style="verb">request_uri</spanx>,  
	and (2) parameter validation.
	If a Request Object value was sent in the <spanx 
	style="verb">request</spanx> parameter or by reference in the
	<spanx style="verb">request_uri</spanx> parameter, the 
	Request Object MUST validate as 
	<xref target="JWS">JWS</xref> or <xref target="JWE">JWE</xref> 
	encoded objects,
	for which nested encryption and signing can be utilized
	in the manner described in the <xref target="JWT">JWT</xref> specification.</t>

	<section anchor="EncryptedRequestObject" title="Encrypted Request Object">

	  <t>If the Authorization Server has advertised JWE encryption algorithms
	  in the <spanx style="verb">request_object_encryption_alg_values_supported</spanx> and
	  <spanx style="verb">request_object_encryption_enc_values_supported</spanx> elements of its 
	  Discovery Document, these are used by the Client to encrypt the JWT.</t>

	  <t>
	    The Authorization Server MUST decode the JWT in accordance with
	    the <xref target="JWE">JSON Web Encryption</xref> specification.
	    The result MAY be either a signed or unsigned (plaintext) Request Object. 
	    In the former case, signature validation MUST be performed 
	    as defined in <xref target="signed.req.obj.var"/>.
	  </t>

	  <t>The Authorization Server MUST return the error if there is a decryption error.</t>
	</section>

	<section anchor="signed.req.obj.var" title="Signed Request Object">

	  <t>To perform Signature Validation, 
	  the <spanx style="verb">alg</spanx> parameter in the JWS header MUST match the value
	  of the <spanx style="verb">request_object_signing_alg</spanx> set during
	  <xref target="OpenID.Registration">Client Registration</xref> or a value that was
	  pre-registered by other means.</t>

	  <t>The signature MUST be validated against the key registered for that <spanx style="verb">client_id</spanx>
	  and algorithm, in accordance with the 
	  <xref target="JWS">JSON Web Signature</xref> specification.</t>

	  <t>The Authorization Server MUST return the Authorization Error Response
	  if there is a signature validation error.</t>
	</section>
	<section anchor="req.obj.veri" title="Parameter Validation">
	  <t>The Authorization Server MUST construct the Authorization Request Message 
	  from the Request Object value
	  and the OAuth 2.0 Authorization Request parameters.
	  If the same parameter exists both in 
	  the Request Object and the OAuth Authorization Request parameters,
	  the parameter in the Request Object is used.
	  Using this Authorization Request Message, the Authorization Server performs 
	  the following steps of the request validation: 
	  </t>
	  <t>
	    <list style="numbers">
	      <t>
		The Authorization Server MUST validate all the 
		OAuth 2.0 parameters according to the OAuth 2.0 specification.
	      </t>
	      <t>
		The Authorization Server MUST verify that all the REQUIRED parameters 
		are present.
	      </t>
	      <t>
		If the <spanx style="verb">sub</spanx> (subject) Claim
		as a member of <spanx style="verb">id_token</spanx> element
		is requested with a specific value, 
		the Authorization Server MUST only send a positive response if that user 
		has an active session with the Authorization Server.
		The Authorization Server MUST NOT reply with an ID Token or
		Access Token for a different user, 
		even if they have an active session with the Authorization Server. 
	      </t>
	      <t>
		If the <spanx style="verb">acr</spanx> Claim is requested
		as an Essential Claim for the ID Token
		with a <spanx style="verb">values</spanx> parameter requesting
		specific Authentication Context Class Reference values, then 
		the Authorization Server MUST return an <spanx style="verb">acr</spanx> 
		Claim Value that matches one of the requested values. 
		The Authorization Server MAY ask the End-User to re-authenticate
		with additional factors 
		to meet this requirement. If this is an Essential Claim and the 
		requirement cannot be met, then the Authorization Server MUST
		treat that outcome as a failed authentication attempt.
	      </t>
	      <t>
		The Client MAY request this Claim as a Voluntary Claim
		by using the <spanx style="verb">acr_values</spanx> request parameter
		or by not including "essential": true in the individual
		<spanx style="verb">acr</spanx> Claim request. 
		If the Claim is not Essential and the requested value
		cannot be provided, the Authorization Server SHOULD return 
		the session's current <spanx style="verb">acr</spanx> as
		the value of the <spanx style="verb">acr</spanx> Claim. 
		If the Claim is not Essential, the Authorization Server is not required to
		provide this Claim in its response.
	      </t>
	    </list>
	  </t>
	  <t>If the Authorization Server encounters any error, 
	  it MUST return the error response.</t>

	</section>
      </section>

      <section anchor="AuthorizationResponseValidation" title="Authorization Response Validation">

	<t>
	  The Client MUST validate the response as follows:
	</t>
	<t>
	  Case 1: response_type=code
	  <list style="numbers">
	    <t>
	      Validate the response according to RFC 6749,
	      especially Sections 4.1.2 and 10.12.
	    </t>
	  </list>
	</t>
	<t>
	  Case 2: response_type=id_token&nbsp;token
	  <list style="numbers">
	    <t>
	      Verify that the response conforms to Section 5 of
	      <xref target="OAuth.Responses"/>.
	    </t>
	    <t>
	      Follow the validation rules in RFC 6749,
	      especially those in Sections 4.2.2 and 10.12.
	    </t>
	    <t>
	      Follow the validation rules in Sections <xref target="id.token.validation" format="counter"/> and <xref target="access.token.validation" format="counter"/>.
	    </t>
	  </list>
	</t>
	<t>
	  Case 3: response_type=code&nbsp;id_token
	  <list style="numbers">
	    <t>
	      Verify that the response conforms to Section 5 of
	      <xref target="OAuth.Responses"/>.
	    </t>
	    <t>
	      Follow the validation rules in RFC 6749,
	      especially those in Sections 4.2.2 and 10.12.
	    </t>
	    <t>
	      Follow the validation rules in Sections <xref target="id.token.validation" format="counter"/> and <xref target="code.validation" format="counter"/>.
	    </t>
	  </list>
	</t>
	<t>
	  Case 4: response_type=code&nbsp;token
	  <list style="numbers">
	    <t>
	      Verify that the response conforms to Section 5 of
	      <xref target="OAuth.Responses"/>.
	    </t>
	    <t>
	      Follow the validation rules in RFC 6749,
	      especially those in Sections 4.2.2 and 10.12.
	    </t>
	  </list>
	</t>
	<t>
	  Case 5: response_type=code&nbsp;id_token&nbsp;token
	  <list style="numbers">
	    <t>
	      Verify that the response conforms to Section 5 of
	      <xref target="OAuth.Responses"/>.
	    </t>
	    <t>
	      Follow the validation rules in RFC 6749,
	      especially those in Sections 4.2.2 and 10.12.
	    </t>
	    <t>
	      Follow the validation rules in Sections <xref target="id.token.validation" format="counter"/>, <xref target="access.token.validation" format="counter"/>, and <xref target="code.validation" format="counter"/>.
	    </t>
	  </list>
	</t>
	<t>
	  Case 6: response_type=id_token
	  <list style="numbers">
	    <t>
	      Verify that the response conforms to Section 5 of
	      <xref target="OAuth.Responses"/>.
	    </t>
	    <t>
	      Follow the validation rules in RFC 6749,
	      especially those in Sections 4.2.2 and 10.12.
	    </t>
	    <t>
	      Follow the validation rules in <xref target="id.token.validation"/>.
	    </t>
	  </list>
	</t>

	<t>
	  See <xref target="AuthorizationExamples"/> for example Authorization Requests
	  and corresponding Authorization Responses for each of these cases.
	</t>
      </section>

      <section anchor="id.token.validation" title="ID Token Validation">
	<t>To validate the ID Token in the Authorization or Token Endpoint Response, the Client
	MUST do the following:</t>

	<t><list style="numbers">
	  <t>If the Client has provided an
	  <spanx style="verb">id_token_encrypted_response_alg</spanx>
	  parameter during Registration, decrypt the ID Token
	  using the key pair specified during Registration.</t>

	  <t>
	    The Client MUST validate that the
	    <spanx style="verb">aud</spanx> (audience) Claim
	    contains its <spanx style="verb">client_id</spanx> value
	    registered at the Issuer identified by the
	    <spanx style="verb">iss</spanx> (issuer) Claim
	    as an audience. The <spanx style="verb">aud</spanx> (audience) Claim MAY contain an array with more than one element.
	    The ID Token MUST be rejected if the ID Token does not list
	    the Client as a valid audience, or if it contains additional audiences not trusted by the Client.
	  </t>
	  <t>
	    If the ID Token contains multiple audiences, the Client SHOULD verify
	    that an <spanx style="verb">azp</spanx> Claim is present.
	  </t>
	  <t>
	    If an <spanx style="verb">azp</spanx> (authorized party) Claim is present,
	    the Client SHOULD verify and that its <spanx style="verb">client_id</spanx>
	    is the Claim value.
	  </t>

	  <t>If the <spanx style="verb">id_token</spanx> is received via direct
	  communication between the Client and the Token Endpoint, the TLS server 
	  validation MAY be used to validate the issuer in place of 
	  checking the token signature.
	  The Client MUST validate the signature of all other ID Tokens according to
	  <xref target="JWS">JWS</xref> using the algorithm specified in the 
	  <spanx style="verb">alg</spanx> parameter of the JWT header.</t>

	  <t>The <spanx style="verb">alg</spanx> value SHOULD be the default of
	  <spanx style="verb">RS256</spanx>
	  or the algorithm sent by the Client 
	  in the <spanx style="verb">id_token_signed_response_alg</spanx> parameter 
	  during Registration.</t>

	  <t>If the <spanx style="verb">alg</spanx> parameter of the JWT header is a MAC based algorithm such as 
	  <spanx style="verb">HS256</spanx>, <spanx style="verb">HS384</spanx>,
	  or <spanx style="verb">HS512</spanx>,
	  the octets of the UTF-8 representation of
	  the <spanx style="verb">client_secret</spanx> corresponding to the 
	  <spanx style="verb">client_id</spanx> contained in the 
	  <spanx style="verb">aud</spanx> (audience) Claim are used as the key
	  to validate the signature. Multiple audiences are not supported for MAC based algorithms.</t> 

	  <t>For other Signing algorithms, the Client MUST use the signing key provided
	  in Discovery by the Issuer.
	  The issuer MUST exactly match the value of the 
	  <spanx style="verb">iss</spanx> (issuer) Claim.</t>

	  <t>The current time MUST be less than the value of the 
	  <spanx style="verb">exp</spanx> Claim.</t>

	  <t>The <spanx style="verb">iat</spanx> Claim can be used to reject tokens that 
	  were issued too far away from the current time, limiting the amount of
	  time that nonces need to be stored to prevent attacks. 
	  The acceptable range is Client specific.</t>

	  <t>If a nonce value was sent in the Authorization Request,
	  a <spanx style="verb">nonce</spanx> Claim MUST be present
	  and its value checked to verify that
	  it is the same value as the one that was sent in the Authorization Request.
	  The Client SHOULD check the <spanx style="verb">nonce</spanx> value
	  for replay attacks.
	  The precise method for detecting replay attacks is Client specific.</t>

	  <t>If the <spanx style="verb">acr</spanx> Claim was requested, the 
	  Client SHOULD check that the asserted Claim Value is appropriate.
	  The meaning and processing of  
	  <spanx style="verb">acr</spanx> Claim Values is out of scope for this specification.</t>

	  <t>
	    If the <spanx style="verb">auth_time</spanx> Claim was requested,
	    either through a specific request for this Claim
	    or by using the <spanx style="verb">max_age</spanx> parameter,
	    the Client SHOULD check the <spanx style="verb">auth_time</spanx> Claim
	    value and request re-authentication if it determines too much time
	    has elapsed since the last End-User authentication.
	  </t>
	</list></t>

      </section>

      <section anchor="UserInfoResponseValidation" title="UserInfo Response Validation">

	<t>To validate the UserInfo Response, the Client MUST do
	the following:</t>

	<t><list style="numbers">
	  <t>If the Client has provided a 
	  <spanx style="verb">userinfo_encrypted_response_alg</spanx>
	  parameter during Registration, decrypt the UserInfo Response
	  using the key pair specified during Registration.</t>

	  <t>If the response was signed, the Client SHOULD validate the
	  signature according to <xref
	  target="JWS">JWS</xref>.</t>

	  <t>Check that the OP that responded was the intended OP
	  through a TLS server certificate check, per
	  <xref target="RFC6125">RFC 6125</xref>.</t>
	</list></t>
      </section>

      <section anchor="access.token.validation" title="Access Token Validation">
	<t>To validate an Access Token issued from the Authorization Endpoint with an ID Token in 
	response to a request containing a <spanx style="verb">response_type</spanx> of
	<spanx style="verb">id_token&nbsp;token</spanx> or <spanx style="verb">code&nbsp;id_token&nbsp;token</spanx>, 
	the Client SHOULD do the following:</t>

	<t><list style="numbers">
	  <t>Hash the octets of the ASCII representation of
	  the <spanx style="verb">access_token</spanx> 
	  with the hash algorithm specified in <xref target="JWA">JWS</xref> for the
	  <spanx style="verb">alg</spanx>
	  parameter in the ID Token's <xref target="JWS">JWS</xref> header.</t>

	  <t>Take the left-most half of the hash and base64url encode it.</t>

	  <t>The value of <spanx style="verb">at_hash</spanx> in the ID Token MUST
	  match the value produced in the previous step if <spanx style="verb">at_hash</spanx>
	  is present in the ID Token.</t>
	</list></t>
      </section>

      <section anchor="code.validation" title="Code Validation">
	<t>To validate a <spanx style="verb">code</spanx> issued from the Authorization Endpoint with an ID Token in 
	response to a request containing a <spanx style="verb">response_type</spanx> of
	<spanx style="verb">code&nbsp;id_token</spanx> or <spanx style="verb">code&nbsp;id_token&nbsp;token</spanx>, the Client SHOULD do the following:</t>

	<t><list style="numbers">
	  <t>Hash the octets of the ASCII representation of
	  the <spanx style="verb">code</spanx> 
	  with the hash algorithm specified in <xref target="JWA">JWS</xref> for the
	  <spanx style="verb">alg</spanx>
	  parameter in the ID Token's <xref target="JWS">JWS</xref> header.</t>

	  <t>Take the left-most half of the hash and base64url encode it.</t>

	  <t>The value of <spanx style="verb">c_hash</spanx> in the ID Token MUST
	  match the value produced in the previous step if <spanx style="verb">c_hash</spanx>
	  is present in the ID Token.</t>
	</list></t>
      </section>

    </section>

    <section title="Offline Access" anchor="OfflineAccess">
      <t>
	The <spanx style="verb">offline_access</spanx> scope value requests
	that an OAuth 2.0 Refresh Token be issued that can be used to
	obtain an Access Token that grants access to the End-User's
	UserInfo Endpoint even when the End-User is not present (not logged in).
	When offline access is requested, a <spanx style="verb">prompt</spanx>
	parameter value of <spanx style="verb">consent</spanx> MUST be used
	unless other conditions for processing permitting offline access
	to the requested resources are in place.
	The OP MUST always obtain consent to returning a Refresh Token
	that enables offline access to the requested resources.
	A previously saved user consent is not always sufficient to grant offline access.
      </t>
      <t>
	Upon receipt of a scope parameter containing the
	<spanx style="verb">offline_access</spanx> value, the Authorization Server:

	<list style="symbols">
	  <t>
	    MUST ensure that the prompt parameter contains <spanx
	    style="verb">consent</spanx> unless other
	    conditions for processing permitting offline access
	    to the requested resources are in place;
	    unless one or both of these conditions are fulfilled, then
	    it MUST ignore the <spanx style="verb">offline_access</spanx> request,
	  </t>
	  <t>
	    MUST ignore the <spanx style="verb">offline_access</spanx> request
	    unless the Client is using a <spanx style="verb">response_type</spanx>
	    value that would result in an Authorization Code being returned,
	  </t>
	  <t>
	    MUST explicitly receive or have consent for all Clients when
	    the registered <spanx style="verb">application_type</spanx>
	    is <spanx style="verb">web</spanx>,
	  </t>
	  <t>
	    SHOULD explicitly receive or have consent for all Clients when
	    the registered <spanx style="verb">application_type</spanx>
	    is <spanx style="verb">native</spanx>.
	  </t>
	</list>

	The use of Refresh Tokens is not exclusive to the
	<spanx style="verb">offline_access</spanx> use case.
	The Authorization Server MAY grant Refresh Tokens
	in other contexts that are beyond the scope of this specification.
      </t>
    </section>

    <section anchor="client_Initiate_login" title="Initiating Login at Client from Third Party">
      <t>
	In some cases, the login flow can start at the Authorization Server
	or another party by contacting the Client via a stored link.
	The target resource at the Client can be a deep link,
	rather than a default landing page.
      </t>
      <t>
	The Client MAY optionally <xref target="OpenID.Registration">register</xref>
	an <spanx style="verb">initiate_login_uri</spanx> that
	can be used by the Authorization Server
	or another party to initiate a login for an End-User at the Client.
      </t>
      <t>
	The Authorization Server or a third party sends a
	Login Initiation Request to the
	Client Initiation URI with the following parameters:
      </t>
      <t>
	<list style="hanging">
          <t hangText="login_hint">OPTIONAL.
	    Hint to the Authorization Server
            about the login identifier the End-User might use to log in.
	    If the client receives a value for this string-valued parameter,
	    it MUST include it in the subsequent authorization request
	    as the <spanx style="verb">login_hint</spanx> parameter value.
          </t>
          <t hangText="iss">REQUIRED.
	    Issuer Identifier for the Issuer that the Client is to send
	    the authentication request to. 
            Its value MUST be a URL using the <spanx style="verb">https</spanx> scheme.
          </t>
          <t hangText="target_link_uri">OPTIONAL.
	    URI that the Client is requested to redirect to after authentication.
	    Clients MUST verify the value of the
            <spanx style="verb">target_link_uri</spanx> to prevent being used as
	    an open redirector to external sites.
          </t>

        </list>
      </t>
      
      <t>
	Other parameters MAY be sent, if defined by extensions.
	Any parameters used that are not understood MUST be ignored by the Client.
      </t>
      
      <t>Clients SHOULD employ frame busting and other techniques to prevent
      End-Users from being logged in by third party sites without their knowledge.</t>
      
    </section>

    <section anchor="self_issued" title="Self-Issued OpenID Provider">
      <t>
	OpenID Connect supports Self-Issued OpenID Providers -
	personal OPs that issue self-signed ID Tokens.
	Self-Issued OPs use the special Issuer Identifier
	<spanx style="verb">https://self-issued.me</spanx>.
      </t>
      <t>
	The messages used to communicate with Self-Issued OPs are
	mostly the same as those used to communicate with other OPs.
	Specifications for the few additional parameters used and
	for the values of some parameters in the Self-Issued case
	are defined in this section.
      </t>

      <section anchor="self_issued.discovery" title="Self-Issued OpenID Provider Discovery">
	<t>
	  If the input identifier for the discovery process
	  contains the domain self-issued.me, dynamic discovery is not performed. 
	  Instead, then the following static configuration values are used:
	</t>
	<t>
	  <figure>
	    <artwork><![CDATA[
  {
   "authorization_endpoint":
     "openid:",
   "issuer":
     "https://self-issued.me",
   "scopes_supported":
     ["openid", "profile", "email", "address", "phone"],
   "response_types_supported":
     ["id_token"],
   "subject_types_supported":
     ["pairwise"],
   "id_token_signing_alg_values_supported":
     ["RS256"],
   "request_object_signing_alg_values_supported":
     ["none", "RS256"]
  }
]]></artwork>
	  </figure>
	</t>
	<t>Note: The OpenID Foundation may consider hosting a site https://self-issued.me/ 
	that returns the above static configuration file so that the Client would not 
	need any special treatment for discovery of the Self-Issued OP. 
	</t>
      </section>

      <section anchor="self_issued.registration" title="Self-Issued OpenID Provider Registration">
	<t>
	  When using a Self-Issued OP, the Client is deemed to have 
	  registered with the OP and obtained following Client Registration Response.  
	</t>
	<t>
	  <list style="hanging">
	    <t hangText="client_id">
	      <spanx style="verb">redirect_uri</spanx> value of the Client. 
	    </t>
	    <t hangText="client_secret_expires_at">
	      0
	    </t>
	  </list>
	</t>
	<t>
	  Note: The OpenID Foundation may consider hosting the (stateless) endpoint
	  <spanx style="verb">https://self-issued.me/registration/1.0/</spanx> 
	  that returns the response above so that the Client would not need to 
	  perform any special processing for registration of a Self-Issued OP.
	</t>

	<section anchor="SelfIssuedRegistrationRequest"
		 title="Providing Additional Registration Information">
	  <t>
	    The <spanx style="verb">registration</spanx> request parameter
	    is used by the Client to provide information about itself to a Self-Issued OP
	    that would normally be provided to an OP during Dynamic Client Registration.
	    The value is a JSON object containing name/value pairs defined in
	    Section 2.1 of the 
	    <xref target="OpenID.Registration">OpenID Connect Dynamic Client Registration 1.0</xref>
	    specification.
	    None of this information is REQUIRED by Self-Issued OPs,
	    so the use of this parameter is OPTIONAL.
	  </t>
	  <t>
	    The <spanx style="verb">registration</spanx> parameter value is represented
	    in an OAuth 2.0 request as UTF-8 encoded JSON
	    (which ends up being form-urlencoded when passed as an OAuth parameter).
	    When used in a Request Object value, per <xref target="RequestObject"/>,
	    the JSON is used as the value of the
	    <spanx style="verb">registration</spanx> member.
	  </t>
	  <t>
	    The Registration parameters that would typically be used in requests
	    to Self-Issued OPs are
	    <spanx style="verb">policy_uri</spanx>,
	    <spanx style="verb">tos_uri</spanx>, and
	    <spanx style="verb">logo_uri</spanx>.
	    If the Client uses more than one redirection URI, the
	    <spanx style="verb">redirect_uris</spanx>
	    parameter would be used to register them.
	    Finally, if the Client is requesting encrypted responses, it would use the
	    <spanx style="verb">jwks_uri</spanx>,
	    <spanx style="verb">id_token_encrypted_response_alg</spanx> and
	    <spanx style="verb">id_token_encrypted_response_enc</spanx> parameters.
	  </t>
	</section>
      </section>

      <section anchor="self_issued.request" title="Self-Issued OpenID Provider Request">
	<t>The Client sends the Authorization Request to the Authorization Endpoint
	with the following parameters:</t>
	<t><list style="hanging">
	  <t hangText="response_type">
	    REQUIRED. Constant string value <spanx style="verb">id_token</spanx>.
	  </t>
	  <t hangText="client_id">
	    REQUIRED.
	    Client ID value for the Client, which in this case contains the
	    <spanx style="verb">redirect_uri</spanx> value of the Client.
	    Since the Client's
	    <spanx style="verb">redirect_uri</spanx> URI value is communicated
	    as the Client ID,
	    a <spanx style="verb">redirect_uri</spanx> parameter
	    is NOT REQUIRED to also be included in the request.
	  </t>
	  <t hangText="scope">
	    REQUIRED.
	    <spanx style="verb">scope</spanx> parameter value,
	    as specified in <xref target="scopes"/>.
	  </t>
	  <t hangText="id_token_hint">
	    OPTIONAL.
	    Previously issued ID Token
	    passed to the Authorization Server as a hint about the End-User's
	    current or past authenticated session with the Client.
	    This SHOULD be present when <spanx style="verb">prompt=none</spanx> is used.
	    If the End-User identified by the ID Token is logged in or is logged in by the
	    request, then the Authorization Server returns a positive response;
	    otherwise, it SHOULD return a negative response.
	  </t>
	  <t>
	    If the ID Token received by the RP is encrypted, the Client MUST
	    decrypt the signed ID Token contained within the encrypted ID Token.
	    The Client MAY re-encrypt the signed ID token to the Authentication Server
	    using a key that enables the server to decrypt the ID Token.
	    In this case, the <spanx style="verb">sub</spanx> (subject)
	    of the signed ID Token MUST be sent as the
	    <spanx style="verb">kid</spanx> (Key ID) of the JWE.
	    Encrypting content to Self-Issued OPs is currently only supported when
	    the OP's JWK key type is <spanx style="verb">RSA</spanx> and the encryption
	    algorithm used is <spanx style="verb">RSA1_5</spanx>.
	  </t>
	  <t hangText="claims">
	    OPTIONAL.
	    This parameter is used to request that specific Claims be returned.
	    The value is a JSON object, as specified in <xref target="ClaimsRequest"/>.
	  </t>
	  <t hangText="registration">
	    OPTIONAL.
	    This parameter is used by the Client to provide information about itself
	    to a Self-Issued OP that would normally be provided to an OP during
	    Dynamic Client Registration,
	    as specified in <xref target="SelfIssuedRegistrationRequest"/>.
	  </t>
	  <t hangText="request">
	    OPTIONAL.
	    Request Object value, as specified in <xref target="RequestObject"/>.
	    The Request Object MAY be encrypted in a JWE by the Client.
	    In this case, the <spanx style="verb">sub</spanx> (subject) of
	    a previously issued ID Token for this Client
	    MUST be sent as the <spanx style="verb">kid</spanx> (Key ID) of the JWE.
	    Encrypting content to Self-Issued OPs is currently only supported when
	    the OP's JWK key type is <spanx style="verb">RSA</spanx> and the encryption
	    algorithm used is <spanx style="verb">RSA1_5</spanx>.
	  </t>
	</list>
	</t>
	<t>
	  Other parameters MAY be sent. 
	  Note that all Claims are returned in the ID Token.
	</t>
	<t>The entire URL MUST NOT exceed 2048 ASCII characters.</t>
	<figure>
	  <preamble>
	    The following is a non-normative example
	    response
	    (with line wraps within values for display purposes only):
	  </preamble>
	  <artwork><![CDATA[
  HTTP/1.1 302 Found
  Location: openid://?
    response_type=id_token
    &client_id=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile
    &state=af0ifjsldkj
    &nonce=n-0S6_WzA2Mj
    registration=&%7B%22logo_uri%22%3A%22https%3A%2F%2F
      client.example.org%2Flogo.png%22%7D
]]></artwork>
	</figure> 
      </section>

      <section anchor="self_issued.response" title="Self-Issued OpenID Provider Response">
	<t>The Self-Issued OpenID Provider response is the same as the normal implicit flow 
	response with the following refinements.  Since it is an implicit flow
	response, the response parameters will be returned in the URL fragment component.
	</t>
	<t><list style="numbers">
	  <t>
	    The <spanx style="verb">iss</spanx> (issuer) Claim Value is 
	    <spanx style="verb">https://self-issued.me</spanx>.
	  </t>
	  <t>
	    A <spanx style="verb">sub_jwk</spanx> Claim is present, with its value being
	    the public key value used to check the signature of the ID Token.
	  </t>
	  <t>
	    The <spanx style="verb">sub</spanx> (subject) Claim
	    value is the base64url encoded SHA-256 hash of 
	    the concatenation of the octets of the UTF-8 representations of
	    the base64url encoded key values in the
	    <spanx style="verb">sub_jwk</spanx> Claim.
	    When the <spanx style="verb">kty</spanx> value is
	    <spanx style="verb">RSA</spanx>, the key values
	    <spanx style="verb">n</spanx> and 
	    <spanx style="verb">e</spanx> are concatenated in that order.
	    When the <spanx style="verb">kty</spanx> value is
	    <spanx style="verb">EC</spanx>, the key values
	    <spanx style="verb">crv</spanx>,
	    <spanx style="verb">x</spanx>, and 
	    <spanx style="verb">y</spanx> are concatenated in that order.
	  </t>
	  <t>
	    No Access Token is returned for accessing a UserInfo Endpoint,
	    so all Claims returned MUST be in the ID Token.
	  </t>
	</list></t>
      </section>

      <section anchor="self_issued.validation" title="Self-Issued ID Token Validation">

	<t>
	  If any of the validation procedures defined in this specification fail, any operations requiring
	  the information that failed to correctly validate MUST be aborted and
	  the information that failed to validate MUST NOT be used.
	</t>

	<t>To validate the ID Token in the Authorization or Token Endpoint Response, the Client
	MUST do the following:</t>

	<t><list style="numbers">
	  <t>
	    The Client MUST validate that the value of the <spanx style="verb">iss</spanx> (issuer) Claim is <spanx style="verb">https://self-isued.me</spanx>.  
	    If <spanx style="verb">iss</spanx> contains a different value, 
	    the ID Token is not Self-Issued, and instead 
	    it MUST be validated according to
	    <xref target="id.token.validation"/>.
	  </t>
	  <t>
	    The Client MUST validate that the 
	    <spanx style="verb">aud</spanx> (audience) Claim
	    contains the value of the <spanx style="verb">redirect_uri</spanx>
	    that the Client sent in the authentication request as an audience. 
	  </t>
	  <t>
	    The Client MUST validate the signature of the ID Token according to
	    <xref target="JWS">JWS</xref> using the algorithm specified in the 
	    <spanx style="verb">alg</spanx> parameter of the JWT header <xref target="JWT"/>,  
	    using the key in the <spanx style="verb">sub_jwk</spanx> Claim;
	    the key is a bare key in JWK format
	    (not an X.509 certificate value).
	  </t>
	  <t>
	    The <spanx style="verb">alg</spanx> value SHOULD be the default of 
	    <spanx style="verb">RS256</spanx>.
	    It MAY also be <spanx style="verb">ES256</spanx>.
	  </t>
	  <t>
	    The Client MUST validate that the <spanx style="verb">sub</spanx> (subject) Claim
	    value is the base64url encoded SHA-256 hash of 
	    the concatenation of the octets of the UTF-8 representations of
	    the base64url encoded key values in the
	    <spanx style="verb">sub_jwk</spanx> Claim.
	    When the <spanx style="verb">kty</spanx> value is
	    <spanx style="verb">RSA</spanx>, the key values
	    <spanx style="verb">n</spanx> and 
	    <spanx style="verb">e</spanx> are concatenated in that order.
	    When the <spanx style="verb">kty</spanx> value is
	    <spanx style="verb">EC</spanx>, the key values
	    <spanx style="verb">crv</spanx>,
	    <spanx style="verb">x</spanx>, and 
	    <spanx style="verb">y</spanx> are concatenated in that order.
	  </t>
	  <t>
	    The current time MUST be less than the value of the 
	    <spanx style="verb">exp</spanx> Claim
	    (possibly allowing for some small leeway to account for clock skew).
	  </t>
	  <t>
	    The <spanx style="verb">iat</spanx> Claim can be used to reject tokens that 
	    were issued too far away from the current time, limiting the amount of
	    time that nonces need to be stored to prevent attacks. 
	    The acceptable range is Client specific.
	  </t>
	  <t>
	    If a nonce value was sent in the Authorization Request, 
	    a <spanx style="verb">nonce</spanx> Claim MUST be present 
	    and its value of the checked to verify that
	    it is the same value as the one that was sent in the Authorization Request.
	    The Client SHOULD check the <spanx style="verb">nonce</spanx> value
	    for replay attacks.
	    The precise method for detecting replay attacks is Client specific.
	  </t>
	</list></t>
	<figure>
	  <preamble>The following is a non-normative example of a base64url decoded 
	  Self-Issued ID Token
	  (with line wraps within values for display purposes only):</preamble>

	  <artwork><![CDATA[
  {
   "iss": "https://self-issued.me",
   "sub": "wBy8QvHbPzUnL0x63h13QqvUYcOur1X0cbQpPVRqX5k",
   "aud": "https://client.example.org/cb",
   "nonce": "n-0S6_WzA2Mj",
   "exp": 1311281970,
   "iat": 1311280970,
   "sub_jwk": {
     "kty":"RSA",
     "n": "0vx7agoebGcQSuuPiLJXZptN9nndrQmbXEps2aiAFbWhM78LhWx
     4cbbfAAtVT86zwu1RK7aPFFxuhDR1L6tSoc_BJECPebWKRXjBZCiFV4n3oknjhMs
     tn64tZ_2W-5JsGY4Hc5n9yBXArwl93lqt7_RN5w6Cf0h4QyQ5v-65YGjQR0_FDW2
     QvzqY368QQMicAtaSqzs8KJZgnYb9c7d0zgdAZHzu6qMQvRL5hajrn1n91CbOpbI
     SD08qNLyrdkt-bFTWhAI4vMQFh6WeZu0fM4lFd2NcRwr3XPksINHaQ-G_xBniIqb
     w0Ls1jF44-csFCur-kEgU8awapJzKnqDKgw",
     "e":"AQAB" 
    }
  }
]]></artwork>
	</figure>

      </section>
    </section>

    <section anchor="Serializations" title="Serializations">
      <t>
	Messages are serialized using one of the following methods:
        <list style="numbers">
	  <t>Query String Serialization</t>
	  <t>Form Serialization</t>
	  <t>JSON Serialization</t>
        </list>
	Not all methods can be used for all messages.
      </t>

      <section anchor="qss" title="Query String Serialization">

        <t>In order to serialize the parameters using the Query String
        Serialization, the Client constructs the string by adding the
        parameters and values to the query component of a URL using the <spanx
        style="verb">application/x-www-form-urlencoded</spanx> format as
        defined by <xref target="W3C.REC-html401-19991224"></xref>.
	Query String Serialization is typically used in
	HTTP <spanx style="verb">GET</spanx> requests.
	The same serialization method is also used when adding
	parameters to the fragment component of a URL.
	</t>

        <figure>
          <preamble>
	    The following is a non-normative example of this serialization
	    (with line wraps within values for display purposes only):
	  </preamble>

          <artwork><![CDATA[
  GET /authorize?scope=openid&response_type=code
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb HTTP/1.1
  Host: server.example.com
]]></artwork>
        </figure>
      </section>

      <section anchor="form_serialization" title="Form Serialization">

        <t>Parameters and their values are Form Serialized by adding the 
        parameter names and values to the entity body of the HTTP request using
        the <spanx style="verb">application/x-www-form-urlencoded</spanx> format
        as defined by <xref target="W3C.REC-html401-19991224"></xref>.
	Form Serialization is typically used in HTTP <spanx style="verb">POST</spanx> requests.</t>

        <figure>
          <preamble>
	    The following is a non-normative example of this serialization
	    (with line wraps within values for display purposes only):
	  </preamble>

          <artwork><![CDATA[
  POST /authorize HTTP/1.1
  Host: server.example.com
  Content-Type: application/x-www-form-urlencoded

  scope=openid&response_type=code
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
]]></artwork>
        </figure>
      </section>

      <section anchor="js" title="JSON Serialization">
	<t>The parameters are serialized into a JSON structure by adding each
	parameter at the highest structure level. Parameter names and string
	values are included as JSON strings. Numerical values are included as
	JSON numbers. Each parameter MAY have a JSON structure as its value.</t>

	<figure>
          <preamble>
	    The following is a non-normative example of this serialization:
	  </preamble>

	  <artwork><![CDATA[
  {
   "access_token":"SlAV32hkKG",
   "expires_in":3600,
   "refresh_token":"8xLOxBtZp8"
  }
]]></artwork>
	</figure>
      </section>

    </section>

    <section anchor="stringops" title="String Operations">

      <t>
	Processing some OpenID Connect messages requires comparing
	values in the messages to known values. For example, the Claim
	Names returned by the UserInfo Endpoint might be compared to
	specific Claim Names such as <spanx
	style="verb">sub</spanx>.  Comparing Unicode strings,
	however, has significant security implications.
      </t>
      <t>
	Therefore, comparisons between JSON strings and other Unicode
	strings MUST be performed as specified below:

	<list style="numbers">

	  <t>
	    Remove any JSON applied escaping to produce an array of
	    Unicode code points.
	  </t>
	  <t>
	    <xref target="USA15">Unicode Normalization</xref> MUST NOT
	    be applied at any point to either the JSON string or to
	    the string it is to be compared against.
	  </t>
	  <t>
	    Comparisons between the two strings MUST be performed as a
	    Unicode code point to code point equality comparison.
	  </t>

	</list>
      </t>
      <t>
	In several places, this specification uses space delimited
	lists of strings.  In all such cases, only the ASCII space
	character (0x20) MAY be used for this purpose.
      </t>

    </section>

    <section anchor="ImplementationConsiderations" title="Implementation Considerations">
      <t>
	This specification defines features used by both Relying Parties and
	OpenID Providers.  Features that are mandatory to implement for
	Relying Parties are already described in the
	<xref target="OpenID.Basic">OpenID Connect Basic Client Profile 1.0</xref> and
	<xref target="OpenID.Implicit">OpenID Connect Implicit Client Profile 1.0</xref>
	specifications, and so are not discussed again here.
      </t>
      <t>
	It is expected that some OpenID Providers will require
	static, out-of-band configuration of RPs using them,
	whereas others will support dynamic usage by RPs without
	a pre-established relationship between them.
	For that reason, the mandatory-to-implement features for OPs
	are listed below in two groups:
	the first for all OPs and the second for "Dynamic" OpenID Providers.
      </t>

      <section anchor="ServerMTI"
	       title="Mandatory to Implement Features for All OpenID Providers">
	<t>
	  All OpenID Providers MUST implement the following features defined in this specification.
	  This list augments the set of features that are already listed elsewhere
	  as being "REQUIRED" or are described with a "MUST",
	  and so is not, by itself, a comprehensive set of implementation requirements for OPs.
	</t>
	<t>
	  <list style="hanging">

	    <t hangText="Signing ID Tokens with RSA SHA-256">
	      OPs MUST support signing ID Tokens with the RSA SHA-256 algorithm
	      (an <spanx style="verb">alg</spanx> value of <spanx style="verb">RS256</spanx>).
	    </t>
	    <t hangText="Prompt Parameter">
	      OPs MUST support the <spanx style="verb">prompt</spanx> parameter,
	      as defined in <xref target="RequestParameters"/>, including the specified
	      user interface behaviors such as <spanx style="verb">none</spanx>
	      and <spanx style="verb">login</spanx>.
	    </t>
	    <t hangText="Display Parameter">
	      OPs MUST support the <spanx style="verb">display</spanx> parameter,
	      as defined in <xref target="RequestParameters"/>.
	      (Note that the minimum level of support required for this parameter is
	      simply to have its use not result in an error.)
	    </t>
	    <t hangText="Preferred Locales">
	      OPs MUST support requests for preferred languages and scripts
	      for the user interface and for Claims via the
	      <spanx style="verb">ui_locales</spanx> and
	      <spanx style="verb">claims_locales</spanx> request parameters,
	      as defined in <xref target="RequestParameters"/>.
	      (Note that the minimum level of support required for these parameters is
	      simply to have their use not result in errors.)
	    </t>
	    <t hangText="Authentication Time">
	      OPs MUST support returning the time at which the End-User authenticated
	      via the <spanx style="verb">auth_time</spanx> Claim,
	      as defined in <xref target="id_token"/>.
	    </t>
	    <t hangText="Maximum Authentication Age">
	      OPs MUST support enforcing a maximum authentication age
	      via the <spanx style="verb">max_age</spanx> parameter,
	      as defined in <xref target="RequestParameters"/>.
	    </t>
	    <t hangText="Authentication Context Class Reference">
	      OPs MUST support requests for specific
	      Authentication Context Class Reference values
	      via the <spanx style="verb">acr_values</spanx> parameter,
	      as defined in <xref target="RequestParameters"/>.
	      (Note that the minimum level of support required for this parameter is
	      simply to have its use not result in an error.)
	    </t>

	  </list>
	</t>
      </section>

      <section anchor="DynamicMTI"
	       title="Mandatory to Implement Features for Dynamic OpenID Providers">
	<t>
	  In addition to the features listed above,
	  OpenID Providers supporting dynamic establishment of relationships with RPs
	  that they do not have a pre-configured relationship with
	  MUST also implement the following features defined in this and related specifications.
	</t>
	<t>
	  <list style="hanging">

	    <t hangText="Discovery">
	      These OPs MUST support Discovery,
	      as defined in
	      <xref target="OpenID.Discovery">OpenID Connect Discovery 1.0</xref>.
	    </t>
	    <t hangText="Dynamic Registration">
	      These OPs MUST support Dynamic Client Registration,
	      as defined in
	      <xref target="OpenID.Registration">OpenID Connect Dynamic Client Registration 1.0</xref>.
	    </t>
	    <t hangText="UserInfo Endpoint">
	      All dynamic OPs that issue Access Tokens MUST support the UserInfo Endpoint,
	      as defined in <xref target="userinfo"/>.
	      (Self-Issued OPs do not issue Access Tokens.)
	    </t>
	    <t hangText="Public Keys Published as Bare Keys">
	      These OPs MUST publish their public keys as bare keys,
	      rather than in X.509 format.
	    </t>
	    <t hangText="Request URI">
	      These OPs MUST support requests made using a Request Object value
	      that is retrieved from a Request URI that is provided
	      with the <spanx style="verb">request_uri</spanx> parameter,
	      as defined in <xref target="RequestParameters"/>.
	    </t>

	  </list>
	</t>
      </section>

      <section anchor="disco_reg" title="Discovery and Registration">

	<t>Some OpenID Connect installations can use a pre-configured set of
	OpenID Providers and/or Relying Parties. In those cases, it might not be
	necessary to support dynamic discovery of information about identities
	or services or dynamic registration of Clients.</t>

	<t>However, if installations choose to support unanticipated
	interactions between Relying Parties and OpenID Providers that do not
	have pre-configured relationships, they SHOULD accomplish this by
	implementing the facilities defined in the <xref
	target="OpenID.Discovery">OpenID Connect Discovery 1.0</xref> and <xref
	target="OpenID.Registration">OpenID Connect Dynamic Client Registration
	1.0</xref> specifications.</t>
      </section>

      <section anchor="related" title="Related Specifications">

	<t>These related OpenID Connect specifications MAY OPTIONALLY be used in
	combination with this specification to provide additional functionality:
	<list style="symbols">

	  <t><xref target="OpenID.Discovery">OpenID Connect Discovery
	  1.0</xref> - Dynamic discovery for user and Authorization Server 
	  endpoints and information</t>

	  <t><xref target="OpenID.Registration">OpenID Connect Dynamic Client
	  Registration 1.0</xref> - Dynamic registration of OpenID Connect
	  Clients with OpenID Providers</t>

	  <t><xref target="OpenID.Basic">OpenID Connect Basic Client Profile 1.0</xref> -
	  Protocol binding for a subset of the OpenID Connect Messages
	  that is intended for use by basic
	  Web-based Relying Parties using the
	  OAuth <spanx style="verb">authorization_code</spanx> grant type.</t>

	  <t><xref target="OpenID.Implicit">OpenID Connect Implicit Client Profile 1.0</xref> -
	  Protocol binding for a subset of the OpenID Connect Messages
	  that is intended for use by basic
	  Web-based Relying Parties using the OAuth implicit grant type.</t>

	  <t><xref target="OpenID.Session">OpenID Connect Session Management
	  1.0</xref> - Session management for OpenID Connect sessions</t>
	</list></t>
      </section>
    </section>

    <section anchor="security_considerations" title="Security Considerations">
      <t>
	This specification references the security considerations defined in
	Section 10 of <xref target="RFC6749">OAuth 2.0</xref>, and
	Section 5 of <xref target="RFC6750">OAuth 2.0 Bearer Token Usage</xref>.
	Furthermore, the <xref target="RFC6819">OAuth 2.0 Threat Model and Security
	Considerations</xref> specification provides an extensive list of threats and controls 
	that apply to this specification as well,
	given that it is based upon OAuth 2.0.
	<xref target="ISO29115">ISO/IEC 29115</xref> 
	also provides threats and controls that 
	implementers need to take into account. 
	Implementers are highly advised to
	read these references in detail and apply the countermeasures described therein.
      </t>

      <t>
	In addition, the following list of attack vectors and remedies are
	also considered.
      </t>

      <section anchor="request_disclosure" title="Request Disclosure">
	<t>If appropriate measures are not taken, a request might be disclosed to 
	an attacker, posing security and privacy threats.</t>
	<t>In addition to what is stated in Section 5.1.1 of <xref target="RFC6819" />, 
	this standard provides a way to provide the confidentiality of the request 
	end to end through the 
	use of <spanx style="verb">request</spanx> or <spanx style="verb">request_uri</spanx>
	parameters, where the content of the <spanx style="verb">request</spanx>
	is an encrypted JWT with the appropriate key and cipher.  
	This protects even against a compromised User-Agent
	in the case of indirect request.</t>
      </section>

      <section anchor="server_masquerading" title="Server Masquerading">
	<t>A malicious Server might masquerade as the legitimate server 
	using various means. To detect such an attack, the Client needs to authenticate 
	the server. </t>
	<t>In addition to what is stated in Section 5.1.2 of <xref target="RFC6819" />, 
	this standard provides a way to authenticate the Server through either the 
	use of Signed or Encrypted JWTs 
	with an appropriate key and cipher.</t> 
      </section>

      <section anchor="token_manufacture"
	       title="Token Manufacture/Modification">
	<t>An Attacker might generate a bogus token or modify the token content 
	(such as the authentication or 
	attribute statements) of an existing parseable token, causing the RP to grant 
	inappropriate access to the Client. For example, an Attacker might modify 
	the parseable token to extend the validity period; a Client might modify the 
	parseable token to have access to information that they should not be able to view.
	</t>
	<t>There are two ways to mitigate this attack:</t>

	<t><list style="numbers">
	  <t>The token can be digitally signed by the OP. The Relying
	  Party SHOULD validate the digital signature to verify that it was
	  issued by a legitimate OP.</t>

	  <t>The token can be sent over a protected channel such as TLS.
	  See <xref target="TLS_requirements"/> for more information on using TLS.
	  In this specification, the token is always sent over a TLS protected channel.
	  Note however, that this measure is only a defense against third party attackers
	  and is not applicable to the case where the Client is the attacker.</t>
	</list></t>
      </section>

      <section anchor="response_disclosure" title="Server Response Disclosure">
	<t>The server response might contain authentication and attribute 
	statements that include sensitive Client information. Disclosure of the 
	response contents can make the Client vulnerable to other types of 
	attacks.</t>

	<t>The server response disclosure can be mitigated in the following two
	ways:
	<list style="numbers">
	  <t>Using the <spanx style="verb">code</spanx> response type.
	  The response is sent over a TLS protected 
	  channel, where the Client is authenticated by the
	  <spanx style="verb">client_id</spanx> and 
	  <spanx style="verb">client_secret</spanx>.</t>

	  <t>For other response types,
	  the signed response can be encrypted with the Client's 
	  public key or a shared secret as an encrypted JWT
	  with an appropriate key and cipher.</t>
	</list></t>
      </section>

      <section anchor="server_response_repudiation" title="Server Response Repudiation">
	<t>A response might be repudiated by the server if the proper mechanisms are not in place. 
	For example, if a Server does not digitally sign a response, the Server can claim that it was not 
	generated through the services of the Server.</t>

	<t>To mitigate this threat, the response MAY be digitally signed by
	the Server using a key that supports non-repudiation. The Client SHOULD validate
	the digital signature to verify that it was issued by a legitimate
	Server and its integrity is intact.</t>
      </section>

      <section anchor="request_repudation" title="Request Repudiation">
	<t>Since it is possible for a 
	compromised or malicious Client to send a request to the wrong party,  
	a Client that was authenticated 
	using only a bearer token can repudiate any transaction.
	</t>
	<t>To mitigate this threat, the Server MAY require that the
	request be digitally signed by
	the Client using a key that supports non-repudiation. 
	The Server SHOULD validate
	the digital signature to verify that it was issued by a legitimate
	Client and the integrity is intact.</t>
      </section>

      <section anchor="access_token_redirect" title="Access Token Redirect">
	<t>An Attacker uses the Access Token generated for one resource to 
	obtain access to a second resource.
	</t>
	<t>To mitigate this threat, the Access Token SHOULD be audience 
	and scope restricted. One way of implementing it is to include
	the identifier of the resource for whom it was generated as audience. 
	The resource verifies that
	incoming tokens include its identifier as the audience of the
	token.</t>
      </section>

      <section anchor="token_reuse" title="Token Reuse">
	<t>An Attacker attempts to use a one-time use token such as
	an Authorization Code that has already
	been used once with the intended Resource.
	To mitigate this threat, the token SHOULD include a timestamp 
	and a short validity lifetime.
	The Relying Party then checks the timestamp and lifetime values
	to ensure that the token is currently valid.</t>

	<t>Alternatively, the server MAY record the state of the use of 
	the token and check the status for each request. </t>
      </section>

      <section anchor="auth_code_capture"
	       title=" Eavesdropping or Leaking Authorization Codes (Secondary Authenticator Capture)">
	<t>In addition to the attack patterns described in
	Section 4.4.1.1 of <xref target="RFC6819"/>,
	an Authorization Code can be captured in the User-Agent where the TLS
	session is terminated if the User-Agent is infected by malware.
	However, capturing it is not useful as long as the profile
	uses either Client authentication or an encrypted response.</t>
      </section>

      <section anchor="token_substitution" title="Token Substitution">
	<t>
	  Token Substitution is a class of attacks in which a malicious user
	  swaps various tokens, including swapping an Authorization Code for
	  a legitimate user with another token that the attacker has.
	  One means of accomplishing this is for the attacker to copy
	  a token out one session and use it in an HTTP message for
	  a different session, which is easy to do when the token is
	  available to the browser; this is known as the "cut and paste" attack.
	</t>
	<t>
	  The implicit flow of <xref target="RFC6749">OAuth 2.0</xref>
	  is not designed to mitigate this risk.  In Section 10.16,
	  it normatively requires that any use of the authorization
	  process as a form of delegated End-User authentication to the
	  Client MUST NOT use the implicit flow without employing
	  additional security mechanisms that enable the Client to
	  determine whether the Access Token was issued for its use.
	</t>
	<t>
	  In OpenID Connect, this is mitigated through mechanisms
	  provided through the ID Token.  The ID Token is a signed
	  security token that provides Claims such as
	  <spanx style="verb">iss</spanx> (issuer),
	  <spanx style="verb">sub</spanx> (subject),
	  <spanx style="verb">aud</spanx> (audience),
	  <spanx style="verb">azp</spanx> (authorized party),
	  <spanx style="verb">at_hash</spanx> (access token hash), and
	  <spanx style="verb">c_hash</spanx> (code hash).  Using the ID Token,
	  the Client is capable of detecting the Token Substitution Attack.
	</t>
	<t>
	  The <spanx style="verb">c_hash</spanx> in the ID Token enables
	  Clients to prevent <spanx style="verb">code</spanx> substitution.
	</t>
	<t>
	  Also, a malicious user may attempt to impersonate a more
	  privileged user by subverting the communication channel
	  between the Authorization Endpoint and Client, or the Token Endpoint
	  and Client, for example by swapping the <spanx style="verb">code</spanx>
	  or reordering the messages, to convince the Token Endpoint
	  that the attacker's authorization grant corresponds to a grant
	  sent on behalf of a more privileged user.
	</t>
	<t>
	  For HTTP bindings such as OpenID Connect Standard 1.0, the
	  responses to Token Requests are bound to the corresponding
	  requests by message order in HTTP, as both the response
	  containing the token and requests are protected by TLS, which
	  will detect and prevent packet reordering.
	</t>
	<t>
	  When designing another binding of OpenID Connect Messages to a
	  protocol incapable of strongly binding Token Endpoint
	  requests to responses, additional mechanisms to
	  address this issue MUST be utilized. One such mechanism could
	  be to include an ID Token with a <spanx style="verb">c_hash</spanx>
	  Claim in the token request and response.
	</t>
      </section>

      <section anchor="TimingAttack" title="Timing Attack">
	<t>A timing attack allows the attacker to 
	obtain an unnecessary large amount of information through the elapsed time 
	differences in the code paths taken by successful and unsuccessful decryption operations or
	successful and unsuccessful signature validation of a message. 
	It can be used to reduce the effective key length of the
	cipher used. </t>
	<t>Implementations SHOULD NOT terminate the validation process 
	at the instant of the finding an error but SHOULD continue 
	running until all the octets have been processed to avoid this attack.</t>
      </section>

      <section anchor="OtherCryptoAttacks" title="Other Crypto Related Attacks">
	<t>There are various crypto related attacks possible depending on the 
	method used for encryption and signature / integrity checking.
	Implementers need to consult the Security Considerations
	for the <xref target="JWT">JWT</xref> specification and
	specifications that it references
	to avoid the vulnerabilities
	identified in these specifications. 
	</t>
      </section>

      <section anchor="signing_order" title="Signing and Encryption Order">
	<t>Signatures over encrypted text are not considered valid
	in many jurisdictions.
	Therefore, for integrity and non-repudiation,
	this specification requires signing 
	the plain text JSON Claims.</t>
      </section>

      <section anchor="issuer_identifier" title="Issuer Identifier">
	<t>OpenID Connect supports multiple issuers per Host and Port combination.
	The issuer returned by discovery MUST exactly match the value of 
	<spanx style="verb">iss</spanx> in the ID Token.</t>

	<t>OpenID Connect treats the path component of any URI as
	part of the user identifier.  For instance, the subject
	"1234" with an issuer of "https://example.com" is not
	equivalent to the subject "1234" with an issuer of
	"https://example.com/sales".
	</t>

	<t>It is RECOMMENDED that only a single issuer per host be used.</t>
      </section>		

      <section anchor="ImplicitGrantFlowThreats" title="Implicit Grant Flow Threats">
        <t>In the implicit grant flow, the Access Token is returned in the
        fragment component of the Client's <spanx style="verb">redirect_uri</spanx> through HTTPS, thus it is
        protected between the OP and the User-Agent, and User-Agent and the
        RP. The only the place it can be captured is the User-Agent where the
        TLS session is terminated, and is possible if the User-Agent is
        infested by malware.</t>
      </section>

      <section anchor="TLS_requirements" title="TLS Requirements">
	<t>
	  Implementations MUST support TLS.
	  Which version(s) ought to be implemented will vary over
	  time, and depend on the widespread deployment and known
	  security vulnerabilities at the time of implementation.
	  At the time of this writing,
	  TLS version 1.2 <xref target='RFC5246' />
	  is the most recent version, but has very limited actual
	  deployment, and might not be readily available in
	  implementation toolkits.
	  TLS version 1.0 <xref target='RFC2246' />
	  is the most widely deployed version, and will give the
	  broadest interoperability.
	</t>
	<t>
	  To protect against information disclosure and tampering,
	  confidentiality protection MUST be applied using TLS
	  with a ciphersuite that provides confidentiality and
	  integrity protection.
	</t>
	<t>
	  Whenever TLS is used, a TLS server certificate check
	  MUST be performed, per <xref target="RFC6125">RFC 6125</xref>.
	</t>
      </section>
      <section anchor="token_lifetime" title="Lifetimes of Access Tokens and Refresh Tokens">
	<t>Access Token grants are not revocable by the Authorization Server. 
	Access Token grant lifetimes SHOULD be kept to single use or 
	very short lifetimes.</t>
	<t>If access to the UserInfo Endpoint or other protected resources is required,
	a Refresh Token SHOULD be used. The Client MAY then exchange the Refresh Token at
	the Token Endpoint for a fresh short-lived Access Token that can be used to 
	access the resource.</t>

	<t>
	  The Authorization Server SHOULD clearly identify long-term grants to the User
	  during Authorization.
	  The Authorization Server SHOULD provide a mechanism for the End-User to revoke
	  Refresh Tokens granted to a Client.
	</t>
      </section>

      <section anchor="SymmetricKeyEntropy" title="Symmetric Key Entropy">
	<t>
	  In <xref target="sigs"/> and <xref target="enc"/>, keys are derived
	  from the <spanx style="verb">client_secret</spanx> value.
	  Thus, when used with symmetric signing or encryption operations,
	  <spanx style="verb">client_secret</spanx> values MUST contain
	  sufficient entropy to generate cryptographically strong keys.
	  Also, <spanx style="verb">client_secret</spanx> values MUST also contain
	  at least the minimum of number of octets required for MAC keys for the
	  particular algorithm used.
	  So for instance, for <spanx style="verb">HS256</spanx>, the
	  <spanx style="verb">client_secret</spanx> value MUST contain
	  at least 8 octets (and almost certainly SHOULD contain more,
	  since <spanx style="verb">client_secret</spanx> values are
	  likely to use a restricted alphabet.
	</t>
      </section>

      <section anchor="NeedForSignedRequests" title="Need for Signed Requests">
	<t>
	  In some situations, Clients might need to use signed requests to ensure that
	  the desired request parameters are delivered to the OP without having
	  been tampered with.  For instance, the <spanx style="verb">max_age</spanx>
	  and <spanx style="verb">acr_values</spanx> provide more assurance about
	  the nature of the authentication performed when delivered in signed requests.
	</t>
      </section>

      <section anchor="NeedForEncryptedRequests" title="Need for Encrypted Requests">
	<t>
	  In some situations, knowing the contents of an OpenID Connect request can,
	  in and of itself, reveal sensitive information about the End-User.
	  For instance, knowing that the Client is requesting a particular Claim or
	  that it is requesting that a particular authentication method be used
	  can reveal sensitive information about the End-User.
	  OpenID Connect enables requests to be encrypted to the OpenID Provider
	  to prevent such potentially sensitive information from being revealed.
	</t>
      </section>
    </section>
    <section anchor="privacy_considerations" title="Privacy Considerations">

      <section anchor="PII" title="Personally Identifiable Information">

	<t>The UserInfo Response typically contains Personally Identifiable
	Information (PII). As such, End-User consent for the release of the information
	for the specified purpose SHOULD be obtained at or prior to the
	authorization time in accordance with relevant regulations. The purpose
	of use is typically registered in association with the <spanx
	style="verb">redirect_uris</spanx>.</t>

	<t>Only necessary UserInfo data should be stored at the Client and the
	Client SHOULD associate the received data with the purpose of use
	statement.</t>
      </section>

      <section anchor="AccessMonitoring" title="Data Access Monitoring">
	<t>The Resource Server SHOULD make the UserInfo access log available to 
	the End-User so that the End-User can monitor who accessed his data.</t>
      </section>

      <section anchor="Correlation" title="Correlation">
	<t>To protect the End-User from a possible correlation among Clients, the
	use of a Pairwise Pseudonymous Identifier (PPID) as the
	<spanx style="verb">sub</spanx> (subject) SHOULD be considered.</t>
      </section>

      <section anchor="OfflineAccessPrivacy" title="Offline Access">

	<t>
	  Offline access enables access to Claims when the user is not present,
	  posing greater privacy risk than the Claims transfer when the user is present.
	  Therefore, it is prudent to obtain explicit consent for
	  offline access to resources.
	  This specification mandates the use of the <spanx style="verb">prompt</spanx>
	  parameter to obtain consent unless it is a priori known that the
	  request complies with the conditions for processing in each jurisdiction.
	</t>
	<t>
	  When an Access Token is returned in the front channel, there is
	  a greater risk of it being exposed to an attacker, who could
	  later use it to access the UserInfo endpoint.
	  If the Access Token does not enable offline access and the server
	  can differentiate whether the Client request has been made
	  offline or online, the risk will be substantially reduced.
	  Therefore, this specification mandates ignoring
	  the offline access request when the Access Token is
	  transmitted in the front channel.
	  Note that differentiating between online and offline access
	  from the server can be difficult especially for native clients.
	  The server may well have to rely on heuristics.
	  Also, the risk of exposure for the Access Token delivered
	  in the front channel for the response types of
	  <spanx style="verb">code&nbsp;token</spanx> and
	  <spanx style="verb">token</spanx> is the same.
	  Thus, the implementations should be prepared to detect the
	  channel from which the Access Token was issued and deny offline access
	  if the token was issued in the front channel.
	</t>
	<t>
	  Note that although these provisions require an explicit
	  consent dialogue through the <spanx style="verb">prompt</spanx> parameter,
	  the mere fact that the user pressed an "accept" button etc.,
	  might not constitute a valid consent.
	  Developers should be aware that for the act of consent to
	  be valid, typically, the impact of the terms have to be
	  understood by the End-User, the consent must be freely given
	  and not forced (i.e., other options have to be available),
	  and the terms must fair and equitable.
	  In general, it is advisable for the service to follow the
	  required privacy principles in each jurisdiction and rely on
	  other conditions of processing than simply explicit consent,
	  as online self-service "explicit consent" often does not
	  form a valid consent in some jurisdictions.
	</t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">

      <section anchor="ClaimsRegistry" title="JSON Web Token Claims Registry">
	<t>
	  This specification registers the Claims defined in
	  <xref target="StandardClaims"/> and <xref target="id_token"/> in the IANA
	  JSON Web Token Claims registry
	  defined in <xref target="JWT"/>.
	</t>

	<section anchor='ClaimsContents' title='Registry Contents'>
	  <t> <?rfc subcompact="yes"?>
	  <list style='symbols'>
	    <t>
	      Claim Name: <spanx style="verb">name</spanx>
	    </t>
	    <t>
	      Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	    </t>
	    <t>
	      Specification Document(s): <xref target="StandardClaims"/> of this document
	    </t>
	  </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">given_name</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">family_name</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">middle_name</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">nickname</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">preferred_username</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">profile</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">picture</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">website</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">email</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">email_verified</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">gender</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">birthdate</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">zoneinfo</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">locale</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">phone_number</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">address</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">updated_at</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="StandardClaims"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">azp</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="id_token"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">nonce</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="id_token"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">auth_time</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="id_token"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">at_hash</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="id_token"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">c_hash</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="id_token"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">acr</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="id_token"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">amr</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="id_token"/> of this document
	      </t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>
		Claim Name: <spanx style="verb">sub_jwk</spanx>
	      </t>
	      <t>
		Change Controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net
	      </t>
	      <t>
		Specification Document(s): <xref target="id_token"/> of this document
	      </t>
	    </list>
	  </t>
	</section>
	<?rfc subcompact="no"?>
      </section>

      <section anchor="OAuthParametersRegistry" title="OAuth Parameters Registry">

	<t>
	  This specification registers the following parameters
	  in the IANA
	  OAuth Parameters registry
	  defined in <xref target="RFC6749">RFC 6749</xref>.
	</t>

	<section anchor='ParametersContents' title='Registry Contents'>
	  <t> <?rfc subcompact="yes"?>
	  <list style="symbols">
	    <t>Parameter name: <spanx style="verb">nonce</spanx></t>

	    <t>Parameter usage location: Authorization Request</t>

	    <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	    <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	    <t>Related information: None</t>
	  </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">display</spanx></t>

	      <t>Parameter usage location: Authorization Request</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">prompt</spanx></t>

	      <t>Parameter usage location: Authorization Request</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">max_age</spanx></t>

	      <t>Parameter usage location: Authorization Request</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">ui_locales</spanx></t>

	      <t>Parameter usage location: Authorization Request</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">claims_locales</spanx></t>

	      <t>Parameter usage location: Authorization Request</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">id_token_hint</spanx></t>

	      <t>Parameter usage location: Authorization Request</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">login_hint</spanx></t>

	      <t>Parameter usage location: Authorization Request</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">acr_values</spanx></t>

	      <t>Parameter usage location: Authorization Request</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">claims</spanx></t>

	      <t>Parameter usage location: Authorization Request</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">registration</spanx></t>

	      <t>Parameter usage location: Authorization Request</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">request</spanx></t>

	      <t>Parameter usage location: Authorization Request</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">request_uri</spanx></t>

	      <t>Parameter usage location: Authorization Request</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="RequestParameters"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Parameter name: <spanx style="verb">id_token</spanx></t>

	      <t>Parameter usage location: Authorization Response,
	      Access Token Response</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="access_token_response"/> of this document</t>

	      <t>Related information: None</t>
	    </list>
	  </t>
	</section>
	<?rfc subcompact="no"?>

      </section>

      <section anchor="OAuthErrorRegistry" title="OAuth Extensions Error Registry">

	<t>
	  This specification registers the following errors
	  in the IANA
	  OAuth Extensions Error registry
	  defined in <xref target="RFC6749">RFC 6749</xref>.
	</t>

	<section anchor='ErrorContents' title='Registry Contents'>
	  <t> <?rfc subcompact="yes"?>
	    <list style="symbols">
	      <t>Error name: <spanx style="verb">interaction_required</spanx></t>

	      <t>Error usage location: Authorization Endpoint</t>

	      <t>Related protocol extension: OpenID Connect</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="AuthError"/> of this document</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Error name: <spanx style="verb">login_required</spanx></t>

	      <t>Error usage location: Authorization Endpoint</t>

	      <t>Related protocol extension: OpenID Connect</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="AuthError"/> of this document</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Error name: <spanx style="verb">session_selection_required</spanx></t>

	      <t>Error usage location: Authorization Endpoint</t>

	      <t>Related protocol extension: OpenID Connect</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="AuthError"/> of this document</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Error name: <spanx style="verb">consent_required</spanx></t>

	      <t>Error usage location: Authorization Endpoint</t>

	      <t>Related protocol extension: OpenID Connect</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="AuthError"/> of this document</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Error name: <spanx style="verb">invalid_request_uri</spanx></t>

	      <t>Error usage location: Authorization Endpoint</t>

	      <t>Related protocol extension: OpenID Connect</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="AuthError"/> of this document</t>
	    </list>
	  </t>

	  <t>
	    <list style="symbols">
	      <t>Error name: <spanx style="verb">invalid_request_object</spanx></t>

	      <t>Error usage location: Authorization Endpoint</t>

	      <t>Related protocol extension: OpenID Connect</t>

	      <t>Change controller: OpenID Foundation Artifact Binding Working Group - openid-specs-ab@lists.openid.net</t>

	      <t>Specification document(s): <xref target="AuthError"/> of this document</t>
	    </list>
	  </t>

	</section>
	<?rfc subcompact="no"?>

      </section>
    </section>

  </middle>

  <back>
    <references title="Normative References">
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2246"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3966"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5322"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5646"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6125"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6711"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6749"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6750"?>
      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6819"?>

      <?rfc include='http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-html401-19991224.xml' ?>

      <reference anchor="USA15">
	<front>
	  <title>Unicode Normalization Forms</title>

	  <author fullname="Mark Davis" initials="M." surname="Davis">
	    <address>
	      <email>markdavis@google.com</email>
	    </address>
	  </author>

	  <author fullname="Ken Whistler" initials="K." surname="Whistler">
	    <address>
	      <email>ken@unicode.org</email>
	    </address>
	  </author>

	  <author fullname="Martin D&uuml;rst" initials="M." surname="D&uuml;rst">
	  </author>

	  <date day="03" month="09" year="2009" />
	</front>

	<seriesInfo name="Unicode Standard Annex" value="15" />
      </reference>

      <reference anchor="OpenID.Discovery">
	<front>
	  <title>OpenID Connect Discovery 1.0</title>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	  </author>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	  </author>

	  <author fullname="Edmund Jay" initials="E." surname="Jay">
	    <organization abbrev="Illumila">Illumila</organization>
	  </author>

	  <date day="5" month="July" year="2013"/>
	</front>

	<format target="http://openid.net/specs/openid-connect-discovery-1_0-17.html"
		type="HTML" />
      </reference>

      <reference anchor="OpenID.Registration">
	<front>
	  <title>OpenID Connect Dynamic Client Registration 1.0</title>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	  </author>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	  </author>

	  <date day="5" month="July" year="2013"/>
	</front>

	<format target="http://openid.net/specs/openid-connect-registration-1_0-19.html"
		type="HTML" />
      </reference>

      <reference anchor="JWT">
	<front>
	  <title>JSON Web Token (JWT)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	  </author>

	  <date day="28" month="May" year="2013" />
	</front>

	<seriesInfo value="draft-ietf-oauth-json-web-token" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-oauth-json-web-token-08"
		type="HTML" />
      </reference>

      <reference anchor="JWS">
	<front>
	  <title>JSON Web Signature (JWS)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	  </author>

	  <date day="28" month="May" year="2013" />
	</front>

	<seriesInfo value="draft-ietf-jose-json-web-signature" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-signature-11"
		type="HTML" />
      </reference>

      <reference anchor="JWE">
	<front>
	  <title>JSON Web Encryption (JWE)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	  </author>

	  <author fullname="Eric Rescorla" initials="E." surname="Rescorla">
	    <organization>RTFM, Inc.</organization>
	  </author>

	  <author fullname="Joe Hildebrand" initials="J." surname="Hildebrand">
	    <organization>Cisco Systems, Inc.</organization>
	  </author>

	  <date day="28" month="May" year="2013" />
	</front>

	<seriesInfo value="draft-ietf-jose-json-web-encryption" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-encryption-11" type="HTML" />
      </reference>

      <reference anchor="JWK">
	<front>
	  <title>JSON Web Key (JWK)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	  </author>

	  <date day="28" month="May" year="2013" />
	</front>

	<seriesInfo value="draft-ietf-jose-json-web-key" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-key-11" type="HTML" />
      </reference>

      <reference anchor="JWA">
	<front>
	  <title>JSON Web Algorithms (JWA)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization>Microsoft</organization>
	  </author>

	  <date day="28" month="May" year="2013" />
	</front>

	<seriesInfo value="draft-ietf-jose-json-web-algorithms" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-11" type="HTML" />
      </reference>

      <reference anchor="OAuth.JWT">
	<front>
	  <title abbrev="OAuth JWT Bearer Token Profiles">JSON Web Token (JWT) Bearer Token Profiles for OAuth 2.0</title>

	  <author fullname="Michael B. Jones" surname="Jones" initials="M.B."> <!-- role="editor" -->
	    <organization>Microsoft</organization>
	  </author>

	  <author fullname="Brian Campbell" initials="B." surname="Campbell">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	  </author>

	  <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
	    <organization>Salesforce</organization>
	  </author>

	  <date day="29" month="March" year="2013"/>
	</front>

	<seriesInfo value="draft-ietf-oauth-jwt-bearer" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-05"
		type="HTML" />
      </reference>

      <reference anchor="OAuth.Assertions">
	<front>
	  <title abbrev='oauth-assertions'>Assertion Framework for OAuth 2.0</title>

	  <author fullname="Brian Campbell" initials="B." surname="Campbell">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	  </author>

	  <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
	    <organization abbrev="Salesforce">Salesforce.com</organization>
	  </author>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	  </author>

	  <author fullname="Yaron Y. Goland" initials="Y.Y." surname="Goland">
	    <organization abbrev="Microsoft">Microsoft</organization>
	  </author>

	  <date day="29" month="March" year="2013"/>
	</front>

	<seriesInfo value="draft-ietf-oauth-assertions" name="Internet-Draft"/>
	<format target="http://tools.ietf.org/html/draft-ietf-oauth-assertions-11"
		type="HTML" />
      </reference>

      <reference anchor="ISO29115">
	<front>
	  <title>ISO/IEC 29115:2013 --
	  Information technology - Security techniques - Entity authentication
	  assurance framework</title>

	  <author fullname="International Organization for Standardization">
	    <organization abbrev="ISO">International Organization for Standardization</organization>
	  </author>

	  <date month="March" year="2013" />
	</front>

	<seriesInfo name="ISO/IEC" value="29115" />
	<format target="http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=45138"
		type="HTML" />
      </reference>

      <reference anchor="ISO639-1">
	<front>
	  <title>ISO 639-1:2002. Codes for the representation of names of
	  languages -- Part 1: Alpha-2 code</title>

	  <author fullname="International Organization for Standardization">
	    <organization abbrev="ISO">International Organization for
	    Standardization</organization>
	  </author>

	  <date year="2002" />
	</front>
      </reference>

      <reference anchor="ISO3166-1">
	<front>
	  <title>ISO 3166-1:1997. Codes for the representation of names of
	  countries and their subdivisions -- Part 1: Country codes</title>

	  <author fullname="International Organization for Standardization">
	    <organization abbrev="ISO">International Organization for
	    Standardization</organization>
	  </author>

	  <date year="1997" />
	</front>

	<format target="http://www.w3.org/WAI/ER/IG/ert/iso639.htm"
		type="HTML" />
      </reference>

      <reference anchor="ISO8601-2004">
	<front>
	  <title>ISO 8601:2004. Data elements and interchange formats - Information interchange -
	  Representation of dates and times</title>

	  <author fullname="International Organization for Standardization">
	    <organization abbrev="ISO">International Organization for
	    Standardization</organization>
	  </author>

	  <date year="2004" />
	</front>
      </reference>

      <reference anchor="E.164">
	<front>
	  <title>E.164: The international public telecommunication numbering plan</title>

	  <author fullname="International Telecommunication Union">
	    <organization abbrev="ITU">International Telecommunication Union</organization>
	  </author>

	  <date year="2010" />
	</front>

	<format target="http://www.itu.int/rec/T-REC-E.164-201011-I/en"
		type="HTML" />
      </reference>

      <reference anchor="zoneinfo">
	<front>
	  <title>The tz database</title>

	  <author fullname="Public Domain">
	    <organization abbrev="Public">Public Domain</organization>
	  </author>

	  <date month="June" year="2011" />
	</front>

	<format target="http://www.twinsun.com/tz/tz-link.htm" type="HTML" />
      </reference>

      <reference anchor="OAuth.Responses">
        <front>
	  <title>OAuth 2.0 Multiple Response Type Encoding Practices</title>

	  <author fullname="Breno de Medeiros" initials="B." role="editor" surname="de Medeiros">
	    <organization abbrev="Google">Google</organization>
	  </author>

	  <author fullname="Marius Scurtescu" initials="M." surname="Scurtescu">
	    <organization abbrev="Google">Google</organization>
	  </author>

	  <author fullname="Paul Tarjan" initials="P." surname="Tarjan">
	    <organization abbrev="Facebook"> Facebook</organization>
	  </author>

	  <date day="7" month="June" year="2013" />
        </front>

	<format target="http://openid.net/specs/oauth-v2-multiple-response-types-1_0-08.html"
		type="HTML" />
      </reference>

      <reference anchor="IANA.Language">
        <front>
          <title>Language Subtag Registry</title>
          <author>
            <organization>Internet Assigned Numbers Authority (IANA)</organization>
          </author>
	  <date year="2005"/>
        </front>

	<format target="http://www.iana.org/assignments/language-subtag-registry"
		type="TXT" />
      </reference>

      <reference anchor="CORS">
        <front>
	  <title>Cross-Origin Resource Sharing</title>
	  <author fullname="Anne van Kesteren">
	    <organization abbrev="Opera">Opera Software ASA</organization>
	  </author>
	  <date day="27" month="July" year="2010"></date>
        </front>

	<format target="http://www.w3.org/TR/access-control/"
		type="HTML" />
      </reference>

    </references>
    <references title="Informative References">

      <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.4949"?>

      <reference anchor="OpenID.Basic">
	<front>
	  <title>OpenID Connect Basic Client Profile 1.0</title>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	  </author>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	  </author>

	  <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
	    <organization abbrev="Google">Google</organization>
	  </author>

	  <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
	    <organization abbrev="Salesforce">Salesforce</organization>
	  </author>

	  <date day="5" month="July" year="2013"/>
	</front>

	<format target="http://openid.net/specs/openid-connect-basic-1_0-28.html"
		type="HTML" />
      </reference>

      <reference anchor="OpenID.Implicit">
	<front>
	  <title>OpenID Connect Implicit Client Profile 1.0</title>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	  </author>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	  </author>

	  <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
	    <organization abbrev="Google">Google</organization>
	  </author>

	  <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
	    <organization abbrev="Salesforce">Salesforce</organization>
	  </author>

	  <author fullname="Edmund Jay" initials="E." surname="Jay">
	    <organization abbrev="Illumila">Illumila</organization>
	  </author>

	  <date day="5" month="July" year="2013"/>
	</front>

	<format target="http://openid.net/specs/openid-connect-implicit-1_0-11.html"
		type="HTML" />
      </reference>

      <reference anchor="OpenID.Session">
	<front>
	  <title>OpenID Connect Session Management
	  1.0</title>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	  </author>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	  </author>

	  <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
	    <organization abbrev="Google">Google</organization>
	  </author>

	  <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
	    <organization abbrev="Salesforce">Salesforce</organization>
	  </author>

	  <author fullname="Edmund Jay" initials="E." surname="Jay">
	    <organization abbrev="Illumila">Illumila</organization>
	  </author>

	  <date day="5" month="July" year="2013"/>
	</front>

	<format target="http://openid.net/specs/openid-connect-session-1_0-15.html"
		type="HTML" />
      </reference>

      <reference anchor="OpenID.2.0">
	<front>
	  <title>OpenID Authentication 2.0</title>

	  <author fullname="OpenID Foundation">
	    <organization abbrev="OIDF">OpenID Foundation</organization>
	  </author>

	  <date day="5" month="December" year="2007" />
	</front>

	<format target="http://www.openid.net/specs/openid-authentication-2_0.txt"
		type="TXT" />

	<format target="http://www.openid.net/specs/openid-authentication-2_0.html"
		type="HTML" />
      </reference>

      <reference anchor="OpenID.PAPE">
	<front>
	  <title abbrev="OpenID Provider Auth Policy Extension">OpenID Provider
	  Authentication Policy Extension 1.0</title>
	  <author fullname="David Recordon" initials="D.R" surname="Recordon">
	    <organization abbrev="Six Apart">Six Apart, Ltd.</organization>
	    <address>
	      <postal>
		<street>548 4th Street</street>
		<city>San Francisco</city>
		<region>CA</region>
		<code>94107</code>
		<country>USA</country>
	      </postal>
	      <email>david@sixapart.com</email>
	      <uri>http://www.sixapart.com/</uri>
	    </address>
	  </author>
	  <author fullname="Michael B. Jones" initials="M.J" surname="Jones">
	    <organization abbrev="Microsoft">Microsoft Corporation</organization>
	    <address>
	      <postal>
		<street>One Microsoft Way, Building 40/5138</street>
		<city>Redmond</city>
		<region>WA</region>
		<code>98052</code>
		<country>USA</country>
	      </postal>
	      <email>mbj@microsoft.com</email>
	      <uri>http://www.microsoft.com/</uri>
	    </address>
	  </author>
	  <author fullname="Johnny Bufu" initials="J.B" role="editor" surname="Bufu">
	    <organization>Independent</organization>
	    <address>
	      <email>johnny.bufu@gmail.com</email>
	      <uri></uri>
	    </address>
	  </author>
	  <author fullname="Jonathan Daugherty" initials="J.D" role="editor"
		  surname="Daugherty">
	    <organization>JanRain</organization>
	    <address>
	      <postal>
		<street>5331 SW Macadam Ave. #375</street>
		<city>Portland</city>
		<region>OR</region>
		<code>97239</code>
		<country>USA</country>
	      </postal>
	      <email>cygnus@janrain.com</email>
	      <uri>http://janrain.com/</uri>
	    </address>
	  </author>
	  <author fullname="Nat Sakimura" initials="N.S" surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	    <address>
	      <postal>
		<street>Marunouchi Kitaguchi Building, 1-6-5 Marunouchi</street>
		<city>Chiyoda-ku</city>
		<region>Tokyo</region>
		<code>100-0005</code>
		<country>Japan</country>
	      </postal>
	      <email>n-sakimura@nri.co.jp</email>
	      <uri>http://www.nri.co.jp/</uri>
	    </address>
	  </author>
	  <date day="30" month="December" year="2008" />
	</front>

	<format target="http://openid.net/specs/openid-provider-authentication-policy-extension-1_0.txt"
		type="TXT" />

	<format target="http://openid.net/specs/openid-provider-authentication-policy-extension-1_0.html"
		type="HTML" />
      </reference>

      <reference anchor="X.1252">
        <front>
          <title>ITU-T Recommendation X.1252 -- Cyberspace security -- Identity management
	  -- Baseline identity management terms and definitions</title>

          <author fullname="International Telecommunication Union">
            <organization abbrev="ITU-T">International Telecommunication Union</organization>
          </author>

          <date month="November" year="2010" />
        </front>
        <seriesInfo name="ITU-T" value="X.1252" />
        <format target="http://www.itu.int/rec/dologin_pub.asp?lang=e&amp;id=T-REC-X.1252-201004-I!!PDF-E&amp;type=items"
                type="PDF" />
      </reference>

    </references>

    <section anchor="AuthorizationExamples" title="Authorization Examples">

      <t>
	The following are non-normative examples of Authorization Requests with 
	differing <spanx style="verb">response_type</spanx> values and their responses 
	(with line wraps within values for display purposes only):
      </t>

      <figure>
	<preamble>Case 1: response_type=code</preamble>
	
	<artwork><![CDATA[
  https://server.example.com/op/authorize?
    response_type=code
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj
              
  HTTP/1.1 302 Found
  Location: https://client.example.org/cb?
    code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk
    &state=af0ifjsldkj
]]></artwork>
      </figure>

      <figure>
	<preamble>Case 2: response_type=id_token&nbsp;token</preamble>
	<artwork><![CDATA[
  https://server.example.com/op/authorize?
    response_type=id_token%20token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj
              
  HTTP/1.1 302 Found
  Location: https://client.example.org/cb#
    access_token=jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y
    &token_type=Bearer
    &id_token=eyJhbGciOiJSUzI1NiJ9.ew0KICJpc3MiOiAiaHR0cDovL3NlcnZlc
    i5leGFtcGxlLmNvbSIsDQogInN1YiI6ICIyNDgyODk3NjEwMDEiLA0KICJhdWQiO
    iAiczZCaGRSa3F0MyIsDQogIm5vbmNlIjogIm4tMFM2X1d6QTJNaiIsDQogImV4c
    CI6IDEzMTEyODE5NzAsDQogImlhdCI6IDEzMTEyODA5NzAsDQogImF0X2hhc2giO
    iAiNzdRbVVQdGpQZnpXdEYyQW5wSzlSUSINCn0.g7UR4IDBNIjoPFV8exQCosUNV
    eh8bNUTeL4wdQp-2WXIWnly0_4ZK0sh4A4uddfenzo4Cjh4wuPPrSw6lMeujYbGy
    zKspJrRYL3iiYWc2VQcl8RKdHPz_G-7yf5enut1YE8v7PhKucPJCRRoobMjqD73f
    1nJNwQ9KBrfh21Ggbx1p8hNqQeeLLXb9b63JD84hVOXwyHmmcVgvZskge-wExwnh
    Ivv_cxTzxIXsSxcYlh3d9hnu0wdxPZOGjT0_nNZJxvdIwDD4cAT_LE5Ae447qB90
    ZF89Nmb0Oj2b1GdGVQEIr8-FXrHlyD827f0N_hLYPdZ73YK6p10qY9oRtMimg
    &state=af0ifjsldkj
]]></artwork>
      </figure>

      <figure>
	<preamble>
	  Verifying and decoding the ID Token will yield the following Claims:
	</preamble>
	<artwork><![CDATA[
  {
   "iss": "http://server.example.com",
   "sub": "248289761001",
   "aud": "s6BhdRkqt3",
   "nonce": "n-0S6_WzA2Mj",
   "exp": 1311281970,
   "iat": 1311280970,
   "at_hash": "77QmUPtjPfzWtF2AnpK9RQ"
  }
]]></artwork>
      </figure>

      <figure>
	<preamble>Case 3: response_type=code&nbsp;id_token</preamble>
	<artwork><![CDATA[
  https://server.example.com/op/authorize?
    response_type=code%20id_token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj
              
  HTTP/1.1 302 Found
  Location: https://client.example.org/cb#
    code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk
    &id_token=eyJhbGciOiJSUzI1NiJ9.ew0KICJpc3MiOiAiaHR0cDovL3NlcnZlc
    i5leGFtcGxlLmNvbSIsDQogInN1YiI6ICIyNDgyODk3NjEwMDEiLA0KICJhdWQiO
    iAiczZCaGRSa3F0MyIsDQogIm5vbmNlIjogIm4tMFM2X1d6QTJNaiIsDQogImV4c
    CI6IDEzMTEyODE5NzAsDQogImlhdCI6IDEzMTEyODA5NzAsDQogImNfaGFzaCI6I
    CJMRGt0S2RvUWFrM1BrMGNuWHhDbHRBIg0KfQ.dAVXerlNOJ_tqMUysD_k1Q_bRX
    RJbLkTOsCPVxpKUis5V6xMRvtjfRg8gUfPuAMYrKQMEqZZmL87Hxkv6cFKavb4ft
    BUrY2qUnrvqe_bNjVEz89QSdxGmdFwSTgFVGWkDf5dV5eIiRxXfIkmlgCltPNocR
    AyvdNrsWC661rHz5F9MzBho2vgi5epUa_KAl6tK4ksgl68pjZqlBqsWfTbGEsWQX
    Efu664dJkdXMLEnsPUeQQLjMhLH7qpZk2ry0nRx0sS1mRwOM_Q0Xmps0vOkNn284
    pMUpmWEAjqklWITgtVYXOzF4ilbmZK6ONpFyKCpnSkAYtTEuqz-m7MoLCD_A
    &state=af0ifjsldkj
]]></artwork>
      </figure>

      <figure>
	<preamble>
	  Verifying and decoding the ID Token will yield the following Claims:
	</preamble>
	<artwork><![CDATA[
  {
   "iss": "http://server.example.com",
   "sub": "248289761001",
   "aud": "s6BhdRkqt3",
   "nonce": "n-0S6_WzA2Mj",
   "exp": 1311281970,
   "iat": 1311280970,
   "c_hash": "LDktKdoQak3Pk0cnXxCltA"
  }
]]></artwork>
      </figure>

      <figure>
	<preamble>Case 4: response_type=code&nbsp;token</preamble>
	<artwork><![CDATA[
  https://server.example.com/op/authorize?
    response_type=code%20token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj

  HTTP/1.1 302 Found
  Location: https://client.example.org/cb#
    code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk
    &access_token=jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y
    &token_type=Bearer
    &state=af0ifjsldkj
]]></artwork>
      </figure>

      <figure>
	<preamble>Case 5: response_type=code&nbsp;id_token&nbsp;token</preamble>
	<artwork><![CDATA[
  https://server.example.com/op/authorize?
    response_type=code%20id_token%20token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj

  HTTP/1.1 302 Found
  Location: https://client.example.org/cb#
    code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk
    &access_token=jHkWEdUXMU1BwAsC4vtUsZwnNvTIxEl0z9K3vx5KF0Y
    &token_type=Bearer
    &id_token=eyJhbGciOiJSUzI1NiJ9.ew0KICJpc3MiOiAiaHR0cDovL3NlcnZlc
    i5leGFtcGxlLmNvbSIsDQogInN1YiI6ICIyNDgyODk3NjEwMDEiLA0KICJhdWQiO
    iAiczZCaGRSa3F0MyIsDQogIm5vbmNlIjogIm4tMFM2X1d6QTJNaiIsDQogImV4c
    CI6IDEzMTEyODE5NzAsDQogImlhdCI6IDEzMTEyODA5NzAsDQogImF0X2hhc2giO
    iAiNzdRbVVQdGpQZnpXdEYyQW5wSzlSUSIsDQogImNfaGFzaCI6ICJMRGt0S2RvU
    WFrM1BrMGNuWHhDbHRBIg0KfQ.JQthrBsOirujair9aD5gj1Yd5qEv0j4fhLgl8h
    3RaH3soYhwPOiN2Iy_yb7wMCO6I3bPoGJc3zCkpjgUtdB4O2eEhFqXHdwnE4c0oV
    TaTHJi_PdV2ox9g-1ikDB0ckWk0f0SzBd7yM2RoYYxJCiGBQlsSSRQz6ehykonI3
    hLAhXFdpfbK-3_a3HBNKOv_9Mr_JJrz2pqSygk5IBNvwzf1ouVeM91KKvr7EdriK
    N8ysk68fctbFAga1p8rE3cfBOX7Acn4p9QSNpUx0i_x4WHktyKDvH_hLdUw91Fql
    _UOgMP_9h8TYdkAjcq8n1tFzaO7kVaazlZ5SM32J7OSDgNSA
    &state=af0ifjsldkj
]]></artwork>
      </figure>

      <figure>
	<preamble>
	  Verifying and decoding the ID Token will yield the following Claims:
	</preamble>
	<artwork><![CDATA[
  {
   "iss": "http://server.example.com",
   "sub": "248289761001",
   "aud": "s6BhdRkqt3",
   "nonce": "n-0S6_WzA2Mj",
   "exp": 1311281970,
   "iat": 1311280970,
   "at_hash": "77QmUPtjPfzWtF2AnpK9RQ",
   "c_hash": "LDktKdoQak3Pk0cnXxCltA"
  }
]]></artwork>
      </figure>
      
      <t>
	This following example makes a request using a
	<spanx style='verb'>request</spanx> parameter value
	requesting that specific Claims be returned in the ID Token.
	The sample Request Object used is described in
	<xref target="RequestObject"/>.
      </t>

      <figure>
	<preamble>Case 6: response_type=id_token</preamble>
	<artwork><![CDATA[
  https://server.example.com/op/authorize?
    response_type=id_token
    &client_id=s6BhdRkqt3
    &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb
    &scope=openid%20profile%20email
    &nonce=n-0S6_WzA2Mj
    &state=af0ifjsldkj

  HTTP/1.1 302 Found
  Location: https://client.example.org/cb#
    code=Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk
    &token_type=Bearer
    &id_token=eyJhbGciOiJSUzI1NiJ9.ew0KICJpc3MiOiAiaHR0cDovL3Nlc
    nZlci5leGFtcGxlLmNvbSIsDQogInN1YiI6ICIyNDgyODk3NjEwMDEiLA0KI
    CJhdWQiOiAiczZCaGRSa3F0MyIsDQogIm5vbmNlIjogIm4tMFM2X1d6QTJNa
    iIsDQogImV4cCI6IDEzMTEyODE5NzAsDQogImlhdCI6IDEzMTEyODA5NzAsD
    QogIm5hbWUiOiAiSmFuZSBEb2UiLA0KICJnaXZlbl9uYW1lIjogIkphbmUiL
    A0KICJmYW1pbHlfbmFtZSI6ICJEb2UiLA0KICJnZW5kZXIiOiAiZmVtYWxlI
    iwNCiAiYmlydGhkYXRlIjogIjAwMDAtMTAtMzEiLA0KICJlbWFpbCI6ICJqY
    W5lZG9lQGV4YW1wbGUuY29tIiwNCiAicGljdHVyZSI6ICJodHRwOi8vZXhhb
    XBsZS5jb20vamFuZWRvZS9tZS5qcGciDQp9.Bgdr1pzosIrnnnpIekmJ7ooe
    DbXuA2AkwfMf90Po2TrMcl3NQzUE_9dcr9r8VOuk4jZxNpV5kCu0RwqqF11-
    6pQ2KQx_ys2i0arLikdResxvJlZzSm_UG6-21s97IaXC97vbnTCcpAkokSe8
    Uik6f8-U61zVmCBMJnpvnxEJllfV8fYldo8lWCqlOngScEbFQUh4fzRsH8O3
    Znr20UZib4V4mGZqYPtPDVGTeu8xkty1t0aK-wEhbm6Hi-TQTi4kltJlw47M
    cSVgF_8SswaGcW6Bf_954ir_ddi4Nexo9RBiWu4n3JMNcQvZU5xMPhu-EF-6
    _nJNotp-lbnBUyxTSg
    &state=af0ifjsldkj
]]></artwork>
      </figure>

      <figure>
	<preamble>
	  Verifying and decoding the ID Token will yield the following Claims:
	</preamble>
	<artwork><![CDATA[
  {
   "iss": "http://server.example.com",
   "sub": "248289761001",
   "aud": "s6BhdRkqt3",
   "nonce": "n-0S6_WzA2Mj",
   "exp": 1311281970,
   "iat": 1311280970,
   "name": "Jane Doe",
   "given_name": "Jane",
   "family_name": "Doe",
   "gender": "female",
   "birthdate": "0000-10-31",
   "email": "janedoe@example.com",
   "picture": "http://example.com/janedoe/me.jpg"
  }
]]></artwork>
      </figure>

      <figure>
	<preamble>
	  The following is the RSA public key in JWK format that can be used to
	  validate the ID Token signatures in the above examples
	  (with line wraps within values for display purposes only):
	</preamble>

	<artwork><![CDATA[
  {
   "kty":"RSA",
   "n":"zhEWTBJVTfcUeqnMzOQFMCEVQWOyOUZwP8LrBWh88tKrZyPGCvBkT
  Dp-E2BzyHMQV4pK51Uys2YOwzL9se5THDWMda9rtsCJVcj1V7WaE7wPgl-kIIdWWf4o2g
  6ZszOy_Fp4q0nG3OTtDRCkBu2iEP21j82pRSRrkCBxnzaChflA7KZbI1n_yhKtxyA7FdA
  480LaSVZyKApvrKiYhocACSwf0y6CQ-wkEi6mVXRJt1aBSywlLYA08ojp5hkZQ39eCM2k
  1EdXdhbar998Q9PZTwXA1cfvuGTZbDWxEKLjMKVuKrT1Yvs-2NTXhZAW1KjFS_3UwLkDk
  -w4dVN-x5tDnw",
   "e":"AQAB"
  }
]]></artwork>
      </figure>            

    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>As a successor version of OpenID, this specification heavily relies
      on ideas explored in <xref target="OpenID.2.0">OpenID Authentication 2.0</xref>. Please
      refer to Appendix C of OpenID Authentication 2.0 for the full list of
      the contributors for that specification.</t>

      <t>In addition, the OpenID Community would like to thank the following
      people for the work they have done in the drafting and editing of this
      specification.</t>

      <t>
	<list style="empty">
	  <t>Naveen Agarwal (naa@google.com), Google</t>
	  <t>Amanda Anganes (aanganes@mitre.org), Mitre</t>
	  <t>Casper Biering (cb@peercraft.com), Peercraft</t>
	  <t>John Bradley (ve7jtb@ve7jtb.com), Ping Identity</t>
	  <t>Tim Bray (tbray@textuality.com), Google</t>
	  <t>Johnny Bufu (jbufu@janrain.com), Janrain</t>
	  <t>Brian Campbell (bcampbell@pingidentity.com), Ping Identity</t>
	  <t>Blaine Cook (romeda@gmail.com), Independent</t>
	  <t>Breno de Medeiros (breno@gmail.com), Google</t>
	  <t>Pamela Dingle (pdingle@pingidentity.com), Ping Identity</t>
	  <t>Vladimir Dzhuvinov (vladimir@nimbusds.com), Nimbus Directory Services</t>
	  <t>George Fletcher (george.fletcher@corp.aol.com), AOL</t>
	  <t>Roland Hedberg (roland.hedberg@adm.umu.se), University of Umea</t>
	  <t>Ryo Ito (ryo.ito@mixi.co.jp), mixi, Inc.</t>
	  <t>Edmund Jay (ejay@mgi1.com), Illumila</t>
	  <t>Michael B. Jones (mbj@microsoft.com), Microsoft</t>
	  <t>Torsten Lodderstedt (t.lodderstedt@telekom.de), Deutsche Telekom</t>
	  <t>Nov Matake (nov@matake.jp), Independent</t>
	  <t>Chuck Mortimore (cmortimore@salesforce.com), Salesforce</t>
	  <t>Anthony Nadalin (tonynad@microsoft.com), Microsoft</t>
	  <t>Hideki Nara (hdknr@ic-tact.co.jp), Tact Communications</t>
	  <t>Axel Nennker (axel.nennker@telekom.de), Deutsche Telekom</t>
	  <t>David Recordon (dr@fb.com), Facebook</t>
	  <t>Justin Richer (jricher@mitre.org), Mitre</t>
	  <t>Nat Sakimura (n-sakimura@nri.co.jp), Nomura Research Institute, Ltd.</t>
	  <t>Luke Shepard (lshepard@fb.com), Facebook</t>
	  <t>Andreas Akre Solberg (andreas.solberg@uninett.no), UNINET</t>
	  <t>Paul Tarjan (pt@fb.com), Facebook</t>
	</list>
      </t>
    </section>

    <section anchor="Notices" title="Notices">
      <t>Copyright (c) 2013 The OpenID Foundation.</t>
      <t>
	The OpenID Foundation (OIDF) grants to any Contributor, developer, 
	implementer, or other interested party a non-exclusive, royalty free, 
	worldwide copyright license to reproduce, prepare derivative works from, 
	distribute, perform and display, this Implementers Draft or 
	Final Specification solely for the purposes of (i) developing 
	specifications, and (ii) implementing Implementers Drafts and 
	Final Specifications based on such documents, provided that attribution 
	be made to the OIDF as the source of the material, but that such attribution 
	does not indicate an endorsement by the OIDF.
      </t>
      <t>
	The technology described in this specification was 
	made available from contributions from various sources, 
	including members of the OpenID Foundation and others.  
	Although the OpenID Foundation has taken steps to help ensure 
	that the technology is available for distribution, it takes 
	no position regarding the validity or scope of any intellectual 
	property or other rights that might be claimed to pertain to 
	the implementation or use of the technology described in 
	this specification or the extent to which any license under 
	such rights might or might not be available; neither does it 
	represent that it has made any independent effort to identify 
	any such rights.  The OpenID Foundation and the contributors 
	to this specification make no (and hereby expressly disclaim any) 
	warranties (express, implied, or otherwise), including implied 
	warranties of merchantability, non-infringement, fitness for 
	a particular purpose, or title, related to this specification, 
	and the entire risk as to implementing this specification is 
	assumed by the implementer.  The OpenID Intellectual 
	Property Rights policy requires contributors to offer 
	a patent promise not to assert certain patent claims against 
	other contributors and against implementers.  The OpenID Foundation invites 
	any interested party to bring to its attention any copyrights, 
	patents, patent applications, or other proprietary rights 
	that may cover technology that may be required to practice 
	this specification.
      </t>
    </section>

    <section anchor="History" title="Document History">
      <t>[[ To be removed from the final specification ]]</t>

      <t>
	-12
        <list style="symbols">
	  <t>
	    Created the new OpenID Connect Core specification by combining
	    OpenID Connect Messages draft 20 and
	    OpenID Connect Standard draft 21,
	    with no normative changes.
	    (These versions are the second Implementer's Drafts.)
	  </t>
	</list>
      </t>

    </section>
  </back>
</rfc>
