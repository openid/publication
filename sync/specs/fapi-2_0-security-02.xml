<?xml version="1.0" encoding="utf-8"?>
<!-- name="GENERATOR" content="github.com/mmarkdown/mmark Mmark Markdown Processor - mmark.miek.nl" -->
<rfc version="3" ipr="none" docName="fapi-2_0-security-02" submissionType="IETF" category="std" xml:lang="en" xmlns:xi="http://www.w3.org/2001/XInclude" consensus="true">

<front>
<title abbrev="fapi-2-security">FAPI 2.0 Security Profile</title><seriesInfo value="fapi-2_0-security-02" status="standard" name="Internet-Draft"></seriesInfo>
<author initials="D." surname="Fett" fullname="Daniel Fett"><organization>yes.com</organization><address><postal><street></street>
</postal><email>mail@danielfett.de</email>
</address></author>
<date/>
<area>Internet</area>
<workgroup>fapi</workgroup>
<keyword>security</keyword>
<keyword>openid</keyword>

<note><name>Foreword</name>
<t>The OpenID Foundation (OIDF) promotes, protects and nurtures the OpenID community and technologies. As a non-profit international standardizing body, it is comprised by over 160 participating entities (workgroup participant). The work of preparing implementer drafts and final international standards is carried out through OIDF workgroups in accordance with the OpenID Process. Participants interested in a subject for which a workgroup has been established have the right to be represented in that workgroup. International organizations, governmental and non-governmental, in liaison with OIDF, also take part in the work. OIDF collaborates closely with other standardizing bodies in the related fields.</t>
<t>Final drafts adopted by the Workgroup through consensus are circulated publicly for the public review for 60 days and for the OIDF members for voting. Publication as an OIDF Standard requires approval by at least 50% of the members casting a vote. There is a possibility that some of the elements of this document may be the subject to patent rights. OIDF shall not be held responsible for identifying any or all such patent rights.</t>
</note>

<note><name>Introduction</name>
<t>The FAPI 2.0 Security Profile is an API security profile based on the
OAuth 2.0 Authorization Framework <xref target="RFC6749"></xref> and related specifications suitable for
protecting APIs in high-value scenarios. While the security profile was
initially developed with a focus on financial applications, it is designed to be
universally applicable for protecting APIs exposing high-value and sensitive
(personal and other) data, for example, in e-health and e-government
applications.</t>
</note>

<note><name>Warning</name>
<t>This document is not an OIDF International Standard. It is distributed for
review and comment. It is subject to change without notice and may not be
referred to as an International Standard.</t>
<t>Recipients of this draft are invited to submit, with their comments,
notification of any relevant patent rights of which they are aware and to
provide supporting documentation.</t>
</note>

<note><name>Notational Conventions</name>
<t>The keywords &quot;shall&quot;, &quot;shall not&quot;, &quot;should&quot;, &quot;should not&quot;, &quot;may&quot;, and &quot;can&quot; in
this document are to be interpreted as described in ISO Directive Part 2
<xref target="ISODIR2"></xref>. These keywords are not used as dictionary terms such that any
occurrence of them shall be interpreted as keywords and are not to be
interpreted with their natural language meanings.</t>
</note>

</front>

<middle>

<section anchor="scope"><name>Scope</name>
<t>This document specifies the requirements for confidential Clients to securely obtain
OAuth tokens from Authorization Servers and securely use those tokens to access REST APIs at
Resource Servers.</t>
</section>

<section anchor="normative-references"><name>Normative references</name>
<t>See section 8 for normative references.</t>
</section>

<section anchor="terms-and-definitions"><name>Terms and definitions</name>
<t>For the purpose of this document, the terms defined in <xref target="RFC6749"></xref>, <xref target="RFC6750"></xref>, <xref target="RFC7636"></xref>, <xref target="OIDC"></xref> and ISO29100 apply.</t>
</section>

<section anchor="symbols-and-abbreviated-terms"><name>Symbols and Abbreviated terms</name>
<t><strong>API</strong> – Application Programming Interface</t>
<t><strong>HTTP</strong> – Hyper Text Transfer Protocol</t>
<t><strong>REST</strong> – Representational State Transfer</t>
<t><strong>TLS</strong> – Transport Layer Security</t>
<t><strong>DNS</strong> - Domain Name System</t>
<t><strong>DNSSEC</strong> -  Domain Name System Security Extensions</t>
<t><strong>CAA</strong> - Certificate Authority Authorization</t>
<t><strong>URI</strong> - Uniform Resource Identifier</t>
</section>

<section anchor="security-profile"><name>Security Profile</name>

<section anchor="introduction"><name>Introduction</name>
<t>The FAPI 2.0 Security Profile is an API security profile based on the OAuth 2.0 Authorization
Framework <xref target="RFC6749"></xref>, that aims to reach the security goals laid out in the Attacker
Model <xref target="attackermodel"></xref>.</t>
<t>This profile is the base of the FAPI 2.0 Framework. Other specifications that are
part of this framework and may be used together with this profile include:</t>

<ol>
<li><t>FAPI Message Signing is recommended when messages are required to be signed for the
purposes of non-repudiation.<br />
</t>
</li>
<li><t>FAPI CIBA is recommended when support is required for decoupled or cross device flows.</t>
</li>
<li><t>Grant Management is recommended for ecosystems that require interopable grant management.</t>
</li>
<li><t>OAuth 2.0 Rich Authorization Requests (RAR) <xref target="I-D.ietf-oauth-rar"></xref> is recommended when
the <tt>scope</tt> parameter is not expressive enough to convey the authorization that a client
wants to obtain.</t>
</li>
</ol>
<t>We are not currently aware of any mechanisms that would allow public clients
to be secured to the same degree and hence their use is not within the scope
of this specification.</t>

<section anchor="profiling-this-specification"><name>Profiling this specification</name>
<t>This specification is a general purpose high security profile of
OAuth 2.0 that has been proved by formal analysis to meet the stated
attacker model.</t>
<t>This specification, and the underlying specifications, leave a number
of choices open to implementors, deployers and/or ecosystems - with
knowledge of the exact use cases, further reducing the number of
choices may further improve security, or make implementation or
interoperability easier.</t>
<t>However, for a profile to be compliant with this specification, the
profile shall not remove or override mandatory behaviours - as doing
so is likely to invalidate the formal security analysis and reduce
security in potentially unpredictable ways.</t>
</section>
</section>

<section anchor="network-layer-protections"><name>Network Layer Protections</name>

<section anchor="requirements-for-all-endpoints"><name>Requirements for all endpoints</name>
<t>TLS connections shall be protected against network attackers. To this end, clients,
authorization servers, and resource servers:</t>

<ol>
<li><t>shall only offer TLS protected endpoints and shall establish connections
to other servers using TLS. TLS connections shall be set up to use
TLS version 1.2 or later.</t>
</li>
<li><t>when using TLS 1.2, follow the recommendations for Secure Use of Transport Layer Security in <xref target="RFC7525"></xref>.</t>
</li>
<li><t>should use DNSSEC to protect against DNS spoofing attacks that can lead to
the issuance of rogue domain-validated TLS certificates.</t>
</li>
<li><t>shall perform a TLS server certificate check, as per <xref target="RFC6125"></xref>.</t>
</li>
</ol>
<t><strong>NOTE</strong>: Even if an endpoint uses only organization validated (OV) or extended
validation (EV) TLS certificates, rogue domain-validated certificates can be used
to impersonate the endpoints and conduct man-in-the-middle attacks. CAA records
<xref target="RFC8659"></xref> can help to mitigate this risk.</t>
</section>

<section anchor="requirements-for-endpoints-not-used-by-web-browsers"><name>Requirements for endpoints not used by web browsers</name>

<ol>
<li><t>when using TLS 1.2, the server shall only permit the cipher suites listed in <xref target="tls-12-ciphers"></xref></t>
</li>
<li><t>when using TLS 1.2, the client should only permit the cipher suites listed in <xref target="tls-12-ciphers"></xref></t>
</li>
<li><t>When using the <tt>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</tt> or <tt>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</tt> cipher suites,
key lengths of at least 2048 bits are required.</t>
</li>
</ol>

<section anchor="tls-12-ciphers"><name>TLS 1.2 permitted cipher suites</name>

<ul>
<li><t><tt>TLS_DHE_RSA_WITH_AES_128_GCM_SHA256</tt></t>
</li>
<li><t><tt>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</tt></t>
</li>
<li><t><tt>TLS_DHE_RSA_WITH_AES_256_GCM_SHA384</tt></t>
</li>
<li><t><tt>TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384</tt></t>
</li>
</ul>
</section>
</section>

<section anchor="requirements-for-endpoints-used-by-web-browsers"><name>Requirements for endpoints used by web browsers</name>
<t>Endpoints for the use by web browsers</t>

<ol>
<li><t>shall use methods to ensure that connections cannot be downgraded using
 TLS Stripping attacks. A preloaded <xref target="preload"></xref> HTTP Strict Transport Security
 policy <xref target="RFC6797"></xref> can be used for this purpose. Some top-level domains,
 like .bank and .insurance, have set such a policy and therefore protect all
 second-level domains below them.</t>
</li>
<li><t>when using TLS 1.2, shall only use cipher suites allowed in <xref target="RFC7525"></xref></t>
</li>
</ol>
</section>
</section>

<section anchor="profile"><name>Profile</name>
<t>In the following, a profile of the following technologies is defined:</t>

<ul>
<li><t>OAuth 2.0 Authorization Framework <xref target="RFC6749"></xref></t>
</li>
<li><t>OAuth 2.0 Bearer Tokens <xref target="RFC6750"></xref></t>
</li>
<li><t>Proof Key for Code Exchange by OAuth Public Clients (PKCE) <xref target="RFC7636"></xref></t>
</li>
<li><t>OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access
Tokens (MTLS) <xref target="RFC8705"></xref></t>
</li>
<li><t>OAuth 2.0 Demonstrating Proof-of-Possession at the Application Layer (DPoP)
<xref target="I-D.ietf-oauth-dpop"></xref></t>
</li>
<li><t>OAuth 2.0 Pushed Authorization Requests (PAR) <xref target="RFC9126"></xref></t>
</li>
<li><t>OAuth 2.0 Authorization Server Metadata <xref target="RFC8414"></xref></t>
</li>
<li><t>OAuth 2.0 Authorization Server Issuer Identification <xref target="RFC9207"></xref></t>
</li>
<li><t>OpenID Connect Core 1.0 incorporating errata set 1 <xref target="OIDC"></xref></t>
</li>
</ul>

<section anchor="requirements-for-authorization-servers"><name>Requirements for Authorization Servers</name>

<section anchor="general-requirements"><name>General Requirements</name>
<t>Authorization servers</t>

<ol>
<li><t>shall distribute discovery metadata (such as the authorization endpoint) via
the metadata document as specified in <xref target="OIDD"></xref> and <xref target="RFC8414"></xref></t>
</li>
<li><t>shall reject requests using the resource owner password credentials grant or
the implicit grant described in <xref target="RFC6749"></xref> or the hybrid flow as described in <xref target="OIDC"></xref></t>
</li>
<li><t>shall support confidential clients as defined in <xref target="RFC6749"></xref></t>
</li>
<li><t>shall only issue sender-constrained access tokens,</t>
</li>
<li><t>shall use one of the following methods for sender-constrained access tokens:</t>

<ul>
<li><t>MTLS as described in <xref target="RFC8705"></xref></t>
</li>
<li><t>DPoP as described in <xref target="I-D.ietf-oauth-dpop"></xref></t>
</li>
</ul></li>
<li><t>shall authenticate clients using one of the following methods:</t>

<ul>
<li><t>MTLS as specified in section 2 of <xref target="RFC8705"></xref></t>
</li>
<li><t><tt>private_key_jwt</tt> as specified in section 9 of <xref target="OIDC"></xref></t>
</li>
</ul></li>
<li><t>shall not expose open redirectors (see section 4.10 of
 <xref target="I-D.ietf-oauth-security-topics"></xref>)</t>
</li>
<li><t>shall accept its issuer identifier value (as defined in <xref target="RFC8414"></xref>) in the <tt>aud</tt> claim
 received in client authentication assertions.</t>
</li>
<li><t>shall not use refresh token rotation unless, in the case a response with a new
 refresh token is not received and stored by the client, retrying the request (with
 the previous refresh token) will succeed.</t>
</li>
<li><t>if using DPoP, may use the server provided nonce mechanism (as defined in section 8 of <xref target="I-D.ietf-oauth-dpop"></xref>).</t>
</li>
<li><t>shall issue authorization codes with a maximum lifetime of 60 seconds</t>
</li>
<li><t>if using DPoP, shall support &quot;Authorization Code Binding to DPoP Key&quot; (as required by section 10.1 of <xref target="I-D.ietf-oauth-dpop"></xref>).</t>
</li>
</ol>
<t><strong>NOTE</strong>: In order to facilitate interoperability the authorization server should also
accept  its token endpoint URL or the URL of the endpoint at which the assertion was
received in the <tt>aud</tt> claim received in client authentication assertions.</t>
<t><strong>NOTE</strong>: Refresh token rotation is an optional feature defined in <xref target="RFC6749"></xref> section 6
where the Authorization Server issues a new refresh token to the client as part of the
<tt>refresh_token</tt> grant. This specification discourages the use of this feature as it
doesn't bring any security benefits for confidential clients, and can cause significant
operational issues. However to allow for operational agility, Authorization Servers
may implement it providing they meet the requirement in clause 20.</t>
<t><strong>NOTE</strong>: Other grants as appropriate may be supported, for example the client credentials grant,
the Client Initiated Backchannel Authentication grant, etc.</t>
</section>

<section anchor="authorization-code-flow"><name>Authorization Code Flow</name>
<t>For the Authorization Code flow, Authorization servers</t>

<ol>
<li><t>shall support the authorization code grant (<tt>response_type=code</tt> &amp; <tt>grant_type=authorization_code</tt>)
described in <xref target="RFC6749"></xref></t>
</li>
<li><t>shall support client-authenticated pushed authorization requests
according to <xref target="RFC9126"></xref></t>
</li>
<li><t>shall reject authorization requests sent without
<xref target="RFC9126"></xref></t>
</li>
<li><t>shall reject pushed authorization requests without client authentication</t>
</li>
<li><t>shall require PKCE <xref target="RFC7636"></xref> with <tt>S256</tt> as the code challenge method</t>
</li>
<li><t>shall require the <tt>redirect_uri</tt> parameter in pushed authorization requests</t>
</li>
<li><t>shall return an <tt>iss</tt> parameter in the authorization response according to <xref target="RFC9207"></xref></t>
</li>
<li><t>shall not transmit authorization responses over unencrypted network
 connections, and, to this end, shall not allow redirect URIs that use the
 &quot;http&quot; scheme except for native clients that use Loopback Interface
 Redirection as described in <xref target="RFC8252"></xref>, Section 7.3,</t>
</li>
<li><t>shall reject an authorization code (section 1.3.1 of <xref target="RFC6749"></xref>) if it has
 been previously used</t>
</li>
<li><t>shall not use the HTTP 307 status code when redirecting a request that contains
 user credentials to avoid forwarding the credentials to a third party accidentally
 (see section 4.11 of [I-D.ietf-oauth-security-topics]);</t>
</li>
<li><t>should use the HTTP 303 status code when redirecting the user agent using status codes;</t>
</li>
<li><t>shall issue pushed authorization requests <tt>request_uri</tt> with <tt>expires_in</tt> values
 of less than 600 seconds.</t>
</li>
</ol>
<t><strong>NOTE</strong>: If replay identification of the authorization code is not possible, it
is desirable to set the validity period of the authorization code to one minute
or a suitable short period of time. The validity period may act as a cache
control indicator of when to clear the authorization code cache if one is used</t>
<t><strong>NOTE</strong>: The <tt>request_uri</tt> <tt>expires_in</tt> time must be sufficient for
the user's device to receive the link and the user to complete the
process of opening the link. In many cases (poor network connection or
where the user has to manually select the browser to be used) this can
easily take over 30 seconds.</t>
</section>

<section anchor="returning-authenticated-user-s-identifier"><name>Returning Authenticated User's Identifier</name>
<t>If it is desired to provide the authenticated user's identifier to the client in
the token response, the authorization server shall support OpenID Connect
<xref target="OIDC"></xref>.</t>
</section>
</section>

<section anchor="requirements-for-clients"><name>Requirements for Clients</name>

<section anchor="general-requirements-1"><name>General Requirements</name>
<t>Clients</t>

<ol>
<li><t>shall support sender-constrained access tokens using one of the following methods:</t>

<ul>
<li><t>MTLS as described in <xref target="RFC8705"></xref></t>
</li>
<li><t>DPoP as described in <xref target="I-D.ietf-oauth-dpop"></xref></t>
</li>
</ul></li>
<li><t>shall support client authentication using one of the following methods:</t>

<ul>
<li><t>MTLS as specified in section 2 of <xref target="RFC8705"></xref></t>
</li>
<li><t><tt>private_key_jwt</tt> as specified in section 9 of <xref target="OIDC"></xref></t>
</li>
</ul></li>
<li><t>shall send access tokens in the HTTP header as in Section 2.1 of OAuth 2.0
Bearer Token Usage <xref target="RFC6750"></xref></t>
</li>
<li><t>shall not expose open redirectors (see section 4.10 of
 <xref target="I-D.ietf-oauth-security-topics"></xref>)</t>
</li>
<li><t>if using <tt>private_key_jwt</tt>, shall use the Authorization Server's issuer identifier
value (as defined in <xref target="RFC8414"></xref>) in the <tt>aud</tt> claim sent in client authentication assertions.
The issuer identifier value shall be sent as a string not as an item in an array.</t>
</li>
<li><t>shall support refresh tokens and their rotation</t>
</li>
<li><t>if using MTLS client authentication or MTLS sender-constrained access tokens, shall support
the <tt>mtls_endpoint_aliases</tt> metadata defined in <xref target="RFC8705"></xref></t>
</li>
<li><t>if using DPoP, shall support the server provided nonce mechanism (as defined in section 8 of <xref target="I-D.ietf-oauth-dpop"></xref>)</t>
</li>
<li><t>shall only use authorization server metadata (such as the authorization endpoint) retrieved from the metadata document as specified in <xref target="OIDD"></xref> and <xref target="RFC8414"></xref></t>
</li>
<li><t>shall ensure that the issuer URL used as the basis for retrieving the authorization server metadata is obtained from an authoritative source and using a secure channel, such that it cannot be modified by an attacker</t>
</li>
<li><t>shall ensure that this issuer URL and the <tt>issuer</tt> value in the obtained metadata match</t>
</li>
</ol>
<t><strong>NOTE</strong>:</t>
<t>This profile may be used by Confidential Clients on a user-controlled device where the system
clock may not be accurate, this may cause <tt>private_key_jwt</tt> client authentication to fail.
In such circumstances a Client should consider using the HTTP Date header returned from the
server to synchronise it's own clock when generating client assertions.</t>
<t><strong>NOTE</strong>:</t>
<t>Although Authorization Servers are required to support &quot;Authorization Code Binding to DPoP Key&quot; (as defined by section 10.1 of <xref target="I-D.ietf-oauth-dpop"></xref>), clients are not required to use it.</t>
</section>

<section anchor="authorization-code-flow-1"><name>Authorization Code Flow</name>
<t>For the Authorization Code flow, Clients</t>

<ol>
<li><t>shall use the authorization code grant described in <xref target="RFC6749"></xref></t>
</li>
<li><t>shall use pushed authorization requests according to <xref target="RFC9126"></xref></t>
</li>
<li><t>shall use PKCE <xref target="RFC7636"></xref> with <tt>S256</tt> as the code challenge method</t>
</li>
<li><t>shall check the <tt>iss</tt> parameter in the authorization response according to
<xref target="RFC9207"></xref> to prevent Mix-Up attacks</t>
</li>
</ol>
</section>
</section>

<section anchor="requirements-for-resource-servers"><name>Requirements for Resource Servers</name>
<t>The FAPI 2.0 endpoints are OAuth 2.0 protected resource endpoints that return
protected information for the resource owner associated with the submitted
access token.</t>
<t>Resource servers with the FAPI endpoints</t>

<ol>
<li><t>shall accept access tokens in the HTTP header as in Section 2.1 of OAuth 2.0
Bearer Token Usage <xref target="RFC6750"></xref></t>
</li>
<li><t>shall not accept access tokens in the query parameters stated in Section 2.3
of OAuth 2.0 Bearer Token Usage <xref target="RFC6750"></xref></t>
</li>
<li><t>shall verify the validity, integrity, expiration and revocation status of
access tokens</t>
</li>
<li><t>shall verify that the authorization represented by the access token is sufficient
for the requested resource access and otherwise return errors as in section 3.1
of <xref target="RFC6750"></xref></t>
</li>
<li><t>shall support and verify sender-constrained access tokens using one of the following methods:</t>

<ul>
<li><t>MTLS as described in <xref target="RFC8705"></xref></t>
</li>
<li><t>DPoP as described in <xref target="I-D.ietf-oauth-dpop"></xref></t>
</li>
</ul></li>
</ol>
</section>
</section>

<section anchor="cryptography-and-secrets"><name>Cryptography and Secrets</name>

<ol>
<li><t>Authorization Servers, Clients, and Resource Servers when creating or processing JWTs shall</t>

<ol>
<li><t>adhere to <xref target="RFC8725"></xref></t>
</li>
<li><t>use <tt>PS256</tt>, <tt>ES256</tt>, or <tt>EdDSA</tt> (using the <tt>Ed25519</tt> subtype) algorithms</t>
</li>
<li><t>not use or accept the <tt>none</tt> algorithm</t>
</li>
</ol></li>
<li><t>RSA keys shall have a minimum length of 2048 bits.</t>
</li>
<li><t>Elliptic curve keys shall have a minimum length of 160 bits.</t>
</li>
<li><t>Credentials not intended for handling by end-users (e.g., access tokens,
refresh tokens, authorization codes, etc.) shall be created with at least
128 bits of entropy such that an attacker correctly guessing the value is
computationally infeasible. Cf. Section 10.10 of <xref target="RFC6749"></xref>.</t>
</li>
</ol>
</section>

<section anchor="main-differences-to-fapi-1-0"><name>Main Differences to FAPI 1.0</name>
<table>
<thead>
<tr>
<th align="left">FAPI 1.0 Read/Write</th>
<th align="left">FAPI 2.0</th>
<th align="left">Reasons</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">JAR</td>
<td align="left">PAR</td>
<td align="left">integrity protection and compatibility improvements for authorization requests</td>
</tr>

<tr>
<td align="left">JARM</td>
<td align="left">only code in response</td>
<td align="left">the authorization response is reduced to only contain the authorization code, obsoleting the need for integrity protection</td>
</tr>

<tr>
<td align="left">BCM principles, defenses based on particular threats</td>
<td align="left">attacker model, security goals, best practices from the OAuth Security BCP</td>
<td align="left">clearer design guideline, suitability for formal analysis</td>
</tr>

<tr>
<td align="left"><tt>s_hash</tt></td>
<td align="left">PKCE</td>
<td align="left">protection provided by <tt>state</tt> (in particular against CSRF) is now provided by PKCE; <tt>state</tt> integrity is partially protected by PAR</td>
</tr>

<tr>
<td align="left">pre-registered redirect URIs</td>
<td align="left">redirect URIs in PAR</td>
<td align="left">pre-registration is not required with client authentication and PAR</td>
</tr>

<tr>
<td align="left">response types <tt>code id_token</tt> or <tt>code</tt></td>
<td align="left">response type <tt>code</tt></td>
<td align="left">no ID token in front-channel (privacy improvement); nonce/signature check can be skipped by clients, PKCE cannot (security improvement)</td>
</tr>

<tr>
<td align="left">ID Token as detached signature</td>
<td align="left">PKCE</td>
<td align="left">ID token does not need to serve as a detached signature</td>
</tr>

<tr>
<td align="left">potentially encrypted ID Tokens in the front channel</td>
<td align="left">No encryption and no ID Tokens in the front channel</td>
<td align="left">ID Tokens only exchanged in back channel</td>
</tr>

<tr>
<td align="left"><tt>nbf</tt> &amp; <tt>exp</tt> claims in request object</td>
<td align="left"><tt>request_uri</tt> has limited lifetime</td>
<td align="left">Prevents pre-generation of requests</td>
</tr>

<tr>
<td align="left"><tt>x-fapi-*</tt> headers</td>
<td align="left">Moved to Implementation and Deployment Advice document</td>
<td align="left">Not relevant to the core of the security profile</td>
</tr>

<tr>
<td align="left">MTLS for sender-constrained access tokens</td>
<td align="left">MTLS or DPoP</td>
<td align="left">Due to the lack of the tight integration with the TLS layer, DPoP can be easier to deploy in some scenarios</td>
</tr>
</tbody>
</table></section>

<section anchor="security-considerations"><name>Security Considerations</name>

<section anchor="access-token-lifetimes"><name>Access token lifetimes</name>
<t>The use of short lived access tokens (combined with refresh tokens) potentially reduces the time window for some attacks.</t>
<t>The use of refresh tokens also allows clients to rotate their sender-constraining keys without loss of grants, either because of compromise of the key or as part of good security hygiene.</t>
<t>If issuing long-lived grants (e.g. days/weeks), the use of short lived (e.g. minutes/hours) access tokens combined with refresh tokens should be considered.</t>
<t>There is a performance and resiliency trade off, setting the access token life time too short can increase the load on and dependency on the authorization server.</t>
</section>

<section anchor="dpop-proof-replay"><name>DPoP Proof Replay</name>
<t>An attacker of type A7 (see <xref target="attackermodel"></xref>) may be able to obtain DPoP proofs
that they can then replay.</t>
<t>This may also allow reuse of the DPoP proof with an alterered request, as DPoP does
not sign the body of HTTP requests nor most headers. For example, for a payment request
the attacker might be able to specify a different amount or destination account.</t>
<t>Possible mitigations for this are:</t>

<ol>
<li><t>Resource servers uses short-lived DPoP nonces to reduce the time window where a request can be replayed</t>
</li>
<li><t>Resource servers implement replay preventation using the <tt>jti</tt> header as explained in <xref target="I-D.ietf-oauth-dpop"></xref></t>
</li>
<li><t>Replay of an altered request can be prevented by using signed resource requests as per FAPI Message Signing</t>
</li>
<li><t>Consider MTLS sender-constraining instead of DPoP</t>
</li>
</ol>
<t>These mitigations may have potential complexity, performance or scalability tradeoffs. Attacker type A7 is
represents a powerful attacker and mitigations may not be necessary for many ecosystems.</t>
</section>

<section anchor="jwks-uris"><name>JWKS URIs</name>
<t>This profile supports the use of <tt>private_key_jwt</tt> and in addition allows the use of
OpenID Connect. When these are used Clients and Authorization Servers need to verify
payloads with keys from another party. For Authorization Server's this profile strongly
recommends  the use of JWKS URI endpoints to distribute public keys. For Client's key
management this profile recommends either the use of JWKS URI endpoints or the use of
the <tt>jwks</tt> parameter in combination with <xref target="RFC7591"></xref> and <xref target="RFC7592"></xref>.</t>
<t>The definition of the Authorization Server <tt>jwks_uri</tt> can be found in <xref target="RFC8414"></xref>,
while the definition of the Client <tt>jwks_uri</tt> can be found in <xref target="RFC7591"></xref>.</t>
<t>In addition, this profile</t>

<ol>
<li><t>requires that <tt>jwks_uri</tt> endpoints shall be served over TLS;</t>
</li>
<li><t>recommends that JOSE headers for <tt>x5u</tt> and <tt>jku</tt> should not be used; and</t>
</li>
<li><t>recommends that the JWK set does not contain multiple keys with the same <tt>kid</tt>.</t>
</li>
</ol>
</section>

<section anchor="duplicate-key-identifiers"><name>Duplicate Key Identifiers</name>
<t>JWK sets should not contain multiple keys with the same <tt>kid</tt>. However, to increase
interoperability when there are multiple keys with the same <tt>kid</tt>,  the verifier shall
consider other JWK attributes, such as <tt>kty</tt>, <tt>use</tt>, <tt>alg</tt>, etc., when selecting the
verification key for the particular JWS message. For example, the following algorithm
could be used in selecting which key to use to verify a message signature:</t>

<ol>
<li><t>find keys with a <tt>kid</tt> that matches the <tt>kid</tt> in the JOSE header;</t>
</li>
<li><t>if a single key is found, use that key;</t>
</li>
<li><t>if multiple keys are found, then the verifier should iterate through the keys until a key is found that has a matching <tt>alg</tt>, <tt>use</tt>, <tt>kty</tt>, or <tt>crv</tt> that corresponds to the message being verified.</t>
</li>
</ol>
</section>

<section anchor="injection-of-stolen-access-tokens"><name>Injection of stolen access tokens</name>
<t>There are potential situations where the attacker may be able to inject stolen access
tokens into a client to bypass <xref target="RFC8705"></xref> or <xref target="I-D.ietf-oauth-dpop"></xref>
sender-constraining of the access token, as described in &quot;Cuckoo's Token Attack&quot; in
<xref target="FAPI1SEC"></xref>.</t>
<t>A pre-condition for this attack is that the attacker has control of an authorization
server that is trusted by the client to issue access token for the target resource
server. An attacker may obtain control of an authorization server by:</t>

<ol>
<li><t>Compromising the security of a different authorization server that the client trusts, or</t>
</li>
<li><t>Acting as an authorization server and establishing a trust relationship with a client using social engineering, or by
compromising the client</t>
</li>
</ol>
<t>The attack may be easier if a centralised directory or other resource server discovery mechanism allows the attacker to
cause the client to send the stolen access token received from the attacker controlled Authorization Server to an honest
Resource Server.</t>
<t>The pre-conditions for this attack do not apply to many ecosystems and require a powerful attacker. In situations
where the pre-conditions may be met, the possible mitigations include:</t>

<ol>
<li><t>Clients using different DPoP keys or MTLS certificates at each authorization server</t>
</li>
<li><t>Clients sending the issuer identifier the access token was obtained from to the resource server, and requiring
resource servers to verify the issuer matches the authorization server that originally issued the token (though
there is no standardized method for clients to send the issuer to the resource server)</t>
</li>
<li><t>Reducing the time window for the attack by using short lived access tokens alongside refresh tokens</t>
</li>
</ol>
</section>

<section anchor="authorization-request-leaks-lead-to-csrf"><name>Authorization Request Leaks lead to CSRF</name>
<t>An attacker of type A3a (see <xref target="attackermodel"></xref>) can intercept an authorization request, log in at the
Authorization Server, receive an authorization code and redirect the honest user via a CSRF attack to
the honest client but with the attacker's authorization code. This results in the user accessing the
attackers resources, thus breaking session integrity.</t>
<t>It is important to note that all practically used redirect-based flows are
susceptible to this attack, as redirection does not allow for a tight coupling
of the session between the user's browser and the client on the one side and the
session between the user's browser and the authorization server on the other
side.  This attack, however, requires a strong attacker who can read
authorization requests and perform a CSRF attack in a short time window.</t>
<t>Possible mitigations for this are:</t>

<ol>
<li><t>Requiring the Authorization Server to only accept a <tt>request_uri</tt> once. This
will prevent attacks where the attacker was able to read the authorization
request, but not use the <tt>request_uri</tt> before the honest user does so.</t>
</li>
<li><t>Requiring the Client to only make one authorization code grant call for each
authorization endpoint call. This will prevent attacks where the attacker was
unable to send the authorization response before the honest user does so.</t>
</li>
<li><t>Reducing the lifetime of the authorization code - this will reduce the window
in which the CSRF attack has to be performed.</t>
</li>
</ol>
<t>An attacker that has the option to block a user's request completely can
circumvent the first and second defenses. In practice, however, attackers can
often read an authorization request (e.g., from a log file or via some other
side-channel), but not block the request from being sent. If the victim's
internet connection is slow, this might increase the attacker's chances.</t>
</section>

<section anchor="browser-swapping-attacks"><name>Browser-Swapping Attacks</name>
<t>An attacker that has access to the authorization response sent through a
victim's browser can perform a browser-swapping attack as follows:</t>

<ol>
<li><t>The attacker starts a new flow using their own browser and some
client. The client sends a pushed authorization request to the
authorization server and receives a <tt>request_uri</tt> in the response.
The client then redirects the attacker's browser to the
authorization server.</t>
</li>
<li><t>The attacker intercepts this redirection and forwards the URL to a
victim. For example, the attacker can embed a link to this URL in a
phishing website, an email, or a QR code.</t>
</li>
<li><t>The victim may be tricked into believing that an
authentication/authorization is legitimately required. The victim
therefore authenticates at the authorization server and may grant
the client access to their data.</t>
</li>
<li><t>The attacker can now intercept the authorization response in the
victim's browser and forward it to the client using their own browser.</t>
</li>
<li><t>The client will recognize that the authorization response belongs to
the same browser that initially started the transaction (the
attacker's browser) and exchange the authorization code for an
access token and/or obtain user information.</t>
</li>
<li><t>Via the client, the attacker now has access to the user's resources
or is logged in as the user.</t>
</li>
</ol>
<t>With currently deployed technology, there is no way to completely
prevent this attack if the authorization response leaks to an attacker
in any redirect-based protocol. It is therefore important to keep the
authorization response confidential. The requirements in this security
profile are designed to achieve that, e.g., by disallowing open
redirectors and requiring that the <tt>redirect_uri</tt> is sent via an
authenticated and encrypted channel, the pushed authorization request,
ensuring that the <tt>redirect_uri</tt> cannot be manipulated by the attacker.</t>
<t>Implementers need to consider the confidentiality of the authorization
response critical when designing their systems, in particular when this
security profile is used in other contexts, e.g., mobile applications.</t>
</section>
</section>
</section>

<section anchor="privacy-considerations"><name>Privacy considerations</name>
<t>There are many factors to be considered in terms of privacy when implementing
this specification. Since this specification is a profile of OAuth 2.0 and
OpenID Connect, the privacy considerations are not specific to this document and
generally apply to OAuth or OpenID Connect. Implementers are advised to perform
a thorough privacy impact assessment and manage identified risks appropriately.</t>
<t>Note: Implementers can consult documents like [ISO29100] and [ISO29134] for this
purpose.</t>
<t>Privacy threats to OAuth and OpenID Connect implementations include the following:</t>

<ul>
<li><t><strong>Inappropriate privacy notice</strong>:  A privacy notice (e.g., provided at a
<tt>policy_url</tt>) or by other means can be inappropriate or insufficient.</t>
</li>
<li><t><strong>Inadequate choice</strong>:  Providing a consent screen without adequate choices
does not form consent.</t>
</li>
<li><t><strong>Misuse of data</strong>:  An authorization server, resource server or client can
potentially use the data not according to the purpose that was agreed.</t>
</li>
<li><t><strong>Collection minimization violation</strong>:  A client asking for more data than
it absolutely needs to fulfill the purpose is violating the collection
minimization principle.</t>
</li>
<li><t><strong>Unsolicited personal data from the resource server</strong>:  Some bad resource
server implementations may return more data than requested. If the data is
personal data, then this would be a violation of privacy principles.</t>
</li>
<li><t><strong>Data minimization violation</strong>:  Any process that is processing more data
than it needs is violating the data minimization principle.</t>
</li>
<li><t><strong>Authorization servers tracking end-users</strong>:  Authorization servers
identifying what data is being provided to which client for which end-user.</t>
</li>
<li><t><strong>End-user tracking by clients</strong>:  Two or more clients correlating access
tokens or ID Tokens to track users.</t>
</li>
<li><t><strong>Client misidentification by end-users</strong>:  End-user misunderstands who the
client is due to a confusing representation of the client at the
authorization server's authorization page.</t>
</li>
<li><t><strong>Insufficient understanding of the end-user granting access to data</strong>: To
enhance the trust of the ecosystem, best practice is for the authorization
server to make clear what is included in the authorization request (for
example, what data will be released to the client).</t>
</li>
<li><t><strong>Attacker observing personal data in authorization request/response</strong>:  The authorization request or response might contain personal
data. In some jurisdictions, even security parameters can be considered
personal data. This profile aims to reduce the data sent in the
authorization request and response to an absolute minimum, but nonetheless,
an attacker might observe some data.</t>
</li>
<li><t><strong>Data leak from authorization server</strong>:  The authorization server generally
stores personal data. If it becomes compromised, this data can leak or be
modified.</t>
</li>
<li><t><strong>Data leak from resource servers</strong>:  Some resource servers store personal
data. If a resource server becomes compromised, this data can leak or be
modified.</t>
</li>
<li><t><strong>Data leak from clients</strong>:  Some clients store personal data. If the client
becomes compromised, this data can leak or be modified.</t>
</li>
</ul>
</section>

<section anchor="acknowledgements"><name>Acknowledgements</name>
<t>We would like to thank Takahiko Kawasaki, Filip Skokan, Dave Tonge, Nat Sakimura, Stuart Low, Dima Postnikov, Torsten Lodderstedt, Joseph Heenan, Travis Spencer, Brian Campbell, Ralph Bragg and Lukasz Jaromin for their valuable feedback and contributions that helped to evolve this specification.</t>
</section>

</middle>

<back>
<references><name>Normative References</name>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7592.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6750.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9207.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.9126.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8252.xml"/>
<reference anchor="ISODIR2" target="https://www.iso.org/sites/directives/current/part2/index.xhtml">
  <front>
    <title>ISO/IEC Directives Part 2 - </title>
    <author fullname="International Organization for Standardization">
      <organization></organization>
    </author>
    <date></date>
  </front>
</reference>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-oauth-rar.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7525.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8705.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8414.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8659.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6797.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6125.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-oauth-dpop.xml"/>
<reference anchor="OIDD" target="https://openid.net/specs/openid-connect-discovery-1_0.html">
  <front>
    <title>OpenID Connect Discovery 1.0 incorporating errata set 1</title>
    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>NRI</organization>
    </author>
    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>Ping Identity</organization>
    </author>
    <author fullname="Mike Jones" initials="M." surname="Jones">
      <organization>Microsoft</organization>
    </author>
    <author fullname="Edmund Jay" initials="E." surname="Jay">
      <organization>Illumila</organization>
    </author>
    <date year="2014" month="Nov" day="8"></date>
  </front>
</reference>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8725.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7591.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7636.xml"/>
<reference anchor="OIDC" target="http://openid.net/specs/openid-connect-core-1_0.html">
  <front>
    <title>OpenID Connect Core 1.0 incorporating errata set 1</title>
    <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
      <organization>NRI</organization>
    </author>
    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>Ping Identity</organization>
    </author>
    <author fullname="Mike Jones" initials="M." surname="Jones">
      <organization>Microsoft</organization>
    </author>
    <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
      <organization>Google</organization>
    </author>
    <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
      <organization>Salesforce</organization>
    </author>
    <date year="2014" month="Nov" day="8"></date>
  </front>
</reference>
<reference anchor="attackermodel" target="https://openid.net/specs/fapi-2_0-attacker-model.html">
  <front>
    <title>FAPI 2.0 Attacker Model</title>
    <author fullname="Daniel Fett" initials="D." surname="Fett">
      <organization>yes.com</organization>
    </author>
    <date year="2022" month="Nov" day="14"></date>
  </front>
</reference>
</references>
<references><name>Informative References</name>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml-ids/reference.I-D.ietf-oauth-security-topics.xml"/>
<reference anchor="FAPI1SEC" target="https://arxiv.org/abs/1901.11520">
  <front>
    <title>An Extensive Formal Security Analysis of the OpenID Financial-grade API</title>
    <author fullname="Daniel Fett" initials="D." surname="Fett">
      <organization>yes.com AG</organization>
    </author>
    <author fullname="Pedram Hosseyni" initials="P." surname="Hosseyni">
      <organization>University of Stuttgart, Germany</organization>
    </author>
    <author fullname="Ralf Kuesters" initials="R." surname="Kuesters">
      <organization>University of Stuttgart, Germany</organization>
    </author>
    <date year="2019" month="Jan" day="31"></date>
  </front>
</reference>
<reference anchor="preload" target="https://hstspreload.org/">
  <front>
    <title>HSTS Preload List Submission</title>
    <author fullname="Anonymous">
      <organization></organization>
    </author>
    <date></date>
  </front>
</reference>
</references>

<section anchor="notices"><name>Notices</name>
<t>Copyright (c) 2022 The OpenID Foundation.</t>
<t>The OpenID Foundation (OIDF) grants to any Contributor, developer, implementer, or other interested party a non-exclusive, royalty free, worldwide copyright license to reproduce, prepare derivative works from, distribute, perform and display, this Implementers Draft or Final Specification solely for the purposes of (i) developing specifications, and (ii) implementing Implementers Drafts and Final Specifications based on such documents, provided that attribution be made to the OIDF as the source of the material, but that such attribution does not indicate an endorsement by the OIDF.</t>
<t>The technology described in this specification was made available from contributions from various sources, including members of the OpenID Foundation and others. Although the OpenID Foundation has taken steps to help ensure that the technology is available for distribution, it takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this specification or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any independent effort to identify any such rights. The OpenID Foundation and the contributors to this specification make no (and hereby expressly disclaim any) warranties (express, implied, or otherwise), including implied warranties of merchantability, non-infringement, fitness for a particular purpose, or title, related to this specification, and the entire risk as to implementing this specification is assumed by the implementer. The OpenID Intellectual Property Rights policy requires contributors to offer a patent promise not to assert certain patent claims against other contributors and against implementers. The OpenID Foundation invites any interested party to bring to its attention any copyrights, patents, patent applications, or other proprietary rights that may cover technology that may be required to practice this specification.</t>
</section>

</back>

</rfc>
