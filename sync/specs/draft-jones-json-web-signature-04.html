<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>JSON Web Signature (JWS)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="JSON Web Signature (JWS)">
<meta name="keywords" content="RFC, Request for Comments, I-D, Internet-Draft, Assertion, Simple Web Token, Security Token, SWT, JavaScript Object Notation, JSON, JSON Web Token, JWT, JSON Web Signature, JWS, JSON Web Encryption, JWE, JSON Web Key, JWK">
<meta name="generator" content="xml2rfc v1.36 (http://xml.resource.org/)">
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: small; color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: small; font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: small; font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: small; text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">M. Jones</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Microsoft</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">D. Balfanz</td></tr>
<tr><td class="header">Expires: June 15, 2012</td><td class="header">Google</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">J. Bradley</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">independent</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Y. Goland</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Microsoft</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">J. Panzer</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Google</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">N. Sakimura</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Nomura Research Institute</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">P. Tarjan</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Facebook</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">December 13, 2011</td></tr>
</table></td></tr></table>
<h1><br />JSON Web Signature (JWS)<br />draft-jones-json-web-signature-04</h1>

<h3>Abstract</h3>

<p>
	JSON Web Signature (JWS) is a means of representing signed
	content using JSON data structures.  Related encryption
	capabilities are described in the separate JSON Web Encryption
	(JWE) specification.
      
</p>
<h3>Requirements Language</h3>

<p>
	The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
	NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and
	"OPTIONAL" in this document are to be interpreted as described
	in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
      
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on June 15, 2012.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2011 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Terminology<br />
<a href="#anchor3">3.</a>&nbsp;
JSON Web Signature (JWS) Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ExampleJWS">3.1.</a>&nbsp;
Example JWS<br />
<a href="#anchor4">4.</a>&nbsp;
JWS Header<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ReservedHeaderParameterName">4.1.</a>&nbsp;
Reserved Header Parameter Names<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PublicHeaderParameterName">4.2.</a>&nbsp;
Public Header Parameter Names<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PrivateHeaderParameterName">4.3.</a>&nbsp;
Private Header Parameter Names<br />
<a href="#anchor5">5.</a>&nbsp;
Rules for Creating and Validating a JWS<br />
<a href="#Signing">6.</a>&nbsp;
Signing JWSs with Cryptographic Algorithms<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DefiningHMAC">6.1.</a>&nbsp;
Creating a JWS with HMAC SHA-256, HMAC SHA-384, or HMAC SHA-512<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DefiningRSA">6.2.</a>&nbsp;
Creating a JWS with RSA SHA-256, RSA SHA-384, or RSA SHA-512<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#DefiningECDSA">6.3.</a>&nbsp;
Creating a JWS with ECDSA P-256 SHA-256, ECDSA P-384 SHA-384, or ECDSA P-521 SHA-512<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#MoreAlgs">6.4.</a>&nbsp;
Additional Algorithms<br />
<a href="#IANA">7.</a>&nbsp;
IANA Considerations<br />
<a href="#Security">8.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">8.1.</a>&nbsp;
Unicode Comparison Security Issues<br />
<a href="#TBD">9.</a>&nbsp;
Open Issues and Things To Be Done (TBD)<br />
<a href="#rfc.references1">10.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">10.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">10.2.</a>&nbsp;
Informative References<br />
<a href="#JWSExamples">Appendix&nbsp;A.</a>&nbsp;
JWS Examples<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#HMACSHA256Example">A.1.</a>&nbsp;
JWS using HMAC SHA-256<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">A.1.1.</a>&nbsp;
Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">A.1.2.</a>&nbsp;
Decoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">A.1.3.</a>&nbsp;
Validating<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#RSASHA256Example">A.2.</a>&nbsp;
JWS using RSA SHA-256<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">A.2.1.</a>&nbsp;
Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">A.2.2.</a>&nbsp;
Decoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">A.2.3.</a>&nbsp;
Validating<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ECDSASHA256Example">A.3.</a>&nbsp;
JWS using ECDSA P-256 SHA-256<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">A.3.1.</a>&nbsp;
Encoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">A.3.2.</a>&nbsp;
Decoding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">A.3.3.</a>&nbsp;
Validating<br />
<a href="#algxref">Appendix&nbsp;B.</a>&nbsp;
Algorithm Identifier Cross-Reference<br />
<a href="#base64urlnotes">Appendix&nbsp;C.</a>&nbsp;
Notes on implementing base64url encoding without padding<br />
<a href="#Acknowledgements">Appendix&nbsp;D.</a>&nbsp;
Acknowledgements<br />
<a href="#anchor18">Appendix&nbsp;E.</a>&nbsp;
Document History<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
	JSON Web Signature (JWS) is a compact signature format
	intended for space constrained environments such as HTTP
	Authorization headers and URI query parameters.  It represents
	signed content using JSON <a class='info' href='#RFC4627'>[RFC4627]<span> (</span><span class='info'>Crockford, D., &ldquo;The application/json Media Type for JavaScript Object Notation (JSON),&rdquo; July&nbsp;2006.</span><span>)</span></a> data
	structures.  The JWS signature mechanisms are independent of
	the type of content being signed, allowing arbitrary content
	to be signed.  A related encryption capability is described in
	a separate JSON Web Encryption (JWE) <a class='info' href='#JWE'>[JWE]<span> (</span><span class='info'>Jones, M., Rescorla, E., and J. Hildebrand, &ldquo;JSON Web Encryption (JWE),&rdquo; December&nbsp;2011.</span><span>)</span></a>
	specification.
      
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>
	</p>
<blockquote class="text"><dl>
<dt>JSON Web Signature (JWS)</dt>
<dd>
	    A data structure cryptographically securing a JWS Header
	    and a JWS Payload with a JWS Signature.
	  
</dd>
<dt>JWS Header</dt>
<dd>
	    A string representing a JSON object that describes the
	    signature applied to the JWS Header and the JWS Payload to
	    create the JWS Signature.
	  
</dd>
<dt>JWS Payload</dt>
<dd>
	    The bytes to be signed - a.k.a., the message.
	  
</dd>
<dt>JWS Signature</dt>
<dd>
	    A byte array containing the cryptographic
	    material that secures the contents of the JWS Header
	    and the JWS Payload.
	  
</dd>
<dt>Encoded JWS Header</dt>
<dd>
	    Base64url encoding of the bytes of the
	    UTF-8 <a class='info' href='#RFC3629'>RFC 3629<span> (</span><span class='info'>Yergeau, F., &ldquo;UTF-8, a transformation format of ISO 10646,&rdquo; November&nbsp;2003.</span><span>)</span></a> [RFC3629]
	    representation of the JWS Header.
	  
</dd>
<dt>Encoded JWS Payload</dt>
<dd>
	    Base64url encoding of the JWS Payload.
	  
</dd>
<dt>Encoded JWS Signature</dt>
<dd>
	    Base64url encoding of the JWS Signature.
	  
</dd>
<dt>JWS Signing Input</dt>
<dd>
	    The concatenation of the Encoded JWS Header, a period ('.')
	    character, and the Encoded JWS Payload.
	  
</dd>
<dt>Header Parameter Names</dt>
<dd>
	    The names of the members within the JSON object
	    represented in a JWS Header.
	  
</dd>
<dt>Header Parameter Values</dt>
<dd>
	    The values of the members within the JSON object
	    represented in a JWS Header.
	  
</dd>
<dt>Digital Signature</dt>
<dd>
	    For the purposes of this specification, we use this term
	    to encompass both Hash-based Message Authentication Codes
	    (HMACs), which can provide authenticity but not
	    non-repudiation, and digital signatures using public key
	    algorithms, which can provide both.  Readers should be
	    aware of this distinction, despite the decision to use a
	    single term for both concepts to improve readability of
	    the specification.
	  
</dd>
<dt>Base64url Encoding</dt>
<dd>
	    For the purposes of this specification, this term always
	    refers to the URL- and filename-safe Base64 encoding
	    described in <a class='info' href='#RFC4648'>RFC 4648<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a> [RFC4648],
	    Section 5, with the (non URL-safe) '=' padding characters
	    omitted, as permitted by Section 3.2.  (See <a class='info' href='#base64urlnotes'>Appendix&nbsp;C<span> (</span><span class='info'>Notes on implementing base64url encoding without padding</span><span>)</span></a> for notes on implementing
	    base64url encoding without padding.)
	  
</dd>
</dl></blockquote><p>
      
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
JSON Web Signature (JWS) Overview</h3>

<p>
	JWS represents signed content using JSON data
	structures and base64url encoding. The representation
	consists of three parts: the JWS Header, the JWS Payload,
	and the JWS Signature.  The three parts are
	base64url-encoded for transmission, and typically represented
	as the concatenation of the encoded strings in that order,
	with the three strings being separated by period ('.')
	characters.
      
</p>
<p>
        The JWS Header describes the signature method and parameters employed.
	The JWS Payload is the message content to be secured.
	The JWS Signature ensures the integrity of
	both the JWS Header and the JWS Payload.
      
</p>
<a name="ExampleJWS"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Example JWS</h3>

<p>
	  The following example JWS Header declares that the
	  encoded object is a JSON Web Token (JWT) <a class='info' href='#JWT'>[JWT]<span> (</span><span class='info'>Jones, M., Balfanz, D., Bradley, J., Goland, Y., Panzer, J., Sakimura, N., and P. Tarjan, &ldquo;JSON Web Token (JWT),&rdquo; December&nbsp;2011.</span><span>)</span></a>
	  and the JWS Header and the JWS Payload are
	  signed using the HMAC SHA-256 algorithm:
	
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"typ":"JWT",
 "alg":"HS256"}</pre></div>
<p>
	  Base64url encoding the bytes of the UTF-8 representation of
	  the JWS Header yields this Encoded JWS Header value:
	
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9</pre></div>
<p>
	  The following is an example of a JSON object that can be
	  used as a JWS Payload.  (Note that the payload can be any
	  content, and need not be a representation of a JSON object.)
	
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}</pre></div>
<p>
	  Base64url encoding the bytes of the UTF-8 representation of the JSON
	  object yields the following Encoded JWS Payload
	  (with line breaks for display purposes only):
	
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ</pre></div>
<p>
	  Signing the UTF-8 representation of the JWS Signing Input
	  (the concatenation of the Encoded JWS Header, a period ('.')
	  character, and the Encoded JWS Payload) with the HMAC
	  SHA-256 algorithm and base64url encoding the result, as per
	  <a class='info' href='#DefiningHMAC'>Section&nbsp;6.1<span> (</span><span class='info'>Creating a JWS with HMAC SHA-256, HMAC SHA-384, or HMAC SHA-512</span><span>)</span></a>, yields this
	  Encoded JWS Signature value:
	
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</pre></div>
<p>
	  Concatenating these parts in the order
	  Header.Payload.Signature with period characters between the
	  parts yields this complete JWS representation
	  (with line breaks for display purposes only):
	
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ
.
dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</pre></div>
<p>
	  This computation is illustrated in more detail in <a class='info' href='#HMACSHA256Example'>Appendix&nbsp;A.1<span> (</span><span class='info'>JWS using HMAC SHA-256</span><span>)</span></a>.
	
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
JWS Header</h3>

<p>
	The members of the JSON object represented by the JWS Header describe the signature applied to the Encoded JWS Header and the Encoded JWS Payload and optionally
	additional properties of the JWS.
	The Header Parameter Names within this object MUST be unique.
	Implementations MUST
	understand the entire contents of the header; otherwise, the
	JWS MUST be rejected for processing.
      
</p>
<p>
	The JWS Header MUST contain an <tt>alg</tt>
	parameter, the value of
	which is a string that unambiguously identifies the algorithm
	used to sign the JWS Header and the JWS Payload to
	produce the JWS Signature.
      
</p>
<p>
        There are three classes of Header Parameter Names:
	Reserved Header Parameter Names, Public Header Parameter Names,
	and Private Header Parameter Names.
      
</p>
<a name="ReservedHeaderParameterName"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Reserved Header Parameter Names</h3>

<p>
	  The following header parameter names are reserved.  All
	  the names are short because a core goal of JWSs is for the
	  representations to be compact.
	
</p><br /><hr class="insert" />
<a name="HeaderParameterTable"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left"><col align="left">
<tr><th align="left">Header Parameter Name</th><th align="left">JSON Value Type</th><th align="left">Header Parameter Syntax</th><th align="left">Header Parameter Semantics</th></tr>
<tr>
<td align="left">alg</td>
<td align="left">string</td>
<td align="left">StringOrURI</td>
<td align="left">
	    The <tt>alg</tt> (algorithm) header
	    parameter identifies the cryptographic algorithm used to
	    secure the JWS.  A list of defined
	    <tt>alg</tt> values is presented in <a class='info' href='#AlgTable'>Table&nbsp;3<span> (</span><span class='info'>JWS Defined &quot;alg&quot; Parameter Values</span><span>)</span></a>.  The processing of the <tt>alg</tt> header parameter
	    requires that the value MUST be one that
	    is both supported and for which there exists a key for use
	    with that algorithm associated with the signer of the
	    content.
	    The <tt>alg</tt> parameter value is case sensitive.
	    This header parameter is REQUIRED.
	  </td>
</tr>
<tr>
<td align="left">typ</td>
<td align="left">string</td>
<td align="left">String</td>
<td align="left">
	    The <tt>typ</tt> (type) header
	    parameter is used to declare the type of the signed
	    content.
	    The <tt>typ</tt> value is case sensitive.
	    This header parameter is OPTIONAL.
	  </td>
</tr>
<tr>
<td align="left">jku</td>
<td align="left">string</td>
<td align="left">URL</td>
<td align="left">
	    The <tt>jku</tt> (JSON Web Key URL)
	    header parameter is an absolute URL that refers to a
	    resource for a set of JSON-encoded public keys, one of
	    which corresponds to the key that was used to sign the
	    JWS.
	    The keys MUST be encoded as described in the JSON Web Key
	    (JWK) <a class='info' href='#JWK'>[JWK]<span> (</span><span class='info'>Jones, M., &ldquo;JSON Web Key (JWK),&rdquo; December&nbsp;2011.</span><span>)</span></a> specification.
	    The protocol used to acquire the resource MUST provide
	    integrity protection.  An HTTP GET request to retrieve the
	    certificate MUST use TLS <a class='info' href='#RFC2818'>RFC
	    2818<span> (</span><span class='info'>Rescorla, E., &ldquo;HTTP Over TLS,&rdquo; May&nbsp;2000.</span><span>)</span></a> [RFC2818] <a class='info' href='#RFC5246'>RFC 5246<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a> [RFC5246] with
	    server authentication <a class='info' href='#RFC6125'>RFC
	    6125<span> (</span><span class='info'>Saint-Andre, P. and J. Hodges, &ldquo;Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS),&rdquo; March&nbsp;2011.</span><span>)</span></a> [RFC6125].
	    This header parameter is OPTIONAL.
	  </td>
</tr>
<tr>
<td align="left">kid</td>
<td align="left">string</td>
<td align="left">String</td>
<td align="left">
	    The <tt>kid</tt> (key ID) header
	    parameter is a hint indicating which specific key owned by
	    the signer should be used to validate the signature.  This
	    allows signers to explicitly signal a change of key to
	    recipients.  The interpretation of the
	    contents of the <tt>kid</tt> parameter
	    is unspecified.
	    This header parameter is OPTIONAL.
	  </td>
</tr>
<tr>
<td align="left">x5u</td>
<td align="left">string</td>
<td align="left">URL</td>
<td align="left">
	    The <tt>x5u</tt> (X.509 URL) header
	    parameter is an absolute URL that refers to a resource for
	    the X.509 public key certificate or certificate chain
	    corresponding to the key used to sign the JWS.
	    The identified resource MUST provide a representation of
	    the certificate or certificate chain that conforms to
	    <a class='info' href='#RFC5280'>RFC 5280<span> (</span><span class='info'>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5280] in PEM encoded form
	    <a class='info' href='#RFC1421'>RFC 1421<span> (</span><span class='info'>Linn, J., &ldquo;Privacy Enhancement for Internet Electronic Mail: Part I: Message Encryption and Authentication Procedures,&rdquo; February&nbsp;1993.</span><span>)</span></a> [RFC1421].
	    The protocol used to acquire the resource MUST provide
	    integrity protection.  An HTTP GET request to retrieve the
	    certificate MUST use TLS <a class='info' href='#RFC2818'>RFC
	    2818<span> (</span><span class='info'>Rescorla, E., &ldquo;HTTP Over TLS,&rdquo; May&nbsp;2000.</span><span>)</span></a> [RFC2818] <a class='info' href='#RFC5246'>RFC 5246<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.2,&rdquo; August&nbsp;2008.</span><span>)</span></a> [RFC5246] with
	    server authentication <a class='info' href='#RFC6125'>RFC
	    6125<span> (</span><span class='info'>Saint-Andre, P. and J. Hodges, &ldquo;Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS),&rdquo; March&nbsp;2011.</span><span>)</span></a> [RFC6125].
	    This header parameter is OPTIONAL.
	  </td>
</tr>
<tr>
<td align="left">x5t</td>
<td align="left">string</td>
<td align="left">String</td>
<td align="left">
	    The <tt>x5t</tt> (x.509 certificate
	    thumbprint) header parameter provides a base64url encoded
	    SHA-1 thumbprint (a.k.a. digest) of the DER encoding of an
	    X.509 certificate that can be used to match the certificate.
	    This header parameter is OPTIONAL.
	  </td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 1: Reserved Header Parameter Definitions&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
	  Additional reserved header parameter names MAY be defined
	  via the IANA JSON Web Signature Header Parameters registry,
	  as per <a class='info' href='#IANA'>Section&nbsp;7<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>.  The syntax values used above
	  are defined as follows:
	
</p><br /><hr class="insert" />
<a name="SyntaxDefinitions"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Syntax Name</th><th align="left">Syntax Definition</th></tr>
<tr>
<td align="left">IntDate</td>
<td align="left">
	    The number of seconds from 1970-01-01T0:0:0Z as measured
	    in UTC until the desired date/time. See <a class='info' href='#RFC3339'>RFC 3339<span> (</span><span class='info'>Klyne, G., Ed. and C. Newman, &ldquo;Date and Time on the Internet: Timestamps,&rdquo; July&nbsp;2002.</span><span>)</span></a> [RFC3339] for details regarding
	    date/times in general and UTC in particular.
	  </td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">
	    Any string value MAY be used.
	  </td>
</tr>
<tr>
<td align="left">StringOrURI</td>
<td align="left">
	    Any string value MAY be used but a value containing a ":"
	    character MUST be a URI as defined in <a class='info' href='#RFC3986'>RFC 3986<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a> [RFC3986].
	  </td>
</tr>
<tr>
<td align="left">URL</td>
<td align="left">
	    A URL as defined in <a class='info' href='#RFC1738'>RFC 1738<span> (</span><span class='info'>Berners-Lee, T., Masinter, L., and M. McCahill, &ldquo;Uniform Resource Locators (URL),&rdquo; December&nbsp;1994.</span><span>)</span></a> [RFC1738].
	  </td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 2: Header Parameter Syntax Definitions&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="PublicHeaderParameterName"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Public Header Parameter Names</h3>

<p>
	  Additional header parameter names can be defined by those
	  using JWSs. However, in order to prevent collisions, any new
	  header parameter name or algorithm value SHOULD either be
	  defined in the IANA JSON Web Signature Header Parameters
	  registry or be defined as a URI that contains a collision
	  resistant namespace.  In each case, the definer of the name
	  or value needs to take reasonable precautions to make sure they
	  are in control of the part of the namespace they use to
	  define the header parameter name.
	
</p>
<p>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWSs.
	
</p>
<a name="PrivateHeaderParameterName"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Private Header Parameter Names</h3>

<p>
	  A producer and consumer of a JWS may agree to any header
	  parameter name that is not a Reserved Name <a class='info' href='#ReservedHeaderParameterName'>Section&nbsp;4.1<span> (</span><span class='info'>Reserved Header Parameter Names</span><span>)</span></a> or a Public
	  Name <a class='info' href='#PublicHeaderParameterName'>Section&nbsp;4.2<span> (</span><span class='info'>Public Header Parameter Names</span><span>)</span></a>. Unlike Public
	  Names, these private names are subject to collision and
	  should be used with caution.
	
</p>
<p>
	  New header parameters should be introduced sparingly, as
	  they can result in non-interoperable JWSs.
	
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Rules for Creating and Validating a JWS</h3>

<p>
	To create a JWS, one MUST perform these steps:

        </p>
<ol class="text">
<li>
	    Create the content to be used as the JWS Payload.
	  
</li>
<li>
	    Base64url encode the bytes of the JWS Payload.  This
	    encoding becomes the Encoded JWS Payload.
	  
</li>
<li>
	    Create a JWS Header containing the desired set of header
	    parameters.  Note that white space is explicitly allowed
	    in the representation and no canonicalization is performed
	    before encoding.
	  
</li>
<li>
	    Base64url encode the bytes of the UTF-8 representation of
	    the JWS Header to create the Encoded JWS Header.
	  
</li>
<li>
	    Compute the JWS Signature in the manner defined for
	    the particular algorithm being used.  The JWS Signing
	    Input is always the concatenation of the Encoded JWS Header,
	    a period ('.') character, and the Encoded JWS Payload.  The
	    <tt>alg</tt> header parameter MUST be
	    present in the JSON Header, with the algorithm value
	    accurately representing the algorithm used to construct
	    the JWS Signature.
	  
</li>
<li>
	    Base64url encode the representation of the JWS Signature to create the Encoded JWS Signature.
	  
</li>
</ol><p>
      
</p>
<p>
	When validating a JWS, the following steps MUST be taken. If
	any of the listed steps fails, then the signed content MUST be
	rejected.
      
</p>
<p>
	</p>
<ol class="text">
<li>
	    The Encoded JWS Header MUST be successfully base64url
	    decoded following the restriction given in this specification that
	    no padding characters have been used.
	  
</li>
<li>
	    The JWS Header MUST be completely valid
	    JSON syntax conforming to <a class='info' href='#RFC4627'>RFC
	    4627<span> (</span><span class='info'>Crockford, D., &ldquo;The application/json Media Type for JavaScript Object Notation (JSON),&rdquo; July&nbsp;2006.</span><span>)</span></a> [RFC4627].
	  
</li>
<li>
	    The JWS Header MUST be validated to only include
	    parameters and values whose syntax and semantics are both
	    understood and supported.
	  
</li>
<li>
	    The Encoded JWS Payload MUST be successfully base64url
	    decoded following the restriction given in this specification that
	    no padding characters have been used.
	  
</li>
<li>
	    The Encoded JWS Signature MUST be successfully base64url
	    decoded following the restriction given in this specification that
	    no padding characters have been used.
	  
</li>
<li>
	    The JWS Signature MUST be successfully validated
	    against the JWS Header and JWS Payload
	    in the manner defined for the algorithm being used, which
	    MUST be accurately represented by the value of the <tt>alg</tt>
	    header parameter, which MUST be present.
	  
</li>
</ol><p>
      
</p>
<p>
	Processing a JWS inevitably requires comparing known strings
	to values in the header. For example, in checking what the
	algorithm is, the Unicode string encoding <tt>alg</tt> will be
	checked against the member names in the JWS Header
	to see if there is a matching header parameter
	name. A similar process occurs when determining if the value
	of the <tt>alg</tt> header parameter represents a supported
	algorithm.
      
</p>
<p>
	Comparisons between JSON strings and other Unicode strings
	MUST be performed as specified below:

	</p>
<ol class="text">
<li>
	    Remove any JSON applied escaping to produce an array of
	    Unicode code points.
	  
</li>
<li>
	    <a class='info' href='#USA15'>Unicode Normalization<span> (</span><span class='info'>Davis, M., Whistler, K., and M. D&uuml;rst, &ldquo;Unicode Normalization Forms,&rdquo; 09&nbsp;2009.</span><span>)</span></a> [USA15] MUST NOT
	    be applied at any point to either the JSON string or to
	    the string it is to be compared against.
	  
</li>
<li>
	    Comparisons between the two strings MUST be performed as a
	    Unicode code point to code point equality comparison.
	  
</li>
</ol><p>
      
</p>
<a name="Signing"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Signing JWSs with Cryptographic Algorithms</h3>

<p>
	JWSs use specific cryptographic algorithms to sign the contents
	of the JWS Header and the JWS Payload.  The
	use of the following algorithms for producing JWSs is defined in
	this section.  The table below is the list of <tt>alg</tt> header
	parameter values defined by this specification, each of which
	is explained in more detail in the following sections:
      
</p><br /><hr class="insert" />
<a name="AlgTable"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Alg Parameter Value</th><th align="left">Algorithm</th></tr>
<tr>
<td align="left">HS256</td>
<td align="left">HMAC using SHA-256 hash algorithm</td>
</tr>
<tr>
<td align="left">HS384</td>
<td align="left">HMAC using SHA-384 hash algorithm</td>
</tr>
<tr>
<td align="left">HS512</td>
<td align="left">HMAC using SHA-512 hash algorithm</td>
</tr>
<tr>
<td align="left">RS256</td>
<td align="left">RSA using SHA-256 hash algorithm</td>
</tr>
<tr>
<td align="left">RS384</td>
<td align="left">RSA using SHA-384 hash algorithm</td>
</tr>
<tr>
<td align="left">RS512</td>
<td align="left">RSA using SHA-512 hash algorithm</td>
</tr>
<tr>
<td align="left">ES256</td>
<td align="left">ECDSA using P-256 curve and SHA-256 hash algorithm</td>
</tr>
<tr>
<td align="left">ES384</td>
<td align="left">ECDSA using P-384 curve and SHA-384 hash algorithm</td>
</tr>
<tr>
<td align="left">ES512</td>
<td align="left">ECDSA using P-521 curve and SHA-512 hash algorithm</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 3: JWS Defined "alg" Parameter Values&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
	See <a class='info' href='#algxref'>Appendix&nbsp;B<span> (</span><span class='info'>Algorithm Identifier Cross-Reference</span><span>)</span></a> for a table cross-referencing the <tt>alg</tt> values used in this specification
	with the equivalent identifiers used by other
	standards and software packages.
      
</p>
<p>
	Of these algorithms, only HMAC SHA-256 MUST be implemented by
	conforming implementations.  It is RECOMMENDED that
	implementations also support the RSA SHA-256 and ECDSA P-256
	SHA-256 algorithms.  Support for other algorithms and key
	sizes is OPTIONAL.
      
</p>
<p>
	The signed content for a JWS is the same for all algorithms:
	the concatenation of the Encoded JWS Header, a period ('.')
	character, and the Encoded JWS Payload.  This character sequence
	is referred to as the JWS Signing Input.  Note that if the JWS
	represents a JWT, this corresponds to the portion of the JWT
	representation preceding the second period character.  The
	UTF-8 representation of the JWS Signing Input is passed to the
	respective signing algorithms.
      
</p>
<a name="DefiningHMAC"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Creating a JWS with HMAC SHA-256, HMAC SHA-384, or HMAC SHA-512</h3>

<p>
	  Hash based Message Authentication Codes (HMACs) enable one to
	  use a secret plus a cryptographic hash function to generate a
	  Message Authentication Code (MAC). This can be used to
	  demonstrate that the MAC matches the hashed content, in this
	  case the JWS Signing Input, which therefore demonstrates that
	  whoever generated the MAC was in possession of the secret.
	  The means of exchanging the shared key is outside the scope
	  of this specification.
	
</p>
<p>
	  The algorithm for implementing and validating HMACs is
	  provided in <a class='info' href='#RFC2104'>RFC 2104<span> (</span><span class='info'>Krawczyk, H., Bellare, M., and R. Canetti, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a> [RFC2104].  This
	  section defines the use of the HMAC SHA-256, HMAC SHA-384,
	  and HMAC SHA-512 cryptographic hash functions as defined in
	  <a class='info' href='#FIPS.180-3'>FIPS 180-3<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Secure Hash Standard (SHS),&rdquo; October&nbsp;2008.</span><span>)</span></a> [FIPS.180&#8209;3]. The
	  <tt>alg</tt> header parameter values
	  <tt>HS256</tt>, <tt>HS384</tt>, and <tt>HS512</tt> are used in the JWS Header
	  to indicate that the Encoded JWS Signature contains a base64url
	  encoded HMAC value using the respective hash function.
	
</p>
<p>
	  The HMAC SHA-256 MAC is generated as follows:

	  </p>
<ol class="text">
<li>
	      Apply the HMAC SHA-256 algorithm to the UTF-8
	      representation of the JWS Signing Input using the shared
	      key to produce an HMAC value.
	    
</li>
<li>
	      Base64url encode the resulting HMAC value.
	    
</li>
</ol><p>

	  The output is the Encoded JWS Signature for that JWS.
	
</p>
<p>
	  The HMAC SHA-256 MAC for a JWS is validated as follows:

	  </p>
<ol class="text">
<li>
	      Apply the HMAC SHA-256 algorithm to the UTF-8
	      representation of the JWS Signing Input of the JWS using
	      the shared key.
	    
</li>
<li>
	      Base64url encode the resulting HMAC value.
	    
</li>
<li>
	      If the JWS Signature and the base64url encoded HMAC
	      value exactly match, then one has confirmation that the
	      shared key was used to generate the HMAC on the JWS and that the
	      contents of the JWS have not be tampered with.
	    
</li>
<li>
	      If the validation fails, the signed content MUST be rejected.
	    
</li>
</ol><p>
	
</p>
<p>
	  Signing with the HMAC SHA-384 and HMAC SHA-512 algorithms is
	  performed identically to the procedure for HMAC SHA-256 - just
	  with correspondingly longer key and result values.
	
</p>
<a name="DefiningRSA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Creating a JWS with RSA SHA-256, RSA SHA-384, or RSA SHA-512</h3>

<p>
	  This section defines the use of the RSASSA-PKCS1-v1_5
	  signature algorithm as defined in <a class='info' href='#RFC3447'>RFC
	  3447<span> (</span><span class='info'>Jonsson, J. and B. Kaliski, &ldquo;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1,&rdquo; February&nbsp;2003.</span><span>)</span></a> [RFC3447], Section 8.2 (commonly known as PKCS#1), using
	  SHA-256, SHA-384, or SHA-512 as the hash function.  The
	  RSASSA-PKCS1-v1_5 algorithm is described in <a class='info' href='#FIPS.186-3'>FIPS 186-3<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Digital Signature Standard (DSS),&rdquo; June&nbsp;2009.</span><span>)</span></a> [FIPS.186&#8209;3], Section 5.5, and the
	  SHA-256, SHA-384, and SHA-512 cryptographic hash functions
	  are defined in <a class='info' href='#FIPS.180-3'>FIPS 180-3<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Secure Hash Standard (SHS),&rdquo; October&nbsp;2008.</span><span>)</span></a> [FIPS.180&#8209;3].
	  The <tt>alg</tt> header
	  parameter values <tt>RS256</tt>, <tt>RS384</tt>, and <tt>RS512</tt> are used in the JWS Header
	  to indicate that the Encoded JWS Signature contains a base64url
	  encoded RSA signature using the respective hash function.
	
</p>
<p>
	  The public keys employed can be identified using Header
	  Parameter methods described in <a class='info' href='#ReservedHeaderParameterName'>Section&nbsp;4.1<span> (</span><span class='info'>Reserved Header Parameter Names</span><span>)</span></a> or can be
	  distributed using methods that are outside the scope of this
	  specification.
	
</p>
<p>
	  A 2048-bit or longer key length MUST be used with this
	  algorithm.
	
</p>
<p>
	  The RSA SHA-256 signature is generated as follows:

	  </p>
<ol class="text">
<li>
	      Generate a digital signature of the UTF-8 representation
	      of the JWS Signing Input using RSASSA-PKCS1-V1_5-SIGN
	      and the SHA-256 hash function with the desired private
	      key. The output will be a byte array.
	    
</li>
<li>
	      Base64url encode the resulting byte array.
	    
</li>
</ol><p>

	  The output is the Encoded JWS Signature for that JWS.
	
</p>
<p>
	  The RSA SHA-256 signature for a JWS is validated as follows:

	  </p>
<ol class="text">
<li>
	      Take the Encoded JWS Signature and base64url decode it into
	      a byte array. If decoding fails, the signed content MUST
	      be rejected.
	    
</li>
<li>
	      Submit the UTF-8 representation of the JWS Signing Input
	      and the public key corresponding to the private key used
	      by the signer to the RSASSA-PKCS1-V1_5-VERIFY algorithm
	      using SHA-256 as the hash function.
	    
</li>
<li>
	      If the validation fails, the signed content MUST be rejected.
	    
</li>
</ol><p>
	
</p>
<p>
	  Signing with the RSA SHA-384 and RSA SHA-512 algorithms is
	  performed identically to the procedure for RSA SHA-256 - just
	  with correspondingly longer key and result values.
	
</p>
<a name="DefiningECDSA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Creating a JWS with ECDSA P-256 SHA-256, ECDSA P-384 SHA-384, or ECDSA P-521 SHA-512</h3>

<p>
	  The Elliptic Curve Digital Signature Algorithm (ECDSA) is
	  defined by <a class='info' href='#FIPS.186-3'>FIPS 186-3<span> (</span><span class='info'>National Institute of Standards and             Technology, &ldquo;Digital Signature Standard (DSS),&rdquo; June&nbsp;2009.</span><span>)</span></a> [FIPS.186&#8209;3]. ECDSA
	  provides for the use of Elliptic Curve cryptography, which is
	  able to provide equivalent security to RSA cryptography but
	  using shorter key lengths and with greater processing
	  speed. This means that ECDSA signatures will be substantially
	  smaller in terms of length than equivalently strong RSA
	  Digital Signatures.
	
</p>
<p>
	  This specification defines the use of ECDSA with the P-256
	  curve and the SHA-256 cryptographic hash function, ECDSA
	  with the P-384 curve and the SHA-384 hash function, and
	  ECDSA with the P-521 curve and the SHA-512 hash
	  function. The P-256, P-384, and P-521 curves are also
	  defined in FIPS 186-3. The <tt>alg</tt> header parameter values <tt>ES256</tt>, <tt>ES384</tt>, and <tt>ES512</tt> are used in the JWS Header
	  to indicate that the Encoded JWS Signature contains a base64url
	  encoded ECDSA P-256 SHA-256, ECDSA P-384 SHA-384, or ECDSA
	  P-521 SHA-512 signature, respectively.
	
</p>
<p>
	  The public keys employed can be identified using Header
	  Parameter methods described in <a class='info' href='#ReservedHeaderParameterName'>Section&nbsp;4.1<span> (</span><span class='info'>Reserved Header Parameter Names</span><span>)</span></a> or can be
	  distributed using methods that are outside the scope of this
	  specification.
	
</p>
<p>
	  A JWS is signed with an ECDSA P-256 SHA-256 signature as
	  follows:

	  </p>
<ol class="text">
<li>
	      Generate a digital signature of the UTF-8 representation
	      of the JWS Signing Input using ECDSA P-256 SHA-256 with
	      the desired private key. The output will be the EC point
	      (R, S), where R and S are unsigned integers.
	    
</li>
<li>
	      Turn R and S into byte arrays in big endian order. Each
	      array will be 32 bytes long.
	    
</li>
<li>
	      Concatenate the two byte arrays in the order R and then S.
	    
</li>
<li>
	      Base64url encode the resulting 64 byte array.
	    
</li>
</ol><p>

	  The output is the Encoded JWS Signature for the JWS.
	
</p>
<p>
	  The ECDSA P-256 SHA-256 signature for a JWS is validated as follows:

	  </p>
<ol class="text">
<li>
	      Take the Encoded JWS Signature and base64url decode it into
	      a byte array. If decoding fails, the signed content MUST
	      be rejected.
	    
</li>
<li>
	      The output of the base64url decoding MUST be a 64 byte
	      array.
	    
</li>
<li>
	      Split the 64 byte array into two 32 byte arrays. The first
	      array will be R and the second S. Remember that the byte
	      arrays are in big endian byte order; please check the
	      ECDSA validator in use to see what byte order it requires.
	    
</li>
<li>
	      Submit the UTF-8 representation of the JWS Signing
	      Input, R, S and the public key (x, y) to the ECDSA P-256
	      SHA-256 validator.
	    
</li>
<li>
	      If the validation fails, the signed content MUST be rejected.
	    
</li>
</ol><p>

	  The ECDSA validator will then determine if the digital
	  signature is valid, given the inputs.  Note that ECDSA digital
	  signature contains a value referred to as K, which is a random
	  number generated for each digital signature instance. This
	  means that two ECDSA digital signatures using exactly the same
	  input parameters will output different signatures because
	  their K values will be different. The consequence of this is
	  that one must validate an ECDSA signature by submitting the
	  previously specified inputs to an ECDSA validator.
	
</p>
<p>
	  Signing with the ECDSA P-384 SHA-384 and ECDSA P-521 SHA-512
	  algorithms is performed identically to the procedure for ECDSA
	  P-256 SHA-256 - just with correspondingly longer key and
	  result values.
	
</p>
<a name="MoreAlgs"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4"></a><h3>6.4.&nbsp;
Additional Algorithms</h3>

<p>
	  Additional algorithms MAY be used to protect JWSs with
	  corresponding <tt>alg</tt> header parameter values being defined to
	  refer to them. New <tt>alg</tt> header parameter values SHOULD
	  either be defined in the IANA JSON Web Signature Algorithms
	  registry or be a URI that contains a collision resistant
	  namespace.  In particular, it is permissible to use the algorithm identifiers
	  defined in <a class='info' href='#RFC3275'>XML DSIG<span> (</span><span class='info'>Eastlake, D., Reagle, J., and D. Solo, &ldquo;(Extensible Markup Language) XML-Signature Syntax and Processing,&rdquo; March&nbsp;2002.</span><span>)</span></a> [RFC3275] and
	  related specifications as <tt>alg</tt> values.
	
</p>
<a name="IANA"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>
	This specification calls for:

        </p>
<ul class="text">
<li>
	    A new IANA registry entitled "JSON Web Signature Header
	    Parameters" for reserved header parameter names is defined
	    in <a class='info' href='#ReservedHeaderParameterName'>Section&nbsp;4.1<span> (</span><span class='info'>Reserved Header Parameter Names</span><span>)</span></a>.
	    Inclusion in the registry is RFC Required in the <a class='info' href='#RFC5226'>RFC 5226<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5226] sense for reserved JWS
	    header parameter names that are intended to be
	    interoperable between implementations.  The registry will
	    just record the reserved header parameter name and a
	    pointer to the RFC that defines it. This specification
	    defines inclusion of the header parameter names defined in
	    <a class='info' href='#HeaderParameterTable'>Table&nbsp;1<span> (</span><span class='info'>Reserved Header Parameter Definitions</span><span>)</span></a>.
	  
</li>
<li>
	    A new IANA registry entitled "JSON Web Signature Algorithms"
	    for values of the <tt>alg</tt> header parameter
	    is defined in <a class='info' href='#MoreAlgs'>Section&nbsp;6.4<span> (</span><span class='info'>Additional Algorithms</span><span>)</span></a>. Inclusion
	    in the registry is RFC Required in the <a class='info' href='#RFC5226'>RFC 5226<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5226] sense. The registry will
	    just record the <tt>alg</tt> value and a pointer to the RFC that
	    defines it.  This specification defines inclusion of the
	    algorithm values defined in <a class='info' href='#AlgTable'>Table&nbsp;3<span> (</span><span class='info'>JWS Defined &quot;alg&quot; Parameter Values</span><span>)</span></a>.
	  
</li>
</ul><p>
      
</p>
<a name="Security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>
	TBD: Lots of work to do here. We need to remember to look into
	any issues relating to security and JSON parsing. One wonders
	just how secure most JSON parsing libraries are. Were they
	ever hardened for security scenarios? If not, what kind of
	holes does that open up? Also, we need to walk through the
	JSON standard and see what kind of issues we have especially
	around comparison of names.  For instance, comparisons of
	header parameter names and other parameters must occur after
	they are unescaped. Need to also put in text about: Importance
	of keeping secrets secret. Rotating keys. Strengths and
	weaknesses of the different algorithms.
      
</p>
<p>
	TBD: Need to put in text about why strict JSON validation is
	necessary.  Basically, that if malformed JSON is received then
	the intent of the sender is impossible to reliably discern.
	One example of malformed JSON that MUST be rejected is
	an object in which the same member name occurs multiple times.
      
</p>
<p>
	TBD: Write security considerations about the implications of
	using a SHA-1 hash (for compatibility reasons) for the
	<tt>x5t</tt> (x.509 certificate
	thumbprint).
      
</p>
<p>
	When utilizing TLS to retrieve information, the authority
	providing the resource MUST be authenticated and the
	information retrieved MUST be free from modification.
      
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Unicode Comparison Security Issues</h3>

<p>
	  Header parameter names in JWSs are Unicode strings.  For
	  security reasons, the representations of these names must be
	  compared verbatim after performing any escape processing (as
	  per <a class='info' href='#RFC4627'>RFC 4627<span> (</span><span class='info'>Crockford, D., &ldquo;The application/json Media Type for JavaScript Object Notation (JSON),&rdquo; July&nbsp;2006.</span><span>)</span></a> [RFC4627], Section 2.5).
	
</p>
<p>
	  This means, for instance, that these JSON strings must
	  compare as being equal ("sig", "\u0073ig"), whereas these
	  must all compare as being not equal to the first set or to
	  each other ("SIG", "Sig", "si\u0047").
	
</p>
<p>
	  JSON strings MAY contain characters outside the Unicode
	  Basic Multilingual Plane.  For instance, the G clef
	  character (U+1D11E) may be represented in a JSON string as
	  "\uD834\uDD1E".  Ideally, JWS implementations SHOULD ensure
	  that characters outside the Basic Multilingual Plane are
	  preserved and compared correctly; alternatively, if this is
	  not possible due to these characters exercising limitations
	  present in the underlying JSON implementation, then input
	  containing them MUST be rejected.
	
</p>
<a name="TBD"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Open Issues and Things To Be Done (TBD)</h3>

<p>
	The following items remain to be done in this draft:

	</p>
<ul class="text">
<li>
	    Consider whether there is a better term than "Digital
	    Signature" for the concept that includes both HMACs and
	    digital signatures using public keys.
	  
</li>
<li>
	    Clarify the optional ability to provide type information in
	    the JWS header.  Specifically, clarify the intended use of
	    the <tt>typ</tt> Header Parameter,
	    whether it conveys syntax or semantics, and indeed, whether
	    this is the right approach.  Also clarify the relationship
	    between these type values and <a class='info' href='#RFC2045'>MIME<span> (</span><span class='info'>Freed, N. and N. Borenstein, &ldquo;Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies,&rdquo; November&nbsp;1996.</span><span>)</span></a> [RFC2045] types.
	  
</li>
<li>
	    Clarify the semantics of the <tt>kid</tt>
	    (key ID) header parameter.  Open issues include: What
	    happens if a <tt>kid</tt> header is
	    received with an unrecognized value? Is that an error?
	    Should it be treated as if it's empty? What happens if the
	    header has a recognized value but the value doesn't match
	    the key associated with that value, but it does match
	    another key that is associated with the issuer? Is that an
	    error?
	  
</li>
<li>
	    Consider whether a key type parameter should also be introduced.
	  
</li>
<li>
	    Since RFC 3447 Section 8 explicitly calls for people NOT to
	    adopt RSASSA-PKCS1 for new applications and instead requests
	    that people transition to RSASSA-PSS, we probably need some
	    Security Considerations text explaining why RSASSA-PKCS1 is
	    being used (it's what's commonly implemented) and what the
	    potential consequences are.
	  
</li>
<li>
	    Add Security Considerations text on timing attacks.
	  
</li>
<li>
	    It would be good to have a confirmation method element so
	    it could be used with holder-of-key.
	  
</li>
<li>
	    Consider whether to add parameters for directly including
	    keys in the header, either as JWK Key Objects, or X.509
	    cert values, or both.
	  
</li>
<li>
	    Consider whether to add version numbers.
	  
</li>
<li>
	    Think about how to best describe the concept currently
	    described as "the bytes of the UTF-8 representation of".
	    Possible terms to use instead of "bytes of" include "byte
	    sequence", "octet series", and "octet sequence".  Also
	    consider whether we want to add an overall clarifying
	    statement somewhere in each spec something like "every
	    place we say 'the UTF-8 representation of X', we mean 'the
	    bytes of the UTF-8 representation of X'".  That would
	    potentially allow us to omit the "the bytes of" part
	    everywhere else.
	  
</li>
<li>
	    Finish the Security Considerations section.
	  
</li>
<li>
	    Add an example in which the payload is not a base64url
	    encoded JSON object.
	  
</li>
<li>
	    Consider having an algorithm that is a MAC using SHA-256
	    that provides content integrity but for which there is no
	    associated secret.  This would be like the JWT
	    "alg":"none", in that no validation of the authenticity
	    content is performed but a checksum is provided.
	  
</li>
<li>
	    Consider whether to define "alg":"none" here,
	    rather than in the JWT spec.
	  
</li>
</ul><p>
      
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="FIPS.180-3">[FIPS.180-3]</a></td>
<td class="author-text">National Institute of Standards and
            Technology, &ldquo;<a href="http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf">Secure Hash Standard (SHS)</a>,&rdquo; FIPS&nbsp;PUB 180-3, October&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="FIPS.186-3">[FIPS.186-3]</a></td>
<td class="author-text">National Institute of Standards and
            Technology, &ldquo;<a href="http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf">Digital Signature Standard (DSS)</a>,&rdquo; FIPS&nbsp;PUB 186-3, June&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="JWK">[JWK]</a></td>
<td class="author-text"><a href="mailto:mbj@microsoft.com">Jones, M.</a>, &ldquo;<a href="http://tools.ietf.org/html/draft-jones-json-web-key">JSON Web Key (JWK)</a>,&rdquo; December&nbsp;2011.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1421">[RFC1421]</a></td>
<td class="author-text"><a href="mailto:104-8456@mcimail.com">Linn, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1421">Privacy Enhancement for Internet Electronic Mail: Part I: Message Encryption and Authentication Procedures</a>,&rdquo; RFC&nbsp;1421, February&nbsp;1993 (<a href="http://www.rfc-editor.org/rfc/rfc1421.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC1738">[RFC1738]</a></td>
<td class="author-text"><a href="mailto:timbl@info.cern.ch">Berners-Lee, T.</a>, <a href="mailto:masinter@parc.xerox.com">Masinter, L.</a>, and <a href="mailto:mpm@boombox.micro.umn.edu">M. McCahill</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1738">Uniform Resource Locators (URL)</a>,&rdquo; RFC&nbsp;1738, December&nbsp;1994 (<a href="http://www.rfc-editor.org/rfc/rfc1738.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2045">[RFC2045]</a></td>
<td class="author-text"><a href="mailto:ned@innosoft.com">Freed, N.</a> and <a href="mailto:nsb@nsb.fv.com">N. Borenstein</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>,&rdquo; RFC&nbsp;2045, November&nbsp;1996 (<a href="http://www.rfc-editor.org/rfc/rfc2045.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2104">[RFC2104]</a></td>
<td class="author-text"><a href="mailto:hugo@watson.ibm.com">Krawczyk, H.</a>, <a href="mailto:mihir@cs.ucsd.edu">Bellare, M.</a>, and <a href="mailto:canetti@watson.ibm.com">R. Canetti</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>,&rdquo; RFC&nbsp;2104, February&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2104.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2818">[RFC2818]</a></td>
<td class="author-text">Rescorla, E., &ldquo;<a href="http://tools.ietf.org/html/rfc2818">HTTP Over TLS</a>,&rdquo; RFC&nbsp;2818, May&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2818.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3339">[RFC3339]</a></td>
<td class="author-text"><a href="mailto:GK@ACM.ORG">Klyne, G., Ed.</a> and <a href="mailto:chris.newman@sun.com">C. Newman</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3339">Date and Time on the Internet: Timestamps</a>,&rdquo; RFC&nbsp;3339, July&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3339.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3339.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3339.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3447">[RFC3447]</a></td>
<td class="author-text">Jonsson, J. and B. Kaliski, &ldquo;<a href="http://tools.ietf.org/html/rfc3447">Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</a>,&rdquo; RFC&nbsp;3447, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3447.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3629">[RFC3629]</a></td>
<td class="author-text">Yergeau, F., &ldquo;<a href="http://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>,&rdquo; STD&nbsp;63, RFC&nbsp;3629, November&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3629.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3986">[RFC3986]</a></td>
<td class="author-text"><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com">Fielding, R.</a>, and <a href="mailto:LMM@acm.org">L. Masinter</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>,&rdquo; STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3986.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3986.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3986.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4627">[RFC4627]</a></td>
<td class="author-text">Crockford, D., &ldquo;<a href="http://tools.ietf.org/html/rfc4627">The application/json Media Type for JavaScript Object Notation (JSON)</a>,&rdquo; RFC&nbsp;4627, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4627.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4648">[RFC4648]</a></td>
<td class="author-text">Josefsson, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>,&rdquo; RFC&nbsp;4648, October&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4648.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5226">[RFC5226]</a></td>
<td class="author-text">Narten, T. and H. Alvestrand, &ldquo;<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;5226, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5226.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5246">[RFC5246]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>,&rdquo; RFC&nbsp;5246, August&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5246.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5280">[RFC5280]</a></td>
<td class="author-text">Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>,&rdquo; RFC&nbsp;5280, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5280.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC6125">[RFC6125]</a></td>
<td class="author-text">Saint-Andre, P. and J. Hodges, &ldquo;<a href="http://tools.ietf.org/html/rfc6125">Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)</a>,&rdquo; RFC&nbsp;6125, March&nbsp;2011 (<a href="http://www.rfc-editor.org/rfc/rfc6125.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="USA15">[USA15]</a></td>
<td class="author-text"><a href="mailto:markdavis@google.com">Davis, M.</a>, <a href="mailto:ken@unicode.org">Whistler, K.</a>, and M. D&uuml;rst, &ldquo;Unicode Normalization Forms,&rdquo; Unicode Standard Annex&nbsp;15, 09&nbsp;2009.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="CanvasApp">[CanvasApp]</a></td>
<td class="author-text">Facebook, &ldquo;<a href="http://developers.facebook.com/docs/authentication/canvas">Canvas Applications</a>,&rdquo; 2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="JCA">[JCA]</a></td>
<td class="author-text">Oracle, &ldquo;<a href="http://download.java.net/jdk7/docs/technotes/guides/security/SunProviders.html">Java Cryptography Architecture</a>,&rdquo; 2011.</td></tr>
<tr><td class="author-text" valign="top"><a name="JSS">[JSS]</a></td>
<td class="author-text">Bradley, J. and N. Sakimura (editor), &ldquo;<a href="http://jsonenc.info/jss/1.0/">JSON Simple Sign</a>,&rdquo; September&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="JWE">[JWE]</a></td>
<td class="author-text"><a href="mailto:mbj@microsoft.com">Jones, M.</a>, <a href="mailto:ekr@rtfm.com">Rescorla, E.</a>, and <a href="mailto:jhildebr@cisco.com">J. Hildebrand</a>, &ldquo;<a href="http://tools.ietf.org/html/draft-jones-json-web-encryption">JSON Web Encryption (JWE)</a>,&rdquo; December&nbsp;2011.</td></tr>
<tr><td class="author-text" valign="top"><a name="JWT">[JWT]</a></td>
<td class="author-text"><a href="mailto:mbj@microsoft.com">Jones, M.</a>, <a href="mailto:balfanz@google.com">Balfanz, D.</a>, <a href="mailto:ve7jtb@ve7jtb.com">Bradley, J.</a>, <a href="mailto:yarong@microsoft.com">Goland, Y.</a>, <a href="mailto:jpanzer@google.com">Panzer, J.</a>, <a href="mailto:n-sakimura@nri.co.jp">Sakimura, N.</a>, and <a href="mailto:pt@fb.com">P. Tarjan</a>, &ldquo;<a href="http://tools.ietf.org/html/draft-jones-json-web-token">JSON Web Token (JWT)</a>,&rdquo; December&nbsp;2011.</td></tr>
<tr><td class="author-text" valign="top"><a name="MagicSignatures">[MagicSignatures]</a></td>
<td class="author-text">Panzer (editor), J., Laurie, B., and D. Balfanz, &ldquo;<a href="http://salmon-protocol.googlecode.com/svn/trunk/draft-panzer-magicsig-experimental-00.html">Magic Signatures</a>,&rdquo; August&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3275">[RFC3275]</a></td>
<td class="author-text">Eastlake, D., Reagle, J., and D. Solo, &ldquo;<a href="http://tools.ietf.org/html/rfc3275">(Extensible Markup Language) XML-Signature Syntax and Processing</a>,&rdquo; RFC&nbsp;3275, March&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3275.txt">TXT</a>).</td></tr>
</table>

<a name="JWSExamples"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A"></a><h3>Appendix A.&nbsp;
JWS Examples</h3>

<p>
	This section provides several examples of JWSs.  While these
	examples all represent JSON Web Tokens (JWTs) <a class='info' href='#JWT'>[JWT]<span> (</span><span class='info'>Jones, M., Balfanz, D., Bradley, J., Goland, Y., Panzer, J., Sakimura, N., and P. Tarjan, &ldquo;JSON Web Token (JWT),&rdquo; December&nbsp;2011.</span><span>)</span></a>, the payload can be any base64url encoded
	content.
      
</p>
<a name="HMACSHA256Example"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1"></a><h3>A.1.&nbsp;
JWS using HMAC SHA-256</h3>

<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1.1"></a><h3>A.1.1.&nbsp;
Encoding</h3>

<p>
	    The following example JWS Header declares that the
	    data structure is a JSON Web Token (JWT) <a class='info' href='#JWT'>[JWT]<span> (</span><span class='info'>Jones, M., Balfanz, D., Bradley, J., Goland, Y., Panzer, J., Sakimura, N., and P. Tarjan, &ldquo;JSON Web Token (JWT),&rdquo; December&nbsp;2011.</span><span>)</span></a>
	    and the JWS Signing Input is signed using
	    the HMAC SHA-256 algorithm.  Note that white space is
	    explicitly allowed in JWS Header strings and
	    no canonicalization is performed before encoding.
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"typ":"JWT",
 "alg":"HS256"}</pre></div>
<p>
	    The following byte array contains the UTF-8 characters for
	    the JWS Header:
	  
</p>
<p>

[123, 34, 116, 121, 112, 34, 58, 34, 74, 87, 84, 34, 44, 13, 10, 32, 34, 97, 108, 103, 34, 58, 34, 72, 83, 50, 53, 54, 34, 125]

	  
</p>
<p>
	    Base64url encoding this UTF-8 representation yields this
	    Encoded JWS Header value:
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9</pre></div>
<p>
	    The JWS Payload used in this example
	    follows.  (Note that the payload can be any base64url
	    encoded content, and need not be a base64url encoded JSON
	    object.)
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}</pre></div>
<p>
	     The following byte array contains the UTF-8 characters
	     for the JWS Payload:
	  
</p>
<p>

[123, 34, 105, 115, 115, 34, 58, 34, 106, 111, 101, 34, 44, 13, 10, 32, 34, 101, 120, 112, 34, 58, 49, 51, 48, 48, 56, 49, 57, 51, 56, 48, 44, 13, 10, 32, 34, 104, 116, 116, 112, 58, 47, 47, 101, 120, 97, 109, 112, 108, 101, 46, 99, 111, 109, 47, 105, 115, 95, 114, 111, 111, 116, 34, 58, 116, 114, 117, 101, 125]

	  
</p>
<p>
	    Base64url encoding the above yields the Encoded JWS Payload value
	    (with line breaks for display purposes only):
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ</pre></div>
<p>
	    Concatenating the Encoded JWS Header, a period character,
	    and the Encoded JWS Payload yields this JWS Signing Input
	    value (with line breaks for display purposes only):
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ</pre></div>
<p>
	    The UTF-8 representation of the JWS Signing Input is the
	    following byte array:
	  
</p>
<p>

[101, 121, 74, 48, 101, 88, 65, 105, 79, 105, 74, 75, 86, 49, 81, 105, 76, 65, 48, 75, 73, 67, 74, 104, 98, 71, 99, 105, 79, 105, 74, 73, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  
</p>
<p>
	    HMACs are generated using keys. This example uses the key
	    represented by the following byte array:
	  
</p>
<p>

[3, 35, 53, 75, 43, 15, 165, 188, 131, 126, 6, 101, 119, 123, 166, 143, 90, 179, 40, 230, 240, 84, 201, 40, 169, 15, 132, 178, 210, 80, 46, 191, 211, 251, 90, 146, 210, 6, 71, 239, 150, 138, 180, 195, 119, 98, 61, 34, 61, 46, 33, 114, 5, 46, 79, 8, 192, 205, 154, 245, 103, 208, 128, 163]

	  
</p>
<p>
	    Running the HMAC SHA-256 algorithm on the UTF-8
	    representation of the JWS Signing Input with this key
	    yields the following byte array:
	  
</p>
<p>

[116, 24, 223, 180, 151, 153, 224, 37, 79, 250, 96, 125, 216, 173, 187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91, 88, 5, 88, 83, 132, 141, 121]

	  
</p>
<p>
	    Base64url encoding the above HMAC output yields the
	    Encoded JWS Signature value:
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk</pre></div>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1.2"></a><h3>A.1.2.&nbsp;
Decoding</h3>

<p>
	    Decoding the JWS first requires removing the base64url
	    encoding from the Encoded JWS Header, the Encoded JWS Payload,
	    and the Encoded JWS Signature. We base64url decode
	    the inputs and
	    turn them into the corresponding byte arrays.  We
	    translate the header input byte array containing UTF-8
	    encoded characters into the JWS Header
	    string.
	  
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.1.3"></a><h3>A.1.3.&nbsp;
Validating</h3>

<p>
	    Next we validate the decoded results.  Since the <tt>alg</tt>
	    parameter in the header is "HS256", we validate the HMAC
	    SHA-256 signature contained in the JWS Signature.  If
	    any of the validation steps fail, the signed content MUST be
	    rejected.
	  
</p>
<p>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  
</p>
<p>
	    To validate the signature, we repeat the previous process
	    of using the correct key and the UTF-8 representation of
	    the JWS Signing Input as input to a SHA-256 HMAC function
	    and then taking the output and determining if it matches
	    the JWS Signature.  If it matches exactly,
	    the signature has been validated.
	  
</p>
<a name="RSASHA256Example"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2"></a><h3>A.2.&nbsp;
JWS using RSA SHA-256</h3>

<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.1"></a><h3>A.2.1.&nbsp;
Encoding</h3>

<p>
	    The JWS Header in this example is different
	    from the previous example in two ways:  First, because a
	    different algorithm is being used, the <tt>alg</tt> value is
	    different.  Second, for illustration purposes only, the
	    optional "typ" parameter is not used.  (This difference is
	    not related to the signature algorithm employed.)  The
	    JWS Header used is:
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"alg":"RS256"}</pre></div>
<p>
	    The following byte array contains the UTF-8 characters for
	    the JWS Header:
	  
</p>
<p>

[123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53, 54, 34, 125]

	  
</p>
<p>
	    Base64url encoding this UTF-8 representation yields this
	    Encoded JWS Header value:
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJhbGciOiJSUzI1NiJ9</pre></div>
<p>
	    The JWS Payload used in this example, which
	    follows, is the same as in the previous example.  Since
	    the Encoded JWS Payload will therefore be the same, its
	    computation is not repeated here.
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}</pre></div>
<p>
	    Concatenating the Encoded JWS Header, a period character,
	    and the Encoded JWS Payload yields this JWS Signing Input
	    value (with line breaks for display purposes only):
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJhbGciOiJSUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ</pre></div>
<p>
	    The UTF-8 representation of the JWS Signing Input is the
	    following byte array:
	  
</p>
<p>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  
</p>
<p>
	    The RSA key consists of a public part (n, e), and a
	    private exponent d.  The values of the RSA key used in
	    this example, presented as the byte arrays representing
	    big endian integers are:
	  
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Parameter Name</th><th align="left">Value</th></tr>
<tr>
<td align="left">n</td>
<td align="left">

[161, 248, 22, 10, 226, 227, 201, 180, 101, 206, 141, 45, 101, 98, 99, 54, 43, 146, 125, 190, 41, 225, 240, 36, 119, 252, 22, 37, 204, 144, 161, 54, 227, 139, 217, 52, 151, 197, 182, 234, 99, 221, 119, 17, 230, 124, 116, 41, 249, 86, 176, 251, 138, 143, 8, 154, 220, 75, 105, 137, 60, 193, 51, 63, 83, 237, 208, 25, 184, 119, 132, 37, 47, 236, 145, 79, 228, 133, 119, 105, 89, 75, 234, 66, 128, 211, 44, 15, 85, 191, 98, 148, 79, 19, 3, 150, 188, 110, 155, 223, 110, 189, 210, 189, 163, 103, 142, 236, 160, 198, 104, 247, 1, 179, 141, 191, 251, 56, 200, 52, 44, 226, 254, 109, 39, 250, 222, 74, 90, 72, 116, 151, 157, 212, 185, 207, 154, 222, 196, 199, 91, 5, 133, 44, 44, 15, 94, 248, 165, 193, 117, 3, 146, 249, 68, 232, 237, 100, 193, 16, 198, 182, 71, 96, 154, 164, 120, 58, 235, 156, 108, 154, 215, 85, 49, 48, 80, 99, 139, 131, 102, 92, 111, 111, 122, 130, 163, 150, 112, 42, 31, 100, 27, 130, 211, 235, 242, 57, 34, 25, 73, 31, 182, 134, 135, 44, 87, 22, 245, 10, 248, 53, 141, 154, 139, 157, 23, 195, 64, 114, 143, 127, 135, 216, 154, 24, 216, 252, 171, 103, 173, 132, 89, 12, 46, 207, 117, 147, 57, 54, 60, 7, 3, 77, 111, 96, 111, 158, 33, 224, 84, 86, 202, 229, 233, 161]

	    </td>
</tr>
<tr>
<td align="left">e</td>
<td align="left">

[1, 0, 1]

	    </td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">

[18, 174, 113, 164, 105, 205, 10, 43, 195, 126, 82, 108, 69, 0, 87, 31, 29, 97, 117, 29, 100, 233, 73, 112, 123, 98, 89, 15, 157, 11, 165, 124, 150, 60, 64, 30, 63, 207, 47, 44, 211, 189, 236, 136, 229, 3, 191, 198, 67, 155, 11, 40, 200, 47, 125, 55, 151, 103, 31, 82, 19, 238, 216, 193, 90, 37, 216, 213, 206, 160, 2, 94, 227, 171, 46, 139, 127, 121, 33, 111, 198, 59, 234, 86, 39, 83, 180, 6, 68, 198, 161, 81, 39, 217, 178, 149, 69, 64, 160, 187, 225, 163, 5, 86, 152, 45, 78, 159, 222, 95, 100, 37, 241, 77, 75, 113, 52, 65, 181, 93, 199, 59, 155, 74, 237, 204, 146, 172, 227, 146, 126, 55, 245, 125, 12, 253, 94, 117, 129, 250, 81, 44, 143, 73, 97, 169, 235, 11, 128, 248, 168, 7, 70, 114, 138, 85, 255, 70, 71, 31, 52, 37, 6, 59, 157, 83, 100, 47, 94, 222, 30, 132, 214, 19, 8, 26, 250, 92, 34, 208, 81, 40, 91, 214, 59, 148, 59, 86, 93, 137, 138, 5, 104, 84, 19, 229, 60, 60, 108, 101, 37, 255, 31, 227, 78, 61, 220, 112, 240, 213, 100, 80, 253, 164, 139, 161, 46, 16, 78, 157, 235, 159, 184, 24, 129, 225, 196, 189, 242, 93, 146, 71, 244, 80, 200, 101, 146, 121, 104, 231, 115, 52, 244, 65, 79, 117, 167, 80, 225, 57, 84, 110, 58, 138, 115, 157]

	    </td>
</tr>
</table>
<br clear="all" />

<p>
	    The RSA private key (n, d) is then passed to the RSA
	    signing function, which also takes the hash type, SHA-256,
	    and the UTF-8 representation of the JWS Signing Input as
	    inputs.  The result of the signature is a byte array S,
	    which represents a big endian integer.  In this example, S
	    is:
	  
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Result Name</th><th align="left">Value</th></tr>
<tr>
<td align="left">S</td>
<td align="left">

[112, 46, 33, 137, 67, 232, 143, 209, 30, 181, 216, 45, 191, 120, 69, 243, 65, 6, 174, 27, 129, 255, 247, 115, 17, 22, 173, 209, 113, 125, 131, 101, 109, 66, 10, 253, 60, 150, 238, 221, 115, 162, 102, 62, 81, 102, 104, 123, 0, 11, 135, 34, 110, 1, 135, 237, 16, 115, 249, 69, 229, 130, 173, 252, 239, 22, 216, 90, 121, 142, 232, 198, 109, 219, 61, 184, 151, 91, 23, 208, 148, 2, 190, 237, 213, 217, 217, 112, 7, 16, 141, 178, 129, 96, 213, 248, 4, 12, 167, 68, 87, 98, 184, 31, 190, 127, 249, 217, 46, 10, 231, 111, 36, 242, 91, 51, 187, 230, 244, 74, 230, 30, 177, 4, 10, 203, 32, 4, 77, 62, 249, 18, 142, 212, 1, 48, 121, 91, 212, 189, 59, 65, 238, 202, 208, 102, 171, 101, 25, 129, 253, 228, 141, 247, 127, 55, 45, 195, 139, 159, 175, 221, 59, 239, 177, 139, 93, 163, 204, 60, 46, 176, 47, 158, 58, 65, 214, 18, 202, 173, 21, 145, 18, 115, 160, 95, 35, 185, 232, 56, 250, 175, 132, 157, 105, 132, 41, 239, 90, 30, 136, 121, 130, 54, 195, 212, 14, 96, 69, 34, 165, 68, 200, 242, 122, 122, 45, 184, 6, 99, 209, 108, 247, 202, 234, 86, 222, 64, 92, 178, 33, 90, 69, 178, 194, 85, 102, 181, 90, 193, 167, 72, 160, 112, 223, 200, 163, 42, 70, 149, 67, 208, 25, 238, 251, 71]

	    </td>
</tr>
</table>
<br clear="all" />

<p>
	    Base64url encoding the signature produces this value for
	    the Encoded JWS Signature
	    (with line breaks for display purposes only):
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7
AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4
BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K
0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqv
hJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrB
p0igcN_IoypGlUPQGe77Rw</pre></div>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.2"></a><h3>A.2.2.&nbsp;
Decoding</h3>

<p>
	    Decoding the JWS from this example requires processing the
	    Encoded JWS Header and Encoded JWS Payload exactly as
	    done in the first example.
	  
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.2.3"></a><h3>A.2.3.&nbsp;
Validating</h3>

<p>
	    Since the <tt>alg</tt> parameter in the header is "RS256", we
	    validate the RSA SHA-256 signature contained in the JWS Signature.  If any of the validation steps fail, the
	    signed content MUST be rejected.
	  
</p>
<p>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  
</p>
<p>
	    Validating the JWS Signature is a little different
	    from the previous example. First, we base64url decode the
	    Encoded JWS Signature to produce a signature S to check.  We
	    then pass (n, e), S and the UTF-8 representation of the
	    JWS Signing Input to an RSA signature verifier that has
	    been configured to use the SHA-256 hash function.
	  
</p>
<a name="ECDSASHA256Example"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3"></a><h3>A.3.&nbsp;
JWS using ECDSA P-256 SHA-256</h3>

<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3.1"></a><h3>A.3.1.&nbsp;
Encoding</h3>

<p>
	    The JWS Header for this example differs from
	    the previous example because a different algorithm is
	    being used.  The JWS Header used is:
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"alg":"ES256"}</pre></div>
<p>
	    The following byte array contains the UTF-8 characters for
	    the JWS Header:
	  
</p>
<p>

[123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53, 54, 34, 125]

	  
</p>
<p>
	    Base64url encoding this UTF-8 representation yields this
	    Encoded JWS Header value:
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJhbGciOiJFUzI1NiJ9</pre></div>
<p>
	    The JWS Payload used in this example, which
	    follows, is the same as in the previous examples.  Since
	    the Encoded JWS Payload will therefore be the same, its
	    computation is not repeated here.
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>{"iss":"joe",
 "exp":1300819380,
 "http://example.com/is_root":true}</pre></div>
<p>
	    Concatenating the Encoded JWS Header, a period character,
	    and the Encoded JWS Payload yields this JWS Signing Input
	    value (with line breaks for display purposes only):
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>eyJhbGciOiJFUzI1NiJ9
.
eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt
cGxlLmNvbS9pc19yb290Ijp0cnVlfQ</pre></div>
<p>
	    The UTF-8 representation of the JWS Signing Input is the
	    following byte array:
	  
</p>
<p>

[101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122, 73, 49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105, 74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72, 65, 105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48, 99, 110, 86, 108, 102, 81]

	  
</p>
<p>
	    The ECDSA key consists of a public part, the EC point (x,
	    y), and a private part d.  The values of the ECDSA key
	    used in this example, presented as the byte arrays
	    representing big endian integers are:
	  
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Parameter Name</th><th align="left">Value</th></tr>
<tr>
<td align="left">x</td>
<td align="left">

[127, 205, 206, 39, 112, 246, 196, 93, 65, 131, 203, 238, 111, 219, 75, 123, 88, 7, 51, 53, 123, 233, 239, 19, 186, 207, 110, 60, 123, 209, 84, 69]

	    </td>
</tr>
<tr>
<td align="left">y</td>
<td align="left">

[199, 241, 68, 205, 27, 189, 155, 126, 135, 44, 223, 237, 185, 238, 185, 244, 179, 105, 93, 110, 169, 11, 36, 173, 138, 70, 35, 40, 133, 136, 229, 173]

	    </td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">

[142, 155, 16, 158, 113, 144, 152, 191, 152, 4, 135, 223, 31, 93, 119, 233, 203, 41, 96, 110, 190, 210, 38, 59, 95, 87, 194, 19, 223, 132, 244, 178]

	    </td>
</tr>
</table>
<br clear="all" />

<p>
	    The ECDSA private part d is then passed to an ECDSA
	    signing function, which also takes the curve type, P-256,
	    the hash type, SHA-256, and the UTF-8 representation of
	    the JWS Signing Input as inputs.  The result of the
	    signature is the EC point (R, S), where R and S are
	    unsigned integers.  In this example, the R and S values,
	    given as byte arrays representing big endian integers are:
	  
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Result Name</th><th align="left">Value</th></tr>
<tr>
<td align="left">R</td>
<td align="left">

[14, 209, 33, 83, 121, 99, 108, 72, 60, 47, 127, 21, 88, 7, 212, 2, 163, 178, 40, 3, 58, 249, 124, 126, 23, 129, 154, 195, 22, 158, 166, 101]

	    </td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">

[197, 10, 7, 211, 140, 60, 112, 229, 216, 241, 45, 175, 8, 74, 84, 128, 166, 101, 144, 197, 242, 147, 80, 154, 143, 63, 127, 138, 131, 163, 84, 213]

	    </td>
</tr>
</table>
<br clear="all" />

<p>
	    Concatenating the S array to the end of the R array and
	    base64url encoding the result produces this value for the
	    Encoded JWS Signature
	    (with line breaks for display purposes only):
	  
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSA
pmWQxfKTUJqPP3-Kg6NU1Q</pre></div>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3.2"></a><h3>A.3.2.&nbsp;
Decoding</h3>

<p>
	    Decoding the JWS from this example requires processing the
	    Encoded JWS Header and Encoded JWS Payload exactly as
	    done in the first example.
	  
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.A.3.3"></a><h3>A.3.3.&nbsp;
Validating</h3>

<p>
	    Since the <tt>alg</tt> parameter in the header is "ES256", we
	    validate the ECDSA P-256 SHA-256 signature contained in
	    the JWS Signature.  If any of the validation steps
	    fail, the signed content MUST be rejected.
	  
</p>
<p>
	    First, we validate that the JWS Header
	    string is legal JSON.
	  
</p>
<p>
	    Validating the JWS Signature is a little different
	    from the first example. First, we base64url decode the Encoded JWS Signature as in the previous examples but we then
	    need to split the 64 member byte array that must result
	    into two 32 byte arrays, the first R and the second S. We
	    then pass (x, y), (R, S) and the UTF-8 representation of
	    the JWS Signing Input to an ECDSA signature verifier that
	    has been configured to use the P-256 curve with the
	    SHA-256 hash function.
	  
</p>
<p>
	    As explained in <a class='info' href='#DefiningECDSA'>Section&nbsp;6.3<span> (</span><span class='info'>Creating a JWS with ECDSA P-256 SHA-256, ECDSA P-384 SHA-384, or ECDSA P-521 SHA-512</span><span>)</span></a>, the
	    use of the k value in ECDSA means that we cannot validate
	    the correctness of the signature in the same way we
	    validated the correctness of the HMAC. Instead,
	    implementations MUST use an ECDSA validator to validate
	    the signature.
	  
</p>
<a name="algxref"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.B"></a><h3>Appendix B.&nbsp;
Algorithm Identifier Cross-Reference</h3>

<p>
	This appendix contains a table cross-referencing the <tt>alg</tt> values used in this specification
	with the equivalent identifiers used by other standards and
	software packages.  See <a class='info' href='#RFC3275'>XML DSIG<span> (</span><span class='info'>Eastlake, D., Reagle, J., and D. Solo, &ldquo;(Extensible Markup Language) XML-Signature Syntax and Processing,&rdquo; March&nbsp;2002.</span><span>)</span></a> [RFC3275]
	and <a class='info' href='#JCA'>Java Cryptography Architecture<span> (</span><span class='info'>Oracle, &ldquo;Java Cryptography Architecture,&rdquo; 2011.</span><span>)</span></a> [JCA]
	for more information about the names defined by those
	documents.

      
</p><br /><hr class="insert" />
<a name="algxreftable"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left"><col align="left"><col align="left">
<tr><th align="left">Algorithm</th><th align="left">JWS</th><th align="left">XML DSIG</th><th align="left">JCA</th><th align="left">OID</th></tr>
<tr>
<td align="left">HMAC using SHA-256 hash algorithm</td>
<td align="left">HS256</td>
<td align="left">http://www.w3.org/2001/04/xmldsig-more#hmac-sha256</td>
<td align="left">HmacSHA256</td>
<td align="left">1.2.840.113549.2.9</td>
</tr>
<tr>
<td align="left">HMAC using SHA-384 hash algorithm</td>
<td align="left">HS384</td>
<td align="left">http://www.w3.org/2001/04/xmldsig-more#hmac-sha384</td>
<td align="left">HmacSHA384</td>
<td align="left">1.2.840.113549.2.10</td>
</tr>
<tr>
<td align="left">HMAC using SHA-512 hash algorithm</td>
<td align="left">HS512</td>
<td align="left">http://www.w3.org/2001/04/xmldsig-more#hmac-sha512</td>
<td align="left">HmacSHA512</td>
<td align="left">1.2.840.113549.2.11</td>
</tr>
<tr>
<td align="left">RSA using SHA-256 hash algorithm</td>
<td align="left">RS256</td>
<td align="left">http://www.w3.org/2001/04/xmldsig-more#rsa-sha256</td>
<td align="left">SHA256withRSA</td>
<td align="left">1.2.840.113549.1.1.11</td>
</tr>
<tr>
<td align="left">RSA using SHA-384 hash algorithm</td>
<td align="left">RS384</td>
<td align="left">http://www.w3.org/2001/04/xmldsig-more#rsa-sha384</td>
<td align="left">SHA384withRSA</td>
<td align="left">1.2.840.113549.1.1.12</td>
</tr>
<tr>
<td align="left">RSA using SHA-512 hash algorithm</td>
<td align="left">RS512</td>
<td align="left">http://www.w3.org/2001/04/xmldsig-more#rsa-sha512</td>
<td align="left">SHA512withRSA</td>
<td align="left">1.2.840.113549.1.1.13</td>
</tr>
<tr>
<td align="left">ECDSA using P-256 curve and SHA-256 hash algorithm</td>
<td align="left">ES256</td>
<td align="left">http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256</td>
<td align="left">SHA256withECDSA</td>
<td align="left">1.2.840.10045.4.3.2</td>
</tr>
<tr>
<td align="left">ECDSA using P-384 curve and SHA-384 hash algorithm</td>
<td align="left">ES384</td>
<td align="left">http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384</td>
<td align="left">SHA384withECDSA</td>
<td align="left">1.2.840.10045.4.3.3</td>
</tr>
<tr>
<td align="left">ECDSA using P-521 curve and SHA-512 hash algorithm</td>
<td align="left">ES512</td>
<td align="left">http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512</td>
<td align="left">SHA512withECDSA</td>
<td align="left">1.2.840.10045.4.3.4</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 4: Algorithm Identifier Cross-Reference&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="base64urlnotes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.C"></a><h3>Appendix C.&nbsp;
Notes on implementing base64url encoding without padding</h3>

<p>
	This appendix describes how to implement base64url encoding
	and decoding functions without padding based upon standard
	base64 encoding and decoding functions that do use padding.
      
</p>
<p>
	To be concrete, example C# code implementing these functions
	is shown below.  Similar code could be used in other
	languages.
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>static string base64urlencode(byte [] arg)
{
  string s = Convert.ToBase64String(arg); // Standard base64 encoder
  s = s.Split('=')[0]; // Remove any trailing '='s
  s = s.Replace('+', '-'); // 62nd char of encoding
  s = s.Replace('/', '_'); // 63rd char of encoding
  return s;
}

static byte [] base64urldecode(string arg)
{
  string s = arg;
  s = s.Replace('-', '+'); // 62nd char of encoding
  s = s.Replace('_', '/'); // 63rd char of encoding
  switch (s.Length % 4) // Pad with trailing '='s
  {
    case 0: break; // No pad chars in this case
    case 2: s += "=="; break; // Two pad chars
    case 3: s += "="; break; // One pad char
    default: throw new System.Exception(
      "Illegal base64url string!");
  }
  return Convert.FromBase64String(s); // Standard base64 decoder
}</pre></div>
<p>
	As per the example code above, the number of '=' padding
	characters that needs to be added to the end of a base64url
	encoded string without padding to turn it into one with
	padding is a deterministic function of the length of the
	encoded string.  Specifically,

	if the length mod 4 is 0, no padding is added;
	if the length mod 4 is 2, two '=' padding characters are added;
	if the length mod 4 is 3, one '=' padding character is added;
	if the length mod 4 is 1, the input is malformed.
      
</p>
<p>
	An example correspondence between unencoded and encoded values
	follows.  The byte sequence below encodes into the string
	below, which when decoded, reproduces the byte sequence.
      
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>3 236 255 224 193</pre></div><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>A-z_4ME</pre></div>
<a name="Acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.D"></a><h3>Appendix D.&nbsp;
Acknowledgements</h3>

<p>
	Solutions for signing JSON content were previously explored by
	<a class='info' href='#MagicSignatures'>Magic Signatures<span> (</span><span class='info'>Panzer (editor), J., Laurie, B., and D. Balfanz, &ldquo;Magic Signatures,&rdquo; August&nbsp;2010.</span><span>)</span></a> [MagicSignatures], <a class='info' href='#JSS'>JSON Simple Sign<span> (</span><span class='info'>Bradley, J. and N. Sakimura (editor), &ldquo;JSON Simple Sign,&rdquo; September&nbsp;2010.</span><span>)</span></a> [JSS], and <a class='info' href='#CanvasApp'>Canvas Applications<span> (</span><span class='info'>Facebook, &ldquo;Canvas Applications,&rdquo; 2010.</span><span>)</span></a> [CanvasApp], all of which
	influenced this draft.
      
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.E"></a><h3>Appendix E.&nbsp;
Document History</h3>

<p>
        -04
        </p>
<ul class="text">
<li>
	    Removed "if present" clause from <tt>alg</tt> description.
	  
</li>
<li>
	    Moved "MUST" requirements from the Overview to later in
	    the spec.
	  
</li>
<li>
	    Respect line length restrictions in examples.
	  
</li>
<li>
	    Corrected OID numbers for ECDSA algorithms.
          
</li>
<li>
	    Applied other editorial improvements.
	  
</li>
</ul><p>
      
</p>
<p>
        -03
        </p>
<ul class="text">
<li>
	    Simplified terminology to better match JWE, where the
	    terms "JWS Header" and "Encoded JWS Header", are now used,
	    for instance, rather than the previous terms "Decoded JWS
	    Header Input" and "JWS Header Input".  Likewise the terms
	    "JWS Payload" and "JWS Signature" are now used, rather
	    than "JWS Payload Input" and "JWS Crypto Output".
	  
</li>
<li>
	    The <tt>jku</tt> and <tt>x5u</tt> URLs are now required to be
	    absolute URLs.
	  
</li>
<li>
	    Removed this unnecessary language from the <tt>kid</tt> description: "Omitting this
	    parameter is equivalent to setting it to an empty string".
	  
</li>
<li>
	    Changed StringAndURI to StringOrURI.
	  
</li>
</ul><p>
      
</p>
<p>
        -02
        </p>
<ul class="text">
<li>
	    Reference the JSON Web Key (JWK) specification from the
	    <tt>jku</tt> header parameter.
	  
</li>
</ul><p>
      
</p>
<p>
        -01
        </p>
<ul class="text">
<li>
	    Changed RSA SHA-256 from MUST be supported to RECOMMENDED
	    that it be supported.  Rationale: Several people have
	    objected to the requirement for implementing RSA SHA-256,
	    some because they will only be using HMACs and symmetric
	    keys, and others because they only want to use ECDSA when
	    using asymmetric keys, either for security or key length
	    reasons, or both.
	  
</li>
<li>
	    Clarified that <tt>x5u</tt> is an HTTPS
	    URL referencing a PEM-encoded certificate or certificate
	    chain.
	  
</li>
<li>
	    Clarified that the <tt>alg</tt>
	    parameter value is case sensitive.
	  
</li>
<li>
	    Changed <tt>x5t</tt> (x.509 certificate
	    thumbprint) to use a SHA-1 hash, rather than a SHA-256
	    hash, for compatibility reasons.
	  
</li>
</ul><p>
      
</p>
<p>
        -00
        </p>
<ul class="text">
<li>
            Created first signature draft using content split from
            draft-jones-json-web-token-01.  This split introduced no
            semantic changes.
          
</li>
</ul><p>
      
</p>
<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Michael B. Jones</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Microsoft</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mbj@microsoft.com">mbj@microsoft.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://self-issued.info/">http://self-issued.info/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Dirk Balfanz</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:balfanz@google.com">balfanz@google.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">John Bradley</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">independent</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:ve7jtb@ve7jtb.com">ve7jtb@ve7jtb.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Yaron Y. Goland</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Microsoft</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:yarong@microsoft.com">yarong@microsoft.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">John Panzer</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Google</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jpanzer@google.com">jpanzer@google.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nat Sakimura</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nomura Research Institute</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:n-sakimura@nri.co.jp">n-sakimura@nri.co.jp</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Paul Tarjan</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Facebook</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:pt@fb.com">pt@fb.com</a></td></tr>
</table>
</body></html>
