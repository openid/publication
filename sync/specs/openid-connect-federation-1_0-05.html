<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>OpenID Connect Federation 1.0 - draft 05</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language">
<link href="#rfc.section.2" rel="Chapter" title="2 Entity Statement">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 The trust anchor">
<link href="#rfc.section.3" rel="Chapter" title="3 Metadata">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 OpenID Connect Relying Party Metadata">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 OpenID Provider Metadata">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 OpenID Connect Discovery">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 OAuth Provider">
<link href="#rfc.section.3.5" rel="Chapter" title="3.5 OAuth Client">
<link href="#rfc.section.3.6" rel="Chapter" title="3.6 OAuth Protected Resources">
<link href="#rfc.section.4" rel="Chapter" title="4 The Federation API">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Fetching entity statements (REQUIRED)">
<link href="#rfc.section.4.1.1" rel="Chapter" title="4.1.1 Fetch Entity Statements Request">
<link href="#rfc.section.4.1.2" rel="Chapter" title="4.1.2 Fetch Entity Statements Response">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Trust negotiation (OPTIONAL)">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Trust negotiation Request">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Trust negotiation Response">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Entity listings (OPTIONAL)">
<link href="#rfc.section.4.3.1" rel="Chapter" title="4.3.1 Entity Listings Request">
<link href="#rfc.section.4.3.2" rel="Chapter" title="4.3.2 Entity Listing Response">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Force refreshing of entity statements">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Generic Error Response">
<link href="#rfc.section.5" rel="Chapter" title="5 Resolving trust chain and metadata">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Fetching entity statements to establish a trust chain">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Finding trust chains">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Validating the trust chains">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Choosing one of the valid trust chains">
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Calculating the lifetime of a trust chain">
<link href="#rfc.section.6" rel="Chapter" title="6 Updating metadata, key-rollover and revocation">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Key-rollover for entity">
<link href="#rfc.section.6.1.1" rel="Chapter" title="6.1.1 Leaf node key-rollover on keys used in protocol">
<link href="#rfc.section.6.1.2" rel="Chapter" title="6.1.2 Key-rollover for entity signing key">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Key rollover for trust roots">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Updating metadata">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Revocation">
<link href="#rfc.section.7" rel="Chapter" title="7 Flattening metadata from the chain of entity statements">
<link href="#rfc.section.8" rel="Chapter" title="8 OpenID Connect Communication">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Explicit Registration">
<link href="#rfc.section.8.1.1" rel="Chapter" title="8.1.1 Provider Discovery">
<link href="#rfc.section.8.1.2" rel="Chapter" title="8.1.2 Client Registration">
<link href="#rfc.section.8.1.3" rel="Chapter" title="8.1.3 After client registration">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Implicit Registration">
<link href="#rfc.section.8.2.1" rel="Chapter" title="8.2.1 The Authentication Request">
<link href="#rfc.section.8.2.2" rel="Chapter" title="8.2.2 Processing the authentication request">
<link href="#rfc.section.8.2.3" rel="Chapter" title="8.2.3 Authentication Error Response">
<link href="#rfc.section.8.2.4" rel="Chapter" title="8.2.4 Authentication at the Token endpoint">
<link href="#rfc.section.9" rel="Chapter" title="9 Timeouts">
<link href="#rfc.section.10" rel="Chapter" title="10 Acknowledgements">
<link href="#rfc.section.11" rel="Chapter" title="11 IANA Considerations">
<link href="#rfc.section.12" rel="Chapter" title="12 Security Considerations">
<link href="#rfc.references" rel="Chapter" title="13 Normative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Illustrative example of OpenID Connect flow">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Initial setup of Foodle">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Federation setup">
<link href="#rfc.appendix.A.3" rel="Chapter" title="A.3 User chooses to login at Foodle">
<link href="#rfc.appendix.A.4" rel="Chapter" title="A.4 Foodle discovers the OpenID provider">
<link href="#rfc.appendix.A.5" rel="Chapter" title="A.5 Resolving the provider trust chain">
<link href="#rfc.appendix.A.6" rel="Chapter" title="A.6 Extracting the provider metadata">
<link href="#rfc.appendix.A.7" rel="Chapter" title="A.7 RP sends authentication request (implicit registration)">
<link href="#rfc.appendix.A.8" rel="Chapter" title="A.8 Provider fetches entity statements">
<link href="#rfc.appendix.A.9" rel="Chapter" title="A.9 Provider fetches entity statements">
<link href="#rfc.appendix.B" rel="Chapter" title="B Notices">
<link href="#rfc.appendix.C" rel="Chapter" title="C Document History">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.11.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Hedberg, R., Ed., Solberg, A., Gulliksson, S., Jones, M., and J. Bradley" />
  <meta name="dct.identifier" content="urn:ietf:id:openid-connect-federation-1_0" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-10-18" />
  <meta name="dct.abstract" content="The OpenID Connect standard specifies how a Relying Party (RP) can discover metadata about an OpenID Provider (OP), and then register to obtain relying party credentials. The discovery and registration process does not involve any mechanisms of dynamically establishing trust in the exchanged information, but instead rely on-out-of band trust establishment." />
  <meta name="description" content="The OpenID Connect standard specifies how a Relying Party (RP) can discover metadata about an OpenID Provider (OP), and then register to obtain relying party credentials. The discovery and registration process does not involve any mechanisms of dynamically establishing trust in the exchanged information, but instead rely on-out-of band trust establishment." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left"></td>
<td class="right">R. Hedberg, Ed.</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">independent</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">A. Solberg</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Uninett</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">S. Gulliksson</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Schibsted</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">M. Jones</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Microsoft</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">J. Bradley</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">Ping Identity</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">October 18, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">OpenID Connect Federation 1.0 - draft 05<br />
  <span class="filename">openid-connect-federation-1_0</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>The OpenID Connect standard specifies how a Relying Party (RP) can discover metadata about an OpenID Provider (OP), and then register to obtain relying party credentials. The discovery and registration process does not involve any mechanisms of dynamically establishing trust in the exchanged information, but instead rely on-out-of band trust establishment.</p>
<p>In an identity federation context, this is not sufficient. The participants of the federation must be able to trust information provided about other participants in the federation. OpenID Connect Federations specifies how trust can be dynamically obtained from resolving trust from a common trusted third party.</p>
<p>While this specification is primarily targeting OpenID Connect, it is designed in order to allow for re-use by other protocols and in other use cases.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Entity Statement</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">The trust anchor</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Metadata</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">OpenID Connect Relying Party Metadata</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">OpenID Provider Metadata</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">OpenID Connect Discovery</a>
</li>
<li>3.4.   <a href="#rfc.section.3.4">OAuth Provider</a>
</li>
<li>3.5.   <a href="#rfc.section.3.5">OAuth Client</a>
</li>
<li>3.6.   <a href="#rfc.section.3.6">OAuth Protected Resources</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">The Federation API</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Fetching entity statements (REQUIRED)</a>
</li>
<ul><li>4.1.1.   <a href="#rfc.section.4.1.1">Fetch Entity Statements Request</a>
</li>
<li>4.1.2.   <a href="#rfc.section.4.1.2">Fetch Entity Statements Response</a>
</li>
</ul><li>4.2.   <a href="#rfc.section.4.2">Trust negotiation (OPTIONAL)</a>
</li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">Trust negotiation Request</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Trust negotiation Response</a>
</li>
</ul><li>4.3.   <a href="#rfc.section.4.3">Entity listings (OPTIONAL)</a>
</li>
<ul><li>4.3.1.   <a href="#rfc.section.4.3.1">Entity Listings Request</a>
</li>
<li>4.3.2.   <a href="#rfc.section.4.3.2">Entity Listing Response</a>
</li>
</ul><li>4.4.   <a href="#rfc.section.4.4">Force refreshing of entity statements</a>
</li>
<li>4.5.   <a href="#rfc.section.4.5">Generic Error Response</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Resolving trust chain and metadata</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Fetching entity statements to establish a trust chain</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Finding trust chains</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Validating the trust chains</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Choosing one of the valid trust chains</a>
</li>
<li>5.5.   <a href="#rfc.section.5.5">Calculating the lifetime of a trust chain</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">Updating metadata, key-rollover and revocation</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Key-rollover for entity</a>
</li>
<ul><li>6.1.1.   <a href="#rfc.section.6.1.1">Leaf node key-rollover on keys used in protocol</a>
</li>
<li>6.1.2.   <a href="#rfc.section.6.1.2">Key-rollover for entity signing key</a>
</li>
</ul><li>6.2.   <a href="#rfc.section.6.2">Key rollover for trust roots</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Updating metadata</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">Revocation</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Flattening metadata from the chain of entity statements</a>
</li>
<li>8.   <a href="#rfc.section.8">OpenID Connect Communication</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Explicit Registration</a>
</li>
<ul><li>8.1.1.   <a href="#rfc.section.8.1.1">Provider Discovery</a>
</li>
<li>8.1.2.   <a href="#rfc.section.8.1.2">Client Registration</a>
</li>
<li>8.1.3.   <a href="#rfc.section.8.1.3">After client registration</a>
</li>
</ul><li>8.2.   <a href="#rfc.section.8.2">Implicit Registration</a>
</li>
<ul><li>8.2.1.   <a href="#rfc.section.8.2.1">The Authentication Request</a>
</li>
<li>8.2.2.   <a href="#rfc.section.8.2.2">Processing the authentication request</a>
</li>
<li>8.2.3.   <a href="#rfc.section.8.2.3">Authentication Error Response</a>
</li>
<li>8.2.4.   <a href="#rfc.section.8.2.4">Authentication at the Token endpoint</a>
</li>
</ul></ul><li>9.   <a href="#rfc.section.9">Timeouts</a>
</li>
<li>10.   <a href="#rfc.section.10">Acknowledgements</a>
</li>
<li>11.   <a href="#rfc.section.11">IANA Considerations</a>
</li>
<li>12.   <a href="#rfc.section.12">Security Considerations</a>
</li>
<li>13.   <a href="#rfc.references">Normative References</a>
</li>
<li>Appendix A.   <a href="#rfc.appendix.A">Illustrative example of OpenID Connect flow</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Initial setup of Foodle</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">Federation setup</a>
</li>
<li>A.3.   <a href="#rfc.appendix.A.3">User chooses to login at Foodle</a>
</li>
<li>A.4.   <a href="#rfc.appendix.A.4">Foodle discovers the OpenID provider</a>
</li>
<li>A.5.   <a href="#rfc.appendix.A.5">Resolving the provider trust chain</a>
</li>
<li>A.6.   <a href="#rfc.appendix.A.6">Extracting the provider metadata</a>
</li>
<li>A.7.   <a href="#rfc.appendix.A.7">RP sends authentication request (implicit registration)</a>
</li>
<li>A.8.   <a href="#rfc.appendix.A.8">Provider fetches entity statements</a>
</li>
<li>A.9.   <a href="#rfc.appendix.A.9">Provider fetches entity statements</a>
</li>
</ul><li>Appendix B.   <a href="#rfc.appendix.B">Notices</a>
</li>
<li>Appendix C.   <a href="#rfc.appendix.C">Document History</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#Introduction" id="Introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">This specification describes how two entities that would like to interact can dynamically fetch and and resolve trust and metadata for a given protocol, by the use of third party trust issuers.</p>
<p id="rfc.section.1.p.2">An identity federation can be realized using this specification by the use of one or more levels of trust issuers. A trust issuer is an entity, which main purpose is to issue trust statements about entities, such as OpenID relying party and providers. This specification does not mandates a specific way or restrict how a federation may be built.  Instead the specification provides the basic technical trust infrastructure building blocks needed to build a a dynamic and distributed trust network such as a federation.</p>
<p id="rfc.section.1.p.3">An entity will typically configure a local trust root to include the identifier and the certificate of a the trusted third party &#8211; the federation. All entities involved in OpenID Connect Federation, including the trust issuers, will have their own unique identifier. This identifier is used to dynamically fetch entity statements. As a complete chain of entity statements is obtained, connecting the local trust root to the target entity, the entity may resolve the resulting trusted metadata, by flattening the metadata found in the trust chain.</p>
<p id="rfc.section.1.p.4">Note that a real-world entity like an organisation, a company may be represented by more than one entity in a federation.</p>
<p id="rfc.section.1.p.5">The OpenID Connect Federation trust chains are relying on cryptographically signed JWT documents, and the trust chain does not at all rely on TLS in order to establish trust.</p>
<p id="rfc.section.1.p.6">OpenID Connect Federation may very well be used for other purposes than building traditional identity federations. One of them could be to build an OpenID Connect deployment where the key rollover process does not fall back to TLS. Another could be allowing traditionally public/native clients, such as medical devices, to generate its own key pair, and use asymmetric crypto to increase the overall security.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> Requirements Language</h1>
<p id="rfc.section.1.1.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" class="xref">RFC 2119</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#entity-statement" id="entity-statement">Entity Statement</a>
</h1>
<p id="rfc.section.2.p.1">An entity statement is always a signed JWT. An entity statement is issued by the <samp>iss</samp>, and the statement considers the subject entity, the <samp>sub</samp>. To be able to resolve trust and metadata, one needs to know the identifier of the target entity &#8211; we refer to this as the leaf entity. The leaf entity will always sign a statement about itself, and give some hints to other entities that may want to issue statements about itself. All other entities in a trust chain we refer to as intermediate entities. The local configured trust root, we refer to as the trust anchor.</p>
<p></p>

<dl>
<dt>iss</dt>
<dd style="margin-left: 8">REQUIRED. The entity identifier of the entity that issues the statement. If the iss and the sub are identical, the issuer is making a statement about itself.</dd>
<dt>sub</dt>
<dd style="margin-left: 8">REQUIRED. The entity identifier of the subject</dd>
<dt>iat</dt>
<dd style="margin-left: 8">REQUIRED. The time the statement was issued.</dd>
<dt>exp</dt>
<dd style="margin-left: 8">REQUIRED. The time the signed statement expires.</dd>
<dt>jwks</dt>
<dd style="margin-left: 8">REQUIRED. A <a href="#RFC7517" class="xref">JSON Web Key Set (JWKS)</a> representing the public part of the subject entity's signing keys.<br><br>These keys are used verify the identity of the subject. A corresponding private key is used by the leaf entity to sign an entity statement about itself, and intermediate entities to sign statements about other entities.  The keys that can be found here are primarily intended to sign entity statements, and can not be used in other protocols, unless the metadata type specification explicitly states how the keys can be used. In OpenID Connect, the jwks keys cannot be used within the Authorization/AccessToken/RefreshToken/UserInfo requests and responses. Instead OpenID Connect specific metadata includes claims for this purpose.</dd>
<dt>authority_hints</dt>
<dd style="margin-left: 8">OPTIONAL. A JSON object where the keys are the intermediate entities that may issue an entity statement about the issuer entity. The value MUST be a JSON array of entities that is further up in the trust chain. The array may be an empty list. The JSON array can be used to simplify the selection of trust chains without the need for fetching all possible authority hints.</dd>
<dt>metadata</dt>
<dd style="margin-left: 8">REQUIRED. JSON object including protocol specific metadata claims that represent the leaf node. To resolve the resulting metadata for a leaf node, the compound metadata documents included in the trust chain is merged by the <a href="#flattening-metadata" class="xref">metadata flattening process</a>. The keys of the JSON object represent the metadata type identifier, and the value MUST be a JSON object representing the metadata according to the metadata schema of that metadata type. To allow for the leaf node to resolve a specific metadata type, all intermediate entities in the trust chain MUST contain a metadata document for this specific type. See <a href="#metadata" class="xref">section about metadata</a>. An entity statement may contain multiple metadata statement, but only one for each metadata type.</dd>
<dt>sub_is_leaf</dt>
<dd style="margin-left: 8">OPTIONAL. Boolean value that indicates whether the subject is considered a leaf node. A leaf node is not trusted to issue statements about other entities then itself. If this property is left out, it is considered to be <samp>false</samp>.</dd>
<dt>sub_meta</dt>
<dd style="margin-left: 8">OPTIONAL. If present, an JSON object containing one or more of the properties listed below. This is metadata describing the subject of this entity statement. The metadata included in the metadata claim is always referring to the leaf nodes, while the metadata in sub_meta refers to the immediate subject, which may be an intermediate trust issuer.<br><br><dl>
<dt>name</dt>
<dd style="margin-left: 8">OPTIONAL. String. The human readable name describing the subject entity. This may be, for example, the name of an organization.</dd>
<dt>contacts</dt>
<dd style="margin-left: 8">OPTIONAL. JSON array with one or more strings. Contact persons at the entity.</dd>
<dt>policy_url</dt>
<dd style="margin-left: 8">OPTIONAL. URL to documentation of conditions and policies relevant to this entity</dd>
<dt>homepage_url</dt>
<dd style="margin-left: 8">OPTIONAL. URL to a generic home page representing this entity.</dd>
</dl>
</dd>
</dl>
<p id="rfc.section.2.p.3">The entity statement is signed using the private key of the issuer entity, in the form of a <a href="#RFC7515" class="xref">JSON Web Signature (JWS)</a>.</p>
<p>Non-normative example of a entity statement, before serialization and adding a signature.</p>
<pre>{
  "iss": "https://feide.no",
  "sub": "https://ntnu.no",
  "iat": 1516239022,
  "exp": 1516298022,
  "metadata": {
    "openid_provider": {
      "issuer": "https://ntnu.no",
      "organization": "NTNU",
      "id_token_signing_alg_values_supported": ["RS256", "RS384",
                                                "RS512"]
    },
    "openid_client": {
      "organization": "NTNU",
      "grant_types_supported": ["authorization_code", "implicit"],
      "scopes": ["openid", "profile", "email", "phone"]
    }
  },
  "jwks": {
    "keys": [
      {
        "alg": "RS256",
        "e": "AQAB",
        "ext": true,
        "key_ops": ["verify"],
        "kid": "key1",
        "kty": "RSA",
        "n": "pnXBOusEANuug6ewezb9J_...",
        "use": "sig"
      }
    ]
  },
  "authority_hints": {
    "https://edugain.org/federation": []
  }
}</pre>
<p>(postamble)</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> The trust anchor</h1>
<p id="rfc.section.2.1.p.1">In order to configure trust when deploying a software component, it is recommended to align the configuration with the semantics of a entity statement. How the configuration is stored and the exact format is out of the scope of this specification, but it is recommended to allow the user to configure a list of entries containing <samp>sub</samp>, <samp>jwks</samp> and <samp>metadata</samp>. When the compound metadata from the trust chain is resolved, metadata from the local trust root can be applied in the <a href="#flattening-metadata" class="xref">metadata flattening process</a>. This allows the configuration of a provider to put trust limitations applied to all metadata resolved for the various trust roots. For example, a provider may trust a large federation with a metadata limitation of only releasing the name and userid, and no other scopes or claims. The provider may add other trust roots with a more limited target group to allow for more scopes and claims.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#metadata" id="metadata">Metadata</a>
</h1>
<p id="rfc.section.3.p.1">The OpenID Connect Federations specification does allow new metadata types to be defined, to support use cases outside OpenID Connect. The metadata type identifier will uniquely identify which metadata specification to interpret.</p>
<p id="rfc.section.3.p.2">The metadata document MUST be a JSON document. Beyond that there is no restriction.</p>
<p id="rfc.section.3.p.3">Metadata used in OpenID Connect Federations typically re-uses existing metadata standards. If needed, the metadata schema is extended with additional properties relevant in a federated context.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> OpenID Connect Relying Party Metadata</h1>
<p id="rfc.section.3.1.p.1">The metadata type identifier is <samp>openid_client</samp>.</p>
<p id="rfc.section.3.1.p.2">All parameters defined in section 2 of <a href="#OpenID.Registration" class="xref">OpenID Connect Dynamic Client Registration 1.0</a> are allowed in a metadata statement.</p>
<p id="rfc.section.3.1.p.3">To that list is added: </p>

<dl>
<dt>allowed_scopes</dt>
<dd style="margin-left: 8">
<br>RECOMMENDED. JSON array containing a list of the <a href="#RFC6749" class="xref">RFC6749</a> scope values that this relying party expects to use.</dd>
<dt>allowed_claims</dt>
<dd style="margin-left: 8">
<br>RECOMMENDED. JSON array containing a list of the Claim Names of the Claims that the OpenID Client wants values for.</dd>
</dl>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> OpenID Provider Metadata</h1>
<p id="rfc.section.3.2.p.1">The metadata type identifier is an <samp>openid_provider</samp>.</p>
<p id="rfc.section.3.2.p.2">All parameters defined in section 3 of <a href="#OpenID.Discovery" class="xref">OpenID Connect Discovery 1.0</a></p>
<p id="rfc.section.3.2.p.3">In addition the following properties are allowed:</p>
<p></p>

<dl>
<dt>organizationName</dt>
<dd style="margin-left: 8">
<br>OPTIONAL. A human readable name representing the organization owning the OpenID Provider. It is intended to be used in the user interface, being recognized by the end users that would be using the provider to authenticate.</dd>
</dl>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> OpenID Connect Discovery</h1>
<p id="rfc.section.3.3.p.1">The metadata type identifier is <samp>openid-discovery</samp>.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> OAuth Provider</h1>
<p id="rfc.section.3.4.p.1">The metadata type identifier is <samp>openid-provider</samp>.</p>
<h1 id="rfc.section.3.5">
<a href="#rfc.section.3.5">3.5.</a> OAuth Client</h1>
<p id="rfc.section.3.5.p.1">The metadata type identifier is <samp>openid_client</samp>.</p>
<h1 id="rfc.section.3.6">
<a href="#rfc.section.3.6">3.6.</a> OAuth Protected Resources</h1>
<p id="rfc.section.3.6.p.1">The metadata type identifier is <samp>openid-api</samp>.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> The Federation API</h1>
<p id="rfc.section.4.p.1">Given the entity identifier, the endpoint of the federation API endpoint of the entity is easily derived. All entities that are expected to expose entity statements about themselves or other entities, MUST implement a Federation API.</p>
<p id="rfc.section.4.p.2">The federation API endpoint of an entity, is resolved from the entity identifier. The Federation API endpoint is found using the <a href="#RFC5785" class="xref">Well known URIs</a> specification, with the suffix <samp>openid-federation</samp>. The scheme, host and port is taken directly from the entity identifier combined with the following path: <samp>/.well-known/openid-federation</samp>.</p>
<p id="rfc.section.4.p.3">The Federation API is an HTTP API that may support multiple operations. Fetching entities is one of the operations, and the only one that all entities is REQUIRED to support. All the other operations is OPTIONAL. The <samp>op</samp> (operation) parameter may be used to defined new operations in a future version of the specification or a local deployment which have agreed upon additional functionality.</p>
<p id="rfc.section.4.p.4">While all operations in the specification make use of a GET request, other operations may choose to use other HTTP methods. If the <samp>op</samp> parameter is left out, it is considered to be a fetch entity statements request. Unless otherwise mentioned or agreed upon, requests to the federation API does not need to be authenticated.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> Fetching entity statements (REQUIRED)</h1>
<p id="rfc.section.4.1.p.1">Fetching entity statements is used to collect entity statements and a valid trust chain in order to establish trust with a remote peer.</p>
<p id="rfc.section.4.1.p.2">In order to fetch entity statements, you need to know the identifier of the entity to ask, and the identifier of the entity that you want the statement to be about. Typically the first entity statement to fetch is the remote peer self issued entity statement.</p>
<h1 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> Fetch Entity Statements Request</h1>
<p id="rfc.section.4.1.1.p.1">The request MUST be a HTTP request using the GET method to a resolved federation API endpoint with the following query string parameters:</p>
<p></p>

<dl>
<dt>op</dt>
<dd style="margin-left: 8">OPTIONAL. If not present MUST be set to <samp>fetch</samp>.</dd>
<dt>iss</dt>
<dd style="margin-left: 8">REQUIRED. The entity identifier of the issuer from which you want an entity statement issued. Because of the normalization of the URL, multiple issuers may resolve to a shared federation API. This parameter makes it explicit exactly which issuer we want entity statements from.</dd>
<dt>sub</dt>
<dd style="margin-left: 8">OPTIONAL. The entity identifier of the subject for which you would like an entity statement issued. If this parameter is left out, it is considered to be the same as the issuer, and would indicate a request for a self issued statement.</dd>
<dt>aud</dt>
<dd style="margin-left: 8">OPTIONAL. The entity identifier of the requester. The issuing entity may choose to include this parameter to form the entity statement specifically for this target, in which the <samp>aud</samp> claim also should be present in the entity statement it self.</dd>
<dt>prefetch</dt>
<dd style="margin-left: 8">OPTIONAL. If left out, it is assumed to be <samp>false</samp>. If set to <samp>true</samp>, it indicates that the requester would like the API to prefetch entity statements that may be relevant for consumer to establish a trust chain, and may save the consumer from performing additional API requests.</dd>
</dl>
<p>The following is a non-normative example of an API request for entity statement:</p>
<pre>
GET /.well-known/openid-federation?
iss=https%3A%2F%2Fopenid.sunet.se%2Ffederation HTTP/1.1
Host: openid.sunet.se
</pre>
<p>(postamble)</p>
<h1 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> Fetch Entity Statements Response</h1>
<p id="rfc.section.4.1.2.p.1">As long as the request is correct, understood and accepted, the response MUST be a JSON array including signed entity statements.  The content type MUST be set to <samp>application/json</samp>.  If the issuing entity does not recognize the subject or the issuer, it should return an empty JSON array. The returned list of entity statements SHOULD include a statement issued by the issuing entity about the entity represented in the subject parameter. The issuing entity may also decide to prefetch additional entity statements that may be relevant to the requester.</p>
<p>A non-normative example of a response:</p>
<pre>200 OK
Last-Modified: Wed, 22 Jul 2018 19:15:56 GMT
Content-Type: application/json

["eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJodHRwczovL3Nlc..."]
</pre>
<p>(the signed JWT is truncated)</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> Trust negotiation (OPTIONAL)</h1>
<p id="rfc.section.4.2.p.1">An entity may use the trust negotiation operation in order to fetch a resolved metadata of it self as seen/trusted by a remote peer. The remote peer will fetch the metadata and necessary trust chain to the requester, and perform metadata flattening. The remote peer should include it own trust root configuration when generating the resulting metadata. The metadata returned should be the same as the one used in the software.</p>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> Trust negotiation Request</h1>
<p id="rfc.section.4.2.1.p.1">Resolving metadata for a specific type of metadata, for a given peer. The relying party may ask a specific provider to resolve the relying party openid_client metadata with its own configured trust root. The result may tell what operations, scopes and claims the relying party is allowed to use.</p>
<p></p>

<dl>
<dt>op</dt>
<dd style="margin-left: 8">REQUIRED. MUST be set to <samp>resolve_metadata</samp>.</dd>
<dt>iss</dt>
<dd style="margin-left: 8">REQUIRED. The entity identifier of the issuer from which you want to resolve metadata. Because of the normalization of the URL, multiple issuers may resolve to a shared federation API. This parameter makes it explicit exactly which issuer we want to interact with.</dd>
<dt>peer</dt>
<dd style="margin-left: 8">REQUIRED. The entity identifier of the entity the information is required for.</dd>
<dt>type</dt>
<dd style="margin-left: 8">REQUIRED. The metadata type to resolve.  In this document we use the metadata types, <samp>openid_client</samp> and <samp>openid_provider</samp>.</dd>
</dl>
<p></p>

<p>The following is a non-normative example of an API request for trust negotiation:</p>
<pre>
GET /.well-known/openid-federation?
op=resolve_metadata&amp;
iss=https%3A%2F%2Fopenid.sunet.se%2Ffederation&amp;
type=openid_provider&amp;
peer=https%3A%2F%2Fidp.umu.se%2Fopenid HTTP/1.1
Host: openid.sunet.se
</pre>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> Trust negotiation Response</h1>
<p id="rfc.section.4.2.2.p.1">The response is a generated flattened metadata of the type specified in the request.</p>
<p>A non-normative example of a response:</p>
<pre>200 OK
Last-Modified: Wed, 22 Jul 2018 19:15:56 GMT
Content-Type: application/json

{
  "organization": "University of Ume?",
  "contacts": ["legal@umu.se", "technical@umu.se"],
  "logo_uri":
    "https://www.umu.se/SRWStatic/img/umu-logo-left-neg-SE.svg",
  "policy_uri":
    "https://www.umu.se/en/about-the-website/legal-information/",
  "authorization_endpoint":
    "https://idp.umu.se/openid/authorization",
  "token_endpoint": "https://idp.umu.se/openid/token",
  "response_types_supported": ["code", "code id_token", "token"],
  "grant_types_supported": [
    "authorization_code",
    "implicit",
    "urn:ietf:params:oauth:grant-type:jwt-bearer"
  ],
  "subject_types_supported": ["pairwise"],
  "id_token_signing_alg_values_supported": ["RS256"],
  "LoaMax": "http://swamid.se/LoA/substantial",
  "expires": 8776635
}
</pre>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> Entity listings (OPTIONAL)</h1>
<p id="rfc.section.4.3.p.1">An entity may query another entity for a list of all entities that that entity is prepared to issue statements about.</p>
<h1 id="rfc.section.4.3.1">
<a href="#rfc.section.4.3.1">4.3.1.</a> Entity Listings Request</h1>
<p id="rfc.section.4.3.1.p.1">The following request parameters are allowed in the query part:</p>
<p></p>

<dl>
<dt>op</dt>
<dd style="margin-left: 8">REQUIRED. MUST be set to <samp>listing</samp>.</dd>
<dt>iss</dt>
<dd style="margin-left: 8">REQUIRED. The entity identifier of the issuer from which you want to resolve metadata. Because of the normalization of the URL, multiple issuers may resolve to a shared federation API. This parameter makes it explicit exactly which issuer we want to interact with.</dd>
<dt>type</dt>
<dd style="margin-left: 8">OPTIONAL. Provide this parameter to filter the results to entity statements that contain entries for this specific metadata type.</dd>
<dt>sub_is_leaf</dt>
<dd style="margin-left: 8">OPTIONAL. If left out, result should include both leaf nodes and intermediate nodes. If set to <samp>true</samp> , the response should contain only leaf nodes. If set to <samp>false</samp>, the response should contain only intermediate nodes.</dd>
<dt>claims</dt>
<dd style="margin-left: 8">OPTIONAL. A comma separated list of claim names that the requester would like to get for each entity. If left out or an empty string, the response should contain an empty object for each of the known entities.</dd>
</dl>
<h1 id="rfc.section.4.3.2">
<a href="#rfc.section.4.3.2">4.3.2.</a> Entity Listing Response</h1>
<p id="rfc.section.4.3.2.p.1">The response MUST contain an JSON object where the known entity identifiers are the property keys, and a JSON object with the requested claims is the property value. Requested claims that the responder is not able to provide should be left out.</p>
<p>A non-normative example of a response:</p>
<pre>200 OK
Last-Modified: Wed, 22 Jul 2018 19:15:56 GMT
Content-Type: application/json

{
  "https://ntnu.andreas.labs.uninett.no/": {
    "client_name": "NTNU Labs"
  },
  "https://blackboard.ntnu.no/openid/callback": {
    "client_name": "Blackboard"
  },
  "https://serviceprovider.andreas.labs.uninett.no/application007": {
    "client_name": "Test application"
  }
}
</pre>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> Force refreshing of entity statements</h1>
<p id="rfc.section.4.4.p.1">TBD.</p>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> Generic Error Response</h1>
<p id="rfc.section.4.5.p.1">If the request was malformed, or some error occurred during processing of the request, the following standardized error format should be used regardless of the operation specified.</p>
<p id="rfc.section.4.5.p.2">The HTTP response code MUST be something else than 200, giving an indication of the type of error. The response body MUST be a JSON object including these claims:</p>
<p></p>

<dl>
<dt>op</dt>
<dd style="margin-left: 8">REQUIRED. Which operation was the request processed as.</dd>
<dt>error</dt>
<dd style="margin-left: 8">REQUIRED. The error code.</dd>
<dt>error_description</dt>
<dd style="margin-left: 8">REQUIRED. A human readable short text describing the error.</dd>
</dl>
<p>A non-normative example of a error response:</p>
<pre>400 Bad request
Last-Modified: Wed, 22 Jul 2018 19:15:56 GMT
Content-Type: application/json

{
  "op": "fetch",
  "error": "generic_error",
  "error_description":
    "Required request parameter [iss] was missing."
}
</pre>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#resolving_trust" id="resolving_trust">Resolving trust chain and metadata</a>
</h1>
<p id="rfc.section.5.p.1">An entity seeking to establish trust with a remote peer will start with the knowledge of the remote peer entity identifier and with a locally configured trust anchor. The entity will first have to fetch sufficient entity statements to establish a chain of trust from the remote peer to the locally configured trust anchor. Afterwards, the seeking entity will have to validate the trust chain and choose one if there are multiple valid trust chains.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#fetching-es" id="fetching-es">Fetching entity statements to establish a trust chain</a>
</h1>
<p id="rfc.section.5.1.p.1">The seeking entity should always start to ask the remote peer entity about its self-issued entity statement. This entity statement MAY contain an list of intermediate entities in the authority_hints claim.</p>
<p id="rfc.section.5.1.p.2">The seeking entity may iterate through the list of authority_hints and request an entity statement on the remote peer from each of the intermediates. It may further iterate intermediate entity statements for their authority_hints, and so on. The seeking entity should never attempt to fetch entity statements that it has already fetched in this process (loop prevention).</p>
<p id="rfc.section.5.1.p.3">The result of this operation should be a number of flat lists of entity statements.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> Finding trust chains</h1>
<p id="rfc.section.5.2.p.1">The seeking entity will look for paths from the remote peer entity to the locally configured trust anchors. If no path is found, the process of establishing trust has failed. The result may also very well be more than one possible path.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> Validating the trust chains</h1>
<p id="rfc.section.5.3.p.1">A trust chain consists of an ordered list of entity statements that refer to each other from one entry in the local trust anchor to the self-issued entity statement of the remote peer.</p>
<p id="rfc.section.5.3.p.2">We refer to the locally configured trust root as ES0, the top level intermediate entity statement as ES1, up to the self signed entity statement ESi. A trust chain without any intermediate entities is also valid. The trust anchor might include a ES0 representing a direct trust to a remote peer, and the self-issued statement of the peer will then be ES1.</p>
<p id="rfc.section.5.3.p.3">To validate the chain, the signed JWT ES1 is validated against the public signing keys in ES0, jwks. Next, the signed JWT ES2 is validated against the public signing keys in ES1, and so on until the complete chain is validated.</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> Choosing one of the valid trust chains</h1>
<p id="rfc.section.5.4.p.1">If multiple valid trust chain is found, the seeking entity will need to decide</p>
<h1 id="rfc.section.5.5">
<a href="#rfc.section.5.5">5.5.</a> <a href="#trust_lifetime" id="trust_lifetime">Calculating the lifetime of a trust chain</a>
</h1>
<p id="rfc.section.5.5.p.1">Each entity statement in a trust chain is signed and MUST have a expiration time (exp) set. Given that all of them are sometime in the future then the expiration time of the whole trust chain is then the expiration time that is closest in time to the present time.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> Updating metadata, key-rollover and revocation</h1>
<p id="rfc.section.6.p.1">The OpenID Connect Federation allows for a smooth process of updating metadata and public keys.</p>
<p id="rfc.section.6.p.2">Each entity statement has an explicit expiration time. A trust chain is valid until one or more of the involved entity statements expires.  This specification describes how entity statement is fetched and metadata is resolved for the first time, but a consumer of metadata from OpenID Connect Federation MUST support refreshing at least the expired entity statements and re-evaluate the whole trust chain when needed.</p>
<p id="rfc.section.6.p.3">Setting an expiration time on an entity statement can be used to control how often the remote party is fetching an updated version of your public key.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> Key-rollover for entity</h1>
<p id="rfc.section.6.1.p.1">A leaf node, such as an OpenID Provider will typically have at least two set of key pairs, one that is embedded in the entity statement issued by the superior trust issuer, and one that is embedded in the protocol specific metadata that is included in the self issuer entity statement.</p>
<h1 id="rfc.section.6.1.1">
<a href="#rfc.section.6.1.1">6.1.1.</a> Leaf node key-rollover on keys used in protocol</h1>
<p></p>

<ol>
<li>Generate a new key pair to use (K2) to replace the existing (K1).  The lifetime T1 is the time until all previously issued entity statements are expired.</li>
<li>Publish both K1 and K2 in the metadata part of the self issued entity statement. Use K1 to sign outgoing messages. Accept encrypted messages to both K1 and K2. Set K2 to prioritized key. Wait at least T1 before moving to next step.</li>
<li>Remove K1 from the metadata part in the published entity statements. Start signing outgoing messages with K2, accept incoming encrypted messages with both K1 and K2. Wait at least T1.</li>
<li>Only K2 is used and accepted.</li>
</ol>

<p>The complete time of this key-rollover process is 2x T1.</p>
<h1 id="rfc.section.6.1.2">
<a href="#rfc.section.6.1.2">6.1.2.</a> Key-rollover for entity signing key</h1>
<p id="rfc.section.6.1.2.p.1">Identical to the section above, but the entity statements is issued by the superior party, such that an out of band process for the entity to push its key material to the superior entity MUST be added.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> Key rollover for trust roots</h1>
<p id="rfc.section.6.2.p.1">As previous steps.</p>
<p id="rfc.section.6.2.p.2">Take into considerations that clients have manually configured pubic keys as part of configuration.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> Updating metadata</h1>
<p id="rfc.section.6.3.p.1">The process of updating its own metadata follows the same procedure as with public keys.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> Revocation</h1>
<p></p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#flattening-metadata" id="flattening-metadata">Flattening metadata from the chain of entity statements</a>
</h1>
<p id="rfc.section.7.p.1">The metadata for a specific entity can be constructed by starting with the information in ms_0 and then adding the information in ms_1 to ms_n using the following rule:</p>
<p id="rfc.section.7.p.2">Given two metadata statements ms_i and ms_j (j &gt; i, i=0, ..., n-1, j=1, ..., n) For every claim in ms_j: If the claim does not appear in ms_i add it to ms_i. If the claim appears in ms_i then replace the value of the claim in ms_i with the value of the claim in ms_j if and only if the value in ms_j is a subset of the value in ms_i else an error MUST be generated.</p>
<p id="rfc.section.7.p.3">A subset is defined as: </p>

<dl>
<dt>String</dt>
<dd style="margin-left: 8">
<br> One string is a subset of another string if it is exactly the same, byte by byte.</dd>
<dt>Simple lists</dt>
<dd style="margin-left: 8">
<br> An array A is a subset of B if every element in A is also in B. And if of the matching elements the one in A is a subset of the one in B.</dd>
<dt>Booleans</dt>
<dd style="margin-left: 8">
<br> Boolean A is a subset of B if A is equal to B.</dd>
<dt>Integer/Floats</dt>
<dd style="margin-left: 8">
<br> The number A is a subset of the number B if A is less or equal to B.</dd>
<dt>Associative array/dictionary</dt>
<dd style="margin-left: 8">
<br> The dictionary A is a subset of the dictionary B if every key in A is in B and the value of A[x] is a subset of B[x].</dd>
</dl>
<p id="rfc.section.7.p.4">The following is a non-normative example of a set of relying party-specific metadata statements that together form the metadata for an entity: </p>

<p>ms_0</p>
<pre>
{
  "contacts": ["helpdesk@example.com"],
  "logo_uri": "https://example.com/logo.jpg",
  "policy_uri": "https://example.com/policy.html",
  "tos_uri": "https://example.com/tos.html"
}
            </pre>
<p>ms_1</p>
<pre>
{
  "rp_scopes": ["openid", "eduperson"],
  "response_types": ["code", "code id_token"],
}
            </pre>
<p>ms_2</p>
<pre>
{
  "contacts": ["rp_helpdesk@example.com"],
  "redirect_uris": ["https://example.com/rp1"],
  "response_types: ["code"]
}            </pre>
<p>sum(ms_0...2)</p>
<pre>{
  "contacts": ["helpdesk@example.com"],
  "logo_uri": "https://example.com/logo.jpg",
  "policy_uri": "https://example.com/policy.html",
  "tos_uri": "https://example.com/tos.html"
  "rp_scopes": ["openid", "eduperson"],
  "response_types": ["code"],
  "redirect_uris": ["https://example.com/rp1"],
}
</pre>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> OpenID Connect Communication</h1>
<p id="rfc.section.8.p.1">This section describes how the trust framework in this specification is used to establish trust between an OpenID Relying Party and an OpenID Provider that has no explicit configuration or registration in advance.  The use of OpenID Connect Federation enables dynamically building large scale multi-lateral federations.</p>
<p id="rfc.section.8.p.2">There are two alternative approaches to establish trust between a Relying Party and a Provider. Members of a federation or a community should agree upon which approach to use. Whilst implementations should support both methods, deployments may choose to disable the use of one of them.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> Explicit Registration</h1>
<p id="rfc.section.8.1.p.1">This method involves performing an explicit registration of a new client the first time a Relying Party interacts with an OpenID Provider using something akin to <a href="#OpenID.Registration" class="xref">OpenID Connect Dynamic Client Registration 1.0</a>.</p>
<p id="rfc.section.8.1.p.2">It is assumed that a federation entity has a set of authority_hints and knowledge about which trust anchor that can be found at the end of a trust chain starting in each authorityHint. How the entity has received this knowledge is outside the scope of this document.</p>
<h1 id="rfc.section.8.1.1">
<a href="#rfc.section.8.1.1">8.1.1.</a> Provider Discovery</h1>
<p id="rfc.section.8.1.1.p.1">The RP will start by figuring out the OPs metadata using the process specified in <a href="#resolving_trust" class="xref">Resolving trust chain and metadata</a> above.</p>
<h1 id="rfc.section.8.1.2">
<a href="#rfc.section.8.1.2">8.1.2.</a> <a href="#Clireg" id="Clireg">Client Registration</a>
</h1>
<h1 id="rfc.section.8.1.2.1">
<a href="#rfc.section.8.1.2.1">8.1.2.1.</a> <a href="#Cliregreq" id="Cliregreq">Client Registration Request</a>
</h1>
<p id="rfc.section.8.1.2.1.p.1">The OP MUST support dynamic relying party registration. That it does so is signaled by having the claim <samp>federation_registration_endpoint</samp> in the metadata.</p>
<p id="rfc.section.8.1.2.1.p.2">Given that the OP supports dynamic registration the RP progresses as follows: </p>

<ol>
<li>Once it has the list of acceptable trust chains for the OP it MUST choose the subset it wants to progress with. The subset can be as small as one trust chain but it can also contain more then one.</li>
<li>Based on the trust anchors referenced in the subset of trust chains, the RP will choose a set of authority_hints from its own set that terminates in those trust anchors.</li>
<li>The RP will now construct a self-signed entity statement where the metadata statement chosen is influenced by the OPs metadata and the authority_hints specified are picked by the process described above.</li>
<li>The entity statement is sent to the <samp>federation_registration_endpoint</samp> defined in this document.</li>
</ol>
<h1 id="rfc.section.8.1.2.2">
<a href="#rfc.section.8.1.2.2">8.1.2.2.</a> <a href="#cliregresp" id="cliregresp">Client Registration Response</a>
</h1>
<p id="rfc.section.8.1.2.2.p.1">Now on the OPs side the following occurs: </p>

<ul class="empty">
<li>It receives the request, collects and evaluates the trust chains starting with the authority_hints in the registration request. After having verified such chains it can verify that the signature on the received registration request is correct.</li>
<li>If it finds more than one acceptable trust chain it MUST choose one or more that terminates in one and the same trust anchor.</li>
<li>At this point, if there already exists a client registration under the same entity_id then that registration MUST be regarded as invalid.</li>
<li>The OP will now construct an entity statement containing a description of the RPs metadata that the OP finds acceptable.  To the entity statement it will add one or more authority_hints from its collection, that terminates in the trust anchor chosen above.</li>
<li>It will sign and return the signed entity statement to the RP</li>
</ul>
<p id="rfc.section.8.1.2.2.p.2">Back at the RP it will: </p>

<ul class="empty">
<li>Verify the correctness of the received entity statement.  Making sure that the trust chains starting at the authority_hints terminates in trust anchors that where referenced in the entity statement it sent to the OP.</li>
<li>If the RP is OK with the metadata that was the result of the flattening of the received entity statement then it stores the configuration and can continue communicating with the OP using the agreed on metadata.</li>
<li>If the RP was not OK, for some reason, with the received entity statement then it has the choice to restart the registration process or to give up.</li>
</ul>
<h1 id="rfc.section.8.1.3">
<a href="#rfc.section.8.1.3">8.1.3.</a> After client registration</h1>
<p id="rfc.section.8.1.3.p.1">A client registration using this specification is not expected to be valid for ever. The entity statements exchanged all have expiration times, which means that the registration will eventually time out. An OP can also for some reason decide that a client registration is not valid anymore. To this can be added that the entities in the federation, for a number of reasons, over time may change how fast their signature will expire, thereby increasing or decreasing the lifetime of a trust chain.</p>
<h1 id="rfc.section.8.1.3.1">
<a href="#rfc.section.8.1.3.1">8.1.3.1.</a> What the RP MUST do</h1>
<p id="rfc.section.8.1.3.1.p.1">At regular intervals the RP MUST: </p>

<ul class="empty">
<li>Starting with the OPs entity statement, resolve and verify the trust chains it chose to use when constructing the registration request. If those trust chains don't exist anymore or do not verify, then the registration should be regarded as invalid and a new registration process should be started.</li>
<li>If the OPs entity statement was OK it must now verify that the entity statement it received about itself from the OP is still valid. Again, if that is not the case the registration should be regarded as invalid and a new registration process should be started.</li>
</ul>
<h1 id="rfc.section.8.1.3.2">
<a href="#rfc.section.8.1.3.2">8.1.3.2.</a> What the OP MUST do</h1>
<p id="rfc.section.8.1.3.2.p.1">TBD</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> Implicit Registration</h1>
<p></p>
<p>The trust between the entities is established using the above described extensions in the first two steps of the communication between an RP and an OP. How the RP found the OP in the first place is out of scope for this document.</p>
<pre>------                                       ------
|    | &lt;--- 1) Discovery ------------------&gt; |    |
| RP | ---- 2) Authentication request -----&gt; | OP |
|    |                                       |    |
------                                       ------     </pre>
<p>After the discovery and registration is completed a first time, those steps SHOULD only be repeated if any changes occur (see notes in respective sections below).</p>
<p id="rfc.section.8.2.p.2">The client_id of the RP MUST be set identical to the RP entity identifier.</p>
<p id="rfc.section.8.2.p.3">Without a registration process, the RP does not have any client_secret. Instead the implicit registration model requires the RP to make use of asymmetric crypto.</p>
<p id="rfc.section.8.2.p.4">The RP MUST host a Federation API that allows the OP to fetch the entity statements.</p>
<h1 id="rfc.section.8.2.1">
<a href="#rfc.section.8.2.1">8.2.1.</a> The Authentication Request</h1>
<p id="rfc.section.8.2.1.p.1">The authentication request as specified in OpenID Connect Core.</p>
<h1 id="rfc.section.8.2.2">
<a href="#rfc.section.8.2.2">8.2.2.</a> Processing the authentication request</h1>
<p id="rfc.section.8.2.2.p.1">When the OP receives an incoming authentication request and both the OP supports OpenID Connect Federation and the incoming client_id is a valid URL, the OP should try to resolve and fetch the entity statement as described in <a href="#fetching-es" class="xref">fetching entity statements</a>.</p>
<p id="rfc.section.8.2.2.p.2">The OP should validate the possible trust chains, and resolve the RP metadata with type <samp>openid_client</samp>.</p>
<p id="rfc.section.8.2.2.p.3">The OP should consider the resolved metadata of the RP and perform these additional validation steps:</p>
<p></p>

<ul><li>Verify that the metadata contains a public key... TODO: add proper reference.</li></ul>
<h1 id="rfc.section.8.2.3">
<a href="#rfc.section.8.2.3">8.2.3.</a> Authentication Error Response</h1>
<p id="rfc.section.8.2.3.p.1">If the OP fails to establish trust with the RP, it should use the <samp>error_description</samp> error code, with an <samp>error_description</samp> that aids the RP to fix what is wrong.</p>
<h1 id="rfc.section.8.2.4">
<a href="#rfc.section.8.2.4">8.2.4.</a> Authentication at the Token endpoint</h1>
<p id="rfc.section.8.2.4.p.1">The RP will have to use asymmetric crypto to authenticate to the token endpoint. The RP MUST authenticate the request by including the <samp>private_key_jwt</samp> parameter, as described in OpenID Connect Core Section 9.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> Timeouts</h1>
<p id="rfc.section.9.p.1">There are a number of timeouts that MUST considered: </p>

<ul class="empty">
<li>Each signature has a timeout.</li>
<li>A relying party registration has a timeout.</li>
</ul>
<p id="rfc.section.9.p.2">Taking this into consideration, an OP MUST NOT assign a lifetime to a relying party registration that exceeds the lifetime of the metadata statement signatures.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#Acknowledgements" id="Acknowledgements">Acknowledgements</a>
</h1>
<p></p>

<ul>
<li>Heather Flanagan</li>
<li>The JRA3T3 task force of GEANT4-2</li>
<li>Michael Schwartz</li>
<li>Peter Schober</li>
</ul>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#IANA" id="IANA">IANA Considerations</a>
</h1>
<p id="rfc.section.11.p.1">TBD</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#Security" id="Security">Security Considerations</a>
</h1>
<p id="rfc.section.12.p.1">TBD</p>
<h1 id="rfc.references">
<a href="#rfc.references">13.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="OpenID.Core">[OpenID.Core]</b></td>
<td class="top">
<a title="Nomura Research Institute, Ltd.">Sakimura, N.</a>, <a title="Ping Identity">Bradley, J.</a>, <a title="Microsoft">Jones, M.</a>, <a title="Google">de Medeiros, B.</a> and <a title="Salesforce">C. Mortimore</a>, "<a href="http://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect Discovery 1.0</a>", August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="OpenID.Discovery">[OpenID.Discovery]</b></td>
<td class="top">
<a title="Nomura Research Institute, Ltd.">Sakimura, N.</a>, <a title="Ping Identity">Bradley, J.</a>, <a title="Microsoft">Jones, M.</a> and <a title="Illumila">E. Jay</a>, "<a href="http://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect Discovery 1.0</a>", August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="OpenID.Registration">[OpenID.Registration]</b></td>
<td class="top">
<a title="Nomura Research Institute, Ltd.">Sakimura, N.</a>, <a title="Ping Identity">Bradley, J.</a> and <a title="Microsoft">M. Jones</a>, "<a href="http://openid.net/specs/openid-connect-registration-1_0.html">OpenID Connect Dynamic Client Registration 1.0</a>", August 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5785">[RFC5785]</b></td>
<td class="top">
<a>Nottingham, M.</a> and <a>E. Hammer-Lahav</a>, "<a href="https://tools.ietf.org/html/rfc5785">Defining Well-Known Uniform Resource Identifiers (URIs)</a>", RFC 5785, DOI 10.17487/RFC5785, April 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6749">[RFC6749]</b></td>
<td class="top">
<a>Hardt, D.</a>, "<a href="https://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization Framework</a>", RFC 6749, DOI 10.17487/RFC6749, October 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6962">[RFC6962]</b></td>
<td class="top">
<a>Laurie, B.</a>, <a>Langley, A.</a> and <a>E. Kasper</a>, "<a href="https://tools.ietf.org/html/rfc6962">Certificate Transparency</a>", RFC 6962, DOI 10.17487/RFC6962, June 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7033">[RFC7033]</b></td>
<td class="top">
<a>Jones, P.</a>, <a>Salgueiro, G.</a>, <a>Jones, M.</a> and <a>J. Smarr</a>, "<a href="https://tools.ietf.org/html/rfc7033">WebFinger</a>", RFC 7033, DOI 10.17487/RFC7033, September 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7515">[RFC7515]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a>", RFC 7515, DOI 10.17487/RFC7515, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7517">[RFC7517]</b></td>
<td class="top">
<a>Jones, M.</a>, "<a href="https://tools.ietf.org/html/rfc7517">JSON Web Key (JWK)</a>", RFC 7517, DOI 10.17487/RFC7517, May 2015.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> Illustrative example of OpenID Connect flow</h1>
<p id="rfc.section.A.p.1">A service Foodle would like to offer its services to all identity providers in eduGAIN. Foodle is managed and registered by the university NTNU. NTNU is part of the Norwegian Feide federation. Foodle is also directly trusted in the Swedish SWAMID federation. Both Feide and SWAMID are part of the international eduGAIN federation.</p>
<h1 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> Initial setup of Foodle</h1>
<p id="rfc.section.A.1.p.1">The Foodle service choose to use the entity identifier <samp>https://foodl.org/</samp>. And upon deployment, Foodle is setup with a RSA key pair, with the following public key:</p>
<pre>{
  "kid": "key1",
  "use": "sig",
  "kty": "RSA",
  "alg": "RS256",
  "n": "pnXBOusEANuug6ewezb9J_XbxbSGEISyA75wBGkerPNg6WTXmmxJ-DV1U4sCu
RqhSdo3Uncmw6-01bZKCtAyRHT_TOZN2TMfNPRsfLkOstVofyfxg5oIWViLX9IDG_iZVd
q6_T6yOuufOIvqpaeBMwSKuDXHNa_DU0aUu_3kOAc5_2hD4Dq-XXtum-oix2EPkNSbFfP
qFIp5n4gS1XrzGzuNQiDw82k-H6mWN0wlVWfqLxJA9DZikAX7x9feipn36wxDH-XUlzDD
Ui3nfnC8GSkT-CYII3oZPsIgMV527iQGVsehIV9KqTF2FnaP83cqV9YgvMfhs1wrx4L3Z
-3B8Q",
  "e": "AQAB",
  "key_ops": ["verify"],
  "ext": true
}</pre>
<p id="rfc.section.A.1.p.2">Foodle offers a WebFinger interface and a metadata API according to this specification, with the ability to issue entity statements about itself.</p>
<h1 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> Federation setup</h1>
<p id="rfc.section.A.2.p.1">How trust is established and entities becomes part of a federation is out of scope of this specification. But it could involve some kind of non-technical contract, agreement or term of use that is established, followed by a federation or trust issuer that registers an entity identifier, public key and a set of metadata that restricts the delegated trust that is represented in the entity statement about the joining party.</p>
<p id="rfc.section.A.2.p.2">The following example, assumes the following trust relations are established, and the following entities are able to issue entity statements:</p>
<p></p>

<ul>
<li>Foodle issues an entity statement about itself</li>
<li>NTNU issues an entity statement about Foodle</li>
<li>SWAMID issues an entity statement about Foodle</li>
<li>Feide issues an entity statement about NTNU</li>
<li>eduGAIN issues an entity statement about Feide</li>
<li>eduGAIN issues an entity statement about SWAMID</li>
<li>SWAMID issues an entity statement about the university of Umea - an OpenID provider for employees and students at the university of Umea</li>
</ul>

<p>Foodle has a local trust root configuration that looks like this (notice that the exact format and content on the trust root configuration is out of scope of this specification):</p>
<pre>[
  {
    "sub": "https://www.sunet.se/swamid",
    "sub_meta": {"name": "SWAMID"},
    "metadata": {
      "openid-provider": {
        "loa_max": "http://swamid.se/LoA/substantial"
      }
    },
    "jwks": {
      "keys": [
        {
          "kty": "RSA",
          "alg": "RS256",
          "n": "v6xydqciFKGfvQaqYGmk9A7etbfvNY[...]",
          "e": "AQAB",
          "key_ops": ["verify"],
          "ext": true,
          "kid": "swamid",
          "use": "sig"
        }
      ]
    }
  }
]</pre>
<h1 id="rfc.appendix.A.3">
<a href="#rfc.appendix.A.3">A.3.</a> User chooses to login at Foodle</h1>
<p id="rfc.section.A.3.p.1">Let us assume a student from Ume&#229; would like to login at Foodle. Some sort of discovery process involves the end user choosing an OpenID provider. OpenID Discovery using the e-mail address is one option. Foodle presenting a list of available providers for the user to choose from is another.</p>
<p id="rfc.section.A.3.p.2">After the discovery process, Foodle knows that the user would like to login using the OpenID provider with entity identifier <samp>https://www.umu.se/openid</samp>.</p>
<h1 id="rfc.appendix.A.4">
<a href="#rfc.appendix.A.4">A.4.</a> Foodle discovers the OpenID provider</h1>
<p id="rfc.section.A.4.p.1">Foodle normalizes the entity identifier of the OpenID Provider, and performs a request to fetch the self-issued entity statement using the Federation API of the OpenID provider.</p>
<pre>
GET /.well-known/openid-federation?
iss=https%3A%2F%2Fumu.se%2Fopenid HTTP/1.1
Host: umu.se</pre>
<pre>HTTP/1.1 200 OK
Content-Type: application/json
["eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InVtdSJ9.eyJpYXQi..."]</pre>
<p id="rfc.section.A.4.p.2">The API endpoint returns a list of signed entity statements. In this case we look for a self-issued statement from the Ume&#229; university. We then decode and inspect the content:</p>
<pre>{
  "iat": 1539174048,
  "exp": 1539177648,
  "metadata": {
    "openid-provider": {
      "authorization_endpoint":
        "https://idp.umu.se/openid/authorization",
      "token_endpoint": "https://idp.umu.se/openid/token",
      "response_types_supported": ["code", "code id_token", "token"],
      "grant_types_supported": [
        "authorization_code",
        "implicit",
        "urn:ietf:params:oauth:grant-type:jwt-bearer"
      ],
      "subject_types_supported": ["pairwise", "public"],
      "id_token_signing_alg_values_supported": ["RS256"],
      "logo_uri":
        "https://www.umu.se/SRWStatic/img/umu-logo-left-neg-SE.svg",
      "policy_uri":
        "https://www.umu.se/en/about-the-website/legal-information/",
      "loa_max": "http://eidas.europa.eu/LoA/high"
    }
  },
  "iss": "https://umu.se/openid",
  "sub": "https://umu.se/openid",
  "authority_hints": {
    "https://www.sunet.se/swamid": ["https://edugain.org/oidc"],
    "https://kalmar2.org/openid": []
  },
  "jwks": {
    "keys": [
      {
        "kty": "RSA",
        "alg": "RS256",
        "n": "z1V1kyi6qwmXfKsfhVqKUMmQH3AixN[...]",
        "e": "AQAB",
        "key_ops": ["verify"],
        "ext": true,
        "kid": "umu",
        "use": "sig"
      }
    ]
  }
}</pre>
<h1 id="rfc.appendix.A.5">
<a href="#rfc.appendix.A.5">A.5.</a> Resolving the provider trust chain</h1>
<p id="rfc.section.A.5.p.1">In order to establish trust with this provider, the Foodle service provider would need to fetch sufficient entity statements to represent a complete chain from the self-issued statement to the locally configured trust root, which contains SWAMID.</p>
<p id="rfc.section.A.5.p.2">The information found in the authority_hints is critical in order to dynamically discover the trust chain. If such hints are not present, the relying party may resume to fixed configured trust roots to ask for trust statements.</p>
<p id="rfc.section.A.5.p.3">In this example, Foodle now fetches an entity statement from SWAMID using the Federation API endpoint of SWAMID, discovered in the authority_hints claim.</p>
<pre>
GET /.well-known/openid-federation?
iss=https%3A%2F%2Fwww.sunet.se%2Fswamid&amp;
sub=https%3A%2F%2Fumu.se%2Fopenid HTTP/1.1
Host: www.sunet.se</pre>
<pre>HTTP/1.1 200 OK
Content-Type: application/json
["eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImZlaWRlIn0.eyJp..."]</pre>
<p id="rfc.section.A.5.p.4">The decoded version of the entity statement is:</p>
<pre>{
  "iat": 1539174048,
  "exp": 1539177648,
  "metadata": {
    "openid-provider": {
      "subject_types_supported": ["pairwise"],
      "id_token_signing_alg_values_supported": ["RS256", "RS512"],
      "organization": "University of Ume?",
      "contacts": ["legal@umu.se", "technical@umu.se"]
    },
    "openid-client": {}
  },
  "iss": "https://www.sunet.se/swamid",
  "sub": "https://umu.se/openid",
  "sub_meta": {"name": "University of Ume?"},
  "jwks": {
    "keys": [
      {
        "kty": "RSA",
        "alg": "RS256",
        "n": "v6xydqciFKGfvQaqYGmk9A7etbfvNY[...]",
        "e": "AQAB",
        "key_ops": ["verify"],
        "ext": true,
        "kid": "swamid",
        "use": "sig"
      }
    ]
  }
}</pre>
<p id="rfc.section.A.5.p.5">Notice that the entity statement about University of Ume&#229; also contains an entry for openid_client metadata. This indicates that SWAMID expresses this university to be trusted to issue its own OpenID clients without the need for registering these directly in SWAMID.</p>
<p id="rfc.section.A.5.p.6">These two entity statements are sufficient to establish a path from the local configured trust anchor which trust SWAMID, to the self-issued statement from the University of Ume&#229;. Here are the steps performed to validate the trust chain:</p>
<p></p>

<ul>
<li>Find the trusted public keys for SWAMID in the local trust configuration.</li>
<li>Use these keys to validate the signature of the signed entity statement issued by SWAMID about the University of Ume&#229;</li>
<li>Check that the sub from the trust configuration matches the iss value of the first entity statement.</li>
<li>Extract the jwks entry from this entity statement. These are the signing keys of the University of Ume&#229;</li>
<li>Validate the self-signed statement from University of Ume&#229; using the keys found above.</li>
<li>Check that the sub from the previous statement matches the iss of the self-issued statement.</li>
<li>Check that the self-issued statement has the iss and sub to be the same.</li>
</ul>
<h1 id="rfc.appendix.A.6">
<a href="#rfc.appendix.A.6">A.6.</a> Extracting the provider metadata</h1>
<p id="rfc.section.A.6.p.1">The output from the trust chain validation is an ordered list of entity statements. In order to extract the needed metadata, we need to look at the metadata type relevant in the given context. In this case, we are establishing trust with an OpenID Provider, and we take a look at the <samp>openid_provider</samp> metadata object of the trust chain:</p>
<pre>[
  {"loa_max": "http://swamid.se/LoA/substantial"},
  {
    "subject_types_supported": ["pairwise"],
    "id_token_signing_alg_values_supported": ["RS256", "RS512"],
    "organization": "University of Ume?",
    "contacts": ["legal@umu.se", "technical@umu.se"]
  },
  {
    "authorization_endpoint":
     "https://idp.umu.se/openid/authorization",
    "token_endpoint": "https://idp.umu.se/openid/token",
    "response_types_supported": ["code", "code id_token", "token"],
    "grant_types_supported": [
      "authorization_code",
      "implicit",
      "urn:ietf:params:oauth:grant-type:jwt-bearer"
    ],
    "subject_types_supported": ["pairwise", "public"],
    "id_token_signing_alg_values_supported": ["RS256"],
    "logo_uri":
      "https://www.umu.se/SRWStatic/img/umu-logo-left-neg-SE.svg",
    "policy_uri":
      "https://www.umu.se/en/about-the-website/legal-information/",
    "loa_max": "http://eidas.europa.eu/LoA/high"
  }
]</pre>
<p id="rfc.section.A.6.p.2">The metadata flattening process converts this to a single metadata object. The resulting metadata in this case would be:</p>
<pre>{
  "organization": "University of Ume?",
  "contacts": ["legal@umu.se", "technical@umu.se"],
  "logo_uri":
    "https://www.umu.se/SRWStatic/img/umu-logo-left-neg-SE.svg",
  "policy_uri":
    "https://www.umu.se/en/about-the-website/legal-information/",
  "authorization_endpoint":
    "https://idp.umu.se/openid/authorization",
  "token_endpoint": "https://idp.umu.se/openid/token",
  "response_types_supported": ["code", "code id_token", "token"],
  "grant_types_supported": [
    "authorization_code",
    "implicit",
    "urn:ietf:params:oauth:grant-type:jwt-bearer"
  ],
  "subject_types_supported": ["pairwise"],
  "id_token_signing_alg_values_supported": ["RS256"],
  "loa_max": "http://swamid.se/LoA/substantial"
}</pre>
<h1 id="rfc.appendix.A.7">
<a href="#rfc.appendix.A.7">A.7.</a> RP sends authentication request (implicit registration)</h1>
<p id="rfc.section.A.7.p.1">Foodle after establishing trust with the University of Ume&#229; and extracted a resulting set of metadata, will send an authentication request to the OpenID provider. This example involves the implicit registration.</p>
<p id="rfc.section.A.7.p.2">Here is an example of an authentication request:</p>
<pre>GET /authorize?
  response_type=code
  &amp;scope=openid%20profile%20email
  &amp;client_id=https%3A%2F%2Ffoodl.org%2F
  &amp;state=2ff7e589-3848-46da-a3d2-949e1235e671
  &amp;redirect_uri=https%3A%2F%2Ffoodl.org%2Fopenid%2Fcallback HTTP/1.1
Host: idp.umu.se
</pre>
<p id="rfc.section.A.7.p.3">The provider receiving this authentication request will, unless the RP is cached or statically configured, start to dynamically fetch and establish trust with the RP.</p>
<h1 id="rfc.appendix.A.8">
<a href="#rfc.appendix.A.8">A.8.</a> Provider fetches entity statements</h1>
<p id="rfc.section.A.8.p.1">The provider needs to establish a trust chain for the RP from which a authentication was received. The provider in this example has the following configured trust root:</p>
<pre>[
  {
    "sub": "https://edugain.org/oidc",
    "metadata": {
      "openid-client": {
        "rp_scopes": ["openid", "userid-targetedid", "eduperson"],
        "response_types": ["code", "code id_token"]
      }
    },
    "jwks": {
      "keys": [
        {
          "kty": "RSA",
          "use": "sig",
          "alg": "RS256",
          "n": "qnd5_krrHKzuJzb5_YEt4sP-YOGSbf[...]",
          "e": "AQAB",
          "key_ops": ["verify"],
          "ext": true,
          "kid": "edugain"
        }
      ]
    }
  },
  {
    "sub": "https://www.sunet.se/swamid",
    "metadata": {
      "openid-client": {
        "rp_scopes": ["openid", "userid-persistent", "fs"],
        "response_types": ["code", "code id_token"]
      }
    },
    "jwks": {
      "keys": [
        {
          "kty": "RSA",
          "alg": "RS256",
          "n": "v6xydqciFKGfvQaqYGmk9A7etbfvNY[...]",
          "e": "AQAB",
          "key_ops": ["verify"],
          "ext": true,
          "kid": "swamid",
          "use": "sig"
        }
      ]
    }
  }
]
</pre>
<h1 id="rfc.appendix.A.9">
<a href="#rfc.appendix.A.9">A.9.</a> Provider fetches entity statements</h1>
<p id="rfc.section.A.9.p.1">The provider starts to resolve metadata for the client identifier https://foodl.org/ by fetching the self-issued entity statement using the Federation API.</p>
<p></p>
<p id="rfc.section.A.9.p.3">uses WebFinger, the metadata API endpoints and the authority_hints in order to establish a full trust chain to the trust root.</p>
<p id="rfc.section.A.9.p.4">In this case there are two possible trust chains:</p>
<p></p>

<ul>
<li>eduGAIN -&gt; Feide -&gt; NTNU -&gt; Foodle</li>
<li>SWAMID -&gt; Foodle</li>
</ul>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#Notices" id="Notices">Notices</a>
</h1>
<p id="rfc.section.B.p.1">Copyright (c) 2018 The OpenID Foundation.</p>
<p id="rfc.section.B.p.2">The OpenID Foundation (OIDF) grants to any Contributor, developer, implementer, or other interested party a non-exclusive, royalty free, worldwide copyright license to reproduce, prepare derivative works from, distribute, perform and display, this Implementers Draft or Final Specification solely for the purposes of (i) developing specifications, and (ii) implementing Implementers Drafts and Final Specifications based on such documents, provided that attribution be made to the OIDF as the source of the material, but that such attribution does not indicate an endorsement by the OIDF.</p>
<p id="rfc.section.B.p.3">The technology described in this specification was made available from contributions from various sources, including members of the OpenID Foundation and others. Although the OpenID Foundation has taken steps to help ensure that the technology is available for distribution, it takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this specification or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any independent effort to identify any such rights. The OpenID Foundation and the contributors to this specification make no (and hereby expressly disclaim any) warranties (express, implied, or otherwise), including implied warranties of merchantability, non-infringement, fitness for a particular purpose, or title, related to this specification, and the entire risk as to implementing this specification is assumed by the implementer. The OpenID Intellectual Property Rights policy requires contributors to offer a patent promise not to assert certain patent claims against other contributors and against implementers. The OpenID Foundation invites any interested party to bring to its attention any copyrights, patents, patent applications, or other proprietary rights that may cover technology that may be required to practice this specification.</p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#History" id="History">Document History</a>
</h1>
<p id="rfc.section.C.p.1">[[ To be removed from the final specification ]]</p>
<p id="rfc.section.C.p.2">-05 </p>

<ul><li>A major rewrite.</li></ul>
<p id="rfc.section.C.p.3">-04 </p>

<ul>
<li>Changed client metadata names <samp>scopes</samp> to <samp>rp_scopes</samp> and <samp>claims</samp> to <samp>rp_claims</samp>.</li>
<li>Added Open Issues appendix.</li>
<li>Added additional references.</li>
<li>Editorial improvements.</li>
<li>Added standard Notices section, which is present in all OpenID specifications.</li>
</ul>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Roland Hedberg</span> (editor)
	  <span class="n hidden">
		<span class="family-name">Hedberg</span>
	  </span>
	</span>
	<span class="org vcardline">independent</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:roland@catalogix.se">roland@catalogix.se</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Andreas &#197;kre Solberg</span> 
	  <span class="n hidden">
		<span class="family-name">Solberg</span>
	  </span>
	</span>
	<span class="org vcardline">Uninett AS</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:andreas.solberg@uninett.no">andreas.solberg@uninett.no</a></span>

<span class="vcardline">URI: <a href="https://www.linkedin.com/in/andreassolberg/">https://www.linkedin.com/in/andreassolberg/</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Samuel Gulliksson</span> 
	  <span class="n hidden">
		<span class="family-name">Gulliksson</span>
	  </span>
	</span>
	<span class="org vcardline">Schibsted Media Group</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:samuel.gulliksson@gmail.com">samuel.gulliksson@gmail.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Michael B. Jones</span> 
	  <span class="n hidden">
		<span class="family-name">Jones</span>
	  </span>
	</span>
	<span class="org vcardline">Microsoft</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:mbj@microsoft.com">mbj@microsoft.com</a></span>

<span class="vcardline">URI: <a href="http://self-issued.info/">http://self-issued.info/</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">John Bradley</span> 
	  <span class="n hidden">
		<span class="family-name">Bradley</span>
	  </span>
	</span>
	<span class="org vcardline">Ping Identity</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ve7jtb@ve7jtb.com">ve7jtb@ve7jtb.com</a></span>

<span class="vcardline">URI: <a href="http://www.thread-safe.com/">http://www.thread-safe.com/</a></span>

  </address>
</div>

</body>
</html>
